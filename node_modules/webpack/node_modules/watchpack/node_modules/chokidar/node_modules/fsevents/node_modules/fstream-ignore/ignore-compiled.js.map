{"version":3,"sources":["ignore.js"],"names":[],"mappings":"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","file":"ignore-compiled.js","sourcesContent":["// Essentially, this is a fstream.DirReader class, but with a\n// bit of special logic to read the specified sort of ignore files,\n// and a filter that prevents it from picking up anything excluded\n// by those files.\n\nvar Minimatch = require(\"minimatch\").Minimatch\n, fstream = require(\"fstream\")\n, DirReader = fstream.DirReader\n, inherits = require(\"inherits\")\n, path = require(\"path\")\n, fs = require(\"fs\")\n\nmodule.exports = IgnoreReader\n\ninherits(IgnoreReader, DirReader)\n\nfunction IgnoreReader (props) {\n  if (!(this instanceof IgnoreReader)) {\n    return new IgnoreReader(props)\n  }\n\n  // must be a Directory type\n  if (typeof props === \"string\") {\n    props = { path: path.resolve(props) }\n  }\n\n  props.type = \"Directory\"\n  props.Directory = true\n\n  if (!props.ignoreFiles) props.ignoreFiles = [\".ignore\"]\n  this.ignoreFiles = props.ignoreFiles\n\n  this.ignoreRules = null\n\n  // ensure that .ignore files always show up at the top of the list\n  // that way, they can be read before proceeding to handle other\n  // entries in that same folder\n  if (props.sort) {\n    this._sort = props.sort === \"alpha\" ? alphasort : props.sort\n    props.sort = null\n  }\n\n  this.on(\"entries\", function () {\n    // if there are any ignore files in the list, then\n    // pause and add them.\n    // then, filter the list based on our ignoreRules\n\n    var hasIg = this.entries.some(this.isIgnoreFile, this)\n\n    if (!hasIg) return this.filterEntries()\n\n    this.addIgnoreFiles()\n  })\n\n  // we filter entries before we know what they are.\n  // however, directories have to be re-tested against\n  // rules with a \"/\" appended, because \"a/b/\" will only\n  // match if \"a/b\" is a dir, and not otherwise.\n  this.on(\"_entryStat\", function (entry, props) {\n    var t = entry.basename\n    if (!this.applyIgnores(entry.basename,\n                           entry.type === \"Directory\",\n                           entry)) {\n      entry.abort()\n    }\n  }.bind(this))\n\n  DirReader.call(this, props)\n}\n\n\nIgnoreReader.prototype.addIgnoreFiles = function () {\n  if (this._paused) {\n    this.once(\"resume\", this.addIgnoreFiles)\n    return\n  }\n  if (this._ignoreFilesAdded) return\n  this._ignoreFilesAdded = true\n\n  var newIg = this.entries.filter(this.isIgnoreFile, this)\n  , count = newIg.length\n  , errState = null\n\n  if (!count) return\n\n  this.pause()\n\n  var then = function (er) {\n    if (errState) return\n    if (er) return this.emit(\"error\", errState = er)\n    if (-- count === 0) {\n      this.filterEntries()\n      this.resume()\n    } else {\n      this.addIgnoreFile(newIg[newIg.length - count], then)\n    }\n  }.bind(this)\n\n  this.addIgnoreFile(newIg[0], then)\n}\n\n\nIgnoreReader.prototype.isIgnoreFile = function (e) {\n  return e !== \".\" &&\n         e !== \"..\" &&\n         -1 !== this.ignoreFiles.indexOf(e)\n}\n\n\nIgnoreReader.prototype.getChildProps = function (stat) {\n  var props = DirReader.prototype.getChildProps.call(this, stat)\n  props.ignoreFiles = this.ignoreFiles\n\n  // Directories have to be read as IgnoreReaders\n  // otherwise fstream.Reader will create a DirReader instead.\n  if (stat.isDirectory()) {\n    props.type = this.constructor\n  }\n  return props\n}\n\n\nIgnoreReader.prototype.addIgnoreFile = function (e, cb) {\n  // read the file, and then call addIgnoreRules\n  // if there's an error, then tell the cb about it.\n\n  var ig = path.resolve(this.path, e)\n  fs.readFile(ig, function (er, data) {\n    if (er) return cb(er)\n\n    this.emit(\"ignoreFile\", e, data)\n    var rules = this.readRules(data, e)\n    this.addIgnoreRules(rules, e)\n    cb()\n  }.bind(this))\n}\n\n\nIgnoreReader.prototype.readRules = function (buf, e) {\n  return buf.toString().split(/\\r?\\n/)\n}\n\n\n// Override this to do fancier things, like read the\n// \"files\" array from a package.json file or something.\nIgnoreReader.prototype.addIgnoreRules = function (set, e) {\n  // filter out anything obvious\n  set = set.filter(function (s) {\n    s = s.trim()\n    return s && !s.match(/^#/)\n  })\n\n  // no rules to add!\n  if (!set.length) return\n\n  // now get a minimatch object for each one of these.\n  // Note that we need to allow dot files by default, and\n  // not switch the meaning of their exclusion\n  var mmopt = { matchBase: true, dot: true, flipNegate: true }\n  , mm = set.map(function (s) {\n    var m = new Minimatch(s, mmopt)\n    m.ignoreFile = e\n    return m\n  })\n\n  if (!this.ignoreRules) this.ignoreRules = []\n  this.ignoreRules.push.apply(this.ignoreRules, mm)\n}\n\n\nIgnoreReader.prototype.filterEntries = function () {\n  // this exclusion is at the point where we know the list of\n  // entries in the dir, but don't know what they are.  since\n  // some of them *might* be directories, we have to run the\n  // match in dir-mode as well, so that we'll pick up partials\n  // of files that will be included later.  Anything included\n  // at this point will be checked again later once we know\n  // what it is.\n  this.entries = this.entries.filter(function (entry) {\n    // at this point, we don't know if it's a dir or not.\n    return this.applyIgnores(entry) || this.applyIgnores(entry, true)\n  }, this)\n}\n\n\nIgnoreReader.prototype.applyIgnores = function (entry, partial, obj) {\n  var included = true\n\n  // this = /a/b/c\n  // entry = d\n  // parent /a/b sees c/d\n  if (this.parent && this.parent.applyIgnores) {\n    var pt = this.basename + \"/\" + entry\n    included = this.parent.applyIgnores(pt, partial)\n  }\n\n  // Negated Rules\n  // Since we're *ignoring* things here, negating means that a file\n  // is re-included, if it would have been excluded by a previous\n  // rule.  So, negated rules are only relevant if the file\n  // has been excluded.\n  //\n  // Similarly, if a file has been excluded, then there's no point\n  // trying it against rules that have already been applied\n  //\n  // We're using the \"flipnegate\" flag here, which tells minimatch\n  // to set the \"negate\" for our information, but still report\n  // whether the core pattern was a hit or a miss.\n\n  if (!this.ignoreRules) {\n    return included\n  }\n\n  this.ignoreRules.forEach(function (rule) {\n    // negation means inclusion\n    if (rule.negate && included ||\n        !rule.negate && !included) {\n      // unnecessary\n      return\n    }\n\n    // first, match against /foo/bar\n    var match = rule.match(\"/\" + entry)\n\n    if (!match) {\n      // try with the leading / trimmed off the test\n      // eg: foo/bar instead of /foo/bar\n      match = rule.match(entry)\n    }\n\n    // if the entry is a directory, then it will match\n    // with a trailing slash. eg: /foo/bar/ or foo/bar/\n    if (!match && partial) {\n      match = rule.match(\"/\" + entry + \"/\") ||\n              rule.match(entry + \"/\")\n    }\n\n    // When including a file with a negated rule, it's\n    // relevant if a directory partially matches, since\n    // it may then match a file within it.\n    // Eg, if you ignore /a, but !/a/b/c\n    if (!match && rule.negate && partial) {\n      match = rule.match(\"/\" + entry, true) ||\n              rule.match(entry, true)\n    }\n\n    if (match) {\n      included = rule.negate\n    }\n  }, this)\n\n  return included\n}\n\n\nIgnoreReader.prototype.sort = function (a, b) {\n  var aig = this.ignoreFiles.indexOf(a) !== -1\n  , big = this.ignoreFiles.indexOf(b) !== -1\n\n  if (aig && !big) return -1\n  if (big && !aig) return 1\n  return this._sort(a, b)\n}\n\nIgnoreReader.prototype._sort = function (a, b) {\n  return 0\n}\n\nfunction alphasort (a, b) {\n  return a === b ? 0\n       : a.toLowerCase() > b.toLowerCase() ? 1\n       : a.toLowerCase() < b.toLowerCase() ? -1\n       : a > b ? 1\n       : -1\n}\n"]}