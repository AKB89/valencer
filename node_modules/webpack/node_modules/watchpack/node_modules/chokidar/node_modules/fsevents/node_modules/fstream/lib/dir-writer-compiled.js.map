{"version":3,"sources":["dir-writer.js"],"names":[],"mappings":"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","file":"dir-writer-compiled.js","sourcesContent":["// It is expected that, when .add() returns false, the consumer\n// of the DirWriter will pause until a \"drain\" event occurs. Note\n// that this is *almost always going to be the case*, unless the\n// thing being written is some sort of unsupported type, and thus\n// skipped over.\n\nmodule.exports = DirWriter\n\nvar Writer = require('./writer.js')\nvar inherits = require('inherits')\nvar mkdir = require('mkdirp')\nvar path = require('path')\nvar collect = require('./collect.js')\n\ninherits(DirWriter, Writer)\n\nfunction DirWriter (props) {\n  var self = this\n  if (!(self instanceof DirWriter)) {\n    self.error('DirWriter must be called as constructor.', null, true)\n  }\n\n  // should already be established as a Directory type\n  if (props.type !== 'Directory' || !props.Directory) {\n    self.error('Non-directory type ' + props.type + ' ' +\n      JSON.stringify(props), null, true)\n  }\n\n  Writer.call(this, props)\n}\n\nDirWriter.prototype._create = function () {\n  var self = this\n  mkdir(self._path, Writer.dirmode, function (er) {\n    if (er) return self.error(er)\n    // ready to start getting entries!\n    self.ready = true\n    self.emit('ready')\n    self._process()\n  })\n}\n\n// a DirWriter has an add(entry) method, but its .write() doesn't\n// do anything.  Why a no-op rather than a throw?  Because this\n// leaves open the door for writing directory metadata for\n// gnu/solaris style dumpdirs.\nDirWriter.prototype.write = function () {\n  return true\n}\n\nDirWriter.prototype.end = function () {\n  this._ended = true\n  this._process()\n}\n\nDirWriter.prototype.add = function (entry) {\n  var self = this\n\n  // console.error('\\tadd', entry._path, '->', self._path)\n  collect(entry)\n  if (!self.ready || self._currentEntry) {\n    self._buffer.push(entry)\n    return false\n  }\n\n  // create a new writer, and pipe the incoming entry into it.\n  if (self._ended) {\n    return self.error('add after end')\n  }\n\n  self._buffer.push(entry)\n  self._process()\n\n  return this._buffer.length === 0\n}\n\nDirWriter.prototype._process = function () {\n  var self = this\n\n  // console.error('DW Process p=%j', self._processing, self.basename)\n\n  if (self._processing) return\n\n  var entry = self._buffer.shift()\n  if (!entry) {\n    // console.error(\"DW Drain\")\n    self.emit('drain')\n    if (self._ended) self._finish()\n    return\n  }\n\n  self._processing = true\n  // console.error(\"DW Entry\", entry._path)\n\n  self.emit('entry', entry)\n\n  // ok, add this entry\n  //\n  // don't allow recursive copying\n  var p = entry\n  var pp\n  do {\n    pp = p._path || p.path\n    if (pp === self.root._path || pp === self._path ||\n      (pp && pp.indexOf(self._path) === 0)) {\n      // console.error('DW Exit (recursive)', entry.basename, self._path)\n      self._processing = false\n      if (entry._collected) entry.pipe()\n      return self._process()\n    }\n    p = p.parent\n  } while (p)\n\n  // console.error(\"DW not recursive\")\n\n  // chop off the entry's root dir, replace with ours\n  var props = {\n    parent: self,\n    root: self.root || self,\n    type: entry.type,\n    depth: self.depth + 1\n  }\n\n  pp = entry._path || entry.path || entry.props.path\n  if (entry.parent) {\n    pp = pp.substr(entry.parent._path.length + 1)\n  }\n  // get rid of any ../../ shenanigans\n  props.path = path.join(self.path, path.join('/', pp))\n\n  // if i have a filter, the child should inherit it.\n  props.filter = self.filter\n\n  // all the rest of the stuff, copy over from the source.\n  Object.keys(entry.props).forEach(function (k) {\n    if (!props.hasOwnProperty(k)) {\n      props[k] = entry.props[k]\n    }\n  })\n\n  // not sure at this point what kind of writer this is.\n  var child = self._currentChild = new Writer(props)\n  child.on('ready', function () {\n    // console.error(\"DW Child Ready\", child.type, child._path)\n    // console.error(\"  resuming\", entry._path)\n    entry.pipe(child)\n    entry.resume()\n  })\n\n  // XXX Make this work in node.\n  // Long filenames should not break stuff.\n  child.on('error', function (er) {\n    if (child._swallowErrors) {\n      self.warn(er)\n      child.emit('end')\n      child.emit('close')\n    } else {\n      self.emit('error', er)\n    }\n  })\n\n  // we fire _end internally *after* end, so that we don't move on\n  // until any \"end\" listeners have had their chance to do stuff.\n  child.on('close', onend)\n  var ended = false\n  function onend () {\n    if (ended) return\n    ended = true\n    // console.error(\"* DW Child end\", child.basename)\n    self._currentChild = null\n    self._processing = false\n    self._process()\n  }\n}\n"]}