{"version":3,"sources":["build.js"],"names":[],"mappings":"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","file":"build-compiled.js","sourcesContent":["/*!\n * XRegExp.build 3.1.1\n * <xregexp.com>\n * Steven Levithan (c) 2012-2016 MIT License\n * Inspired by Lea Verou's RegExp.create <lea.verou.me>\n */\n\nmodule.exports = function(XRegExp) {\n    'use strict';\n\n    var REGEX_DATA = 'xregexp';\n    var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*]/g;\n    var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g');\n\n    /**\n     * Strips a leading `^` and trailing unescaped `$`, if both are present.\n     *\n     * @param {String} pattern Pattern to process.\n     * @returns {String} Pattern with edge anchors removed.\n     */\n    function deanchor(pattern) {\n        // Allow any number of empty noncapturing groups before/after anchors, because regexes\n        // built/generated by XRegExp sometimes include them\n        var leadingAnchor = /^(?:\\(\\?:\\))*\\^/,\n            trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n        if (\n            leadingAnchor.test(pattern) &&\n            trailingAnchor.test(pattern) &&\n            // Ensure that the trailing `$` isn't escaped\n            trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))\n        ) {\n            return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n        }\n\n        return pattern;\n    }\n\n    /**\n     * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n     *\n     * @param {String|RegExp} value Value to convert.\n     * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n     */\n    function asXRegExp(value) {\n        return XRegExp.isRegExp(value) ?\n            (value[REGEX_DATA] && value[REGEX_DATA].captureNames ?\n                // Don't recompile, to preserve capture names\n                value :\n                // Recompile as XRegExp\n                XRegExp(value.source)\n            ) :\n            // Compile string as XRegExp\n            XRegExp(value);\n    }\n\n    /**\n     * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n     * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n     * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n     *\n     * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n     *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n     *   character classes.\n     * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n     *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n     * @param {String} [flags] Any combination of XRegExp flags.\n     * @returns {RegExp} Regex with interpolated subpatterns.\n     * @example\n     *\n     * var time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n     *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n     *     h12: /1[0-2]|0?[1-9]/,\n     *     h24: /2[0-3]|[01][0-9]/\n     *   }, 'x'),\n     *   minutes: /^[0-5][0-9]$/\n     * });\n     * time.test('10:59'); // -> true\n     * XRegExp.exec('10:59', time).minutes; // -> '59'\n     */\n    XRegExp.build = function(pattern, subs, flags) {\n        var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern),\n            data = {},\n            numCaps = 0, // 'Caps' is short for captures\n            numPriorCaps,\n            numOuterCaps = 0,\n            outerCapsMap = [0],\n            outerCapNames,\n            sub,\n            p;\n\n        // Add flags within a leading mode modifier to the overall pattern's flags\n        if (inlineFlags) {\n            flags = flags || '';\n            inlineFlags[1].replace(/./g, function(flag) {\n                // Don't add duplicates\n                flags += (flags.indexOf(flag) > -1 ? '' : flag);\n            });\n        }\n\n        for (p in subs) {\n            if (subs.hasOwnProperty(p)) {\n                // Passing to XRegExp enables extended syntax and ensures independent validity,\n                // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n                // subpatterns provided as native regexes, it dies on octals and adds the property\n                // used to hold extended regex instance data, for simplicity\n                sub = asXRegExp(subs[p]);\n                data[p] = {\n                    // Deanchoring allows embedding independently useful anchored regexes. If you\n                    // really need to keep your anchors, double them (i.e., `^^...$$`)\n                    pattern: deanchor(sub.source),\n                    names: sub[REGEX_DATA].captureNames || []\n                };\n            }\n        }\n\n        // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n        // helps keep this simple. Named captures will be put back\n        pattern = asXRegExp(pattern);\n        outerCapNames = pattern[REGEX_DATA].captureNames || [];\n        pattern = pattern.source.replace(parts, function($0, $1, $2, $3, $4) {\n            var subName = $1 || $2,\n                capName,\n                intro,\n                localCapIndex;\n            // Named subpattern\n            if (subName) {\n                if (!data.hasOwnProperty(subName)) {\n                    throw new ReferenceError('Undefined property ' + $0);\n                }\n                // Named subpattern was wrapped in a capturing group\n                if ($1) {\n                    capName = outerCapNames[numOuterCaps];\n                    outerCapsMap[++numOuterCaps] = ++numCaps;\n                    // If it's a named group, preserve the name. Otherwise, use the subpattern name\n                    // as the capture name\n                    intro = '(?<' + (capName || subName) + '>';\n                } else {\n                    intro = '(?:';\n                }\n                numPriorCaps = numCaps;\n                return intro + data[subName].pattern.replace(subParts, function(match, paren, backref) {\n                    // Capturing group\n                    if (paren) {\n                        capName = data[subName].names[numCaps - numPriorCaps];\n                        ++numCaps;\n                        // If the current capture has a name, preserve the name\n                        if (capName) {\n                            return '(?<' + capName + '>';\n                        }\n                    // Backreference\n                    } else if (backref) {\n                        localCapIndex = +backref - 1;\n                        // Rewrite the backreference\n                        return data[subName].names[localCapIndex] ?\n                            // Need to preserve the backreference name in case using flag `n`\n                            '\\\\k<' + data[subName].names[localCapIndex] + '>' :\n                            '\\\\' + (+backref + numPriorCaps);\n                    }\n                    return match;\n                }) + ')';\n            }\n            // Capturing group\n            if ($3) {\n                capName = outerCapNames[numOuterCaps];\n                outerCapsMap[++numOuterCaps] = ++numCaps;\n                // If the current capture has a name, preserve the name\n                if (capName) {\n                    return '(?<' + capName + '>';\n                }\n            // Backreference\n            } else if ($4) {\n                localCapIndex = +$4 - 1;\n                // Rewrite the backreference\n                return outerCapNames[localCapIndex] ?\n                    // Need to preserve the backreference name in case using flag `n`\n                    '\\\\k<' + outerCapNames[localCapIndex] + '>' :\n                    '\\\\' + outerCapsMap[+$4];\n            }\n            return $0;\n        });\n\n        return XRegExp(pattern, flags);\n    };\n\n};\n"]}