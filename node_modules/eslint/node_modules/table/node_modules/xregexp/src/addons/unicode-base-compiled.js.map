{"version":3,"sources":["unicode-base.js"],"names":[],"mappings":"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","file":"unicode-base-compiled.js","sourcesContent":["/*!\n * XRegExp Unicode Base 3.1.1\n * <xregexp.com>\n * Steven Levithan (c) 2008-2016 MIT License\n */\n\nmodule.exports = function(XRegExp) {\n    'use strict';\n\n    /**\n     * Adds base support for Unicode matching:\n     * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n     *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n     *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n     * - Adds flag A (astral), which enables 21-bit Unicode support.\n     * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n     *\n     * Unicode Base relies on externally provided Unicode character data. Official addons are\n     * available to provide data for Unicode categories, scripts, blocks, and properties.\n     *\n     * @requires XRegExp\n     */\n\n    // ==--------------------------==\n    // Private stuff\n    // ==--------------------------==\n\n    // Storage for Unicode data\n    var unicode = {};\n\n    // Reuse utils\n    var dec = XRegExp._dec;\n    var hex = XRegExp._hex;\n    var pad4 = XRegExp._pad4;\n\n    // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n    function normalize(name) {\n        return name.replace(/[- _]+/g, '').toLowerCase();\n    }\n\n    // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n    function charCode(chr) {\n        var esc = /^\\\\[xu](.+)/.exec(chr);\n        return esc ?\n            dec(esc[1]) :\n            chr.charCodeAt(chr.charAt(0) === '\\\\' ? 1 : 0);\n    }\n\n    // Inverts a list of ordered BMP characters and ranges\n    function invertBmp(range) {\n        var output = '';\n        var lastEnd = -1;\n        XRegExp.forEach(\n            range,\n            /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/,\n            function(m) {\n                var start = charCode(m[1]);\n                if (start > (lastEnd + 1)) {\n                    output += '\\\\u' + pad4(hex(lastEnd + 1));\n                    if (start > (lastEnd + 2)) {\n                        output += '-\\\\u' + pad4(hex(start - 1));\n                    }\n                }\n                lastEnd = charCode(m[2] || m[1]);\n            }\n        );\n        if (lastEnd < 0xFFFF) {\n            output += '\\\\u' + pad4(hex(lastEnd + 1));\n            if (lastEnd < 0xFFFE) {\n                output += '-\\\\uFFFF';\n            }\n        }\n        return output;\n    }\n\n    // Generates an inverted BMP range on first use\n    function cacheInvertedBmp(slug) {\n        var prop = 'b!';\n        return unicode[slug][prop] || (\n            unicode[slug][prop] = invertBmp(unicode[slug].bmp)\n        );\n    }\n\n    // Combines and optionally negates BMP and astral data\n    function buildAstral(slug, isNegated) {\n        var item = unicode[slug],\n            combined = '';\n        if (item.bmp && !item.isBmpLast) {\n            combined = '[' + item.bmp + ']' + (item.astral ? '|' : '');\n        }\n        if (item.astral) {\n            combined += item.astral;\n        }\n        if (item.isBmpLast && item.bmp) {\n            combined += (item.astral ? '|' : '') + '[' + item.bmp + ']';\n        }\n        // Astral Unicode tokens always match a code point, never a code unit\n        return isNegated ?\n            '(?:(?!' + combined + ')(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))' :\n            '(?:' + combined + ')';\n    }\n\n    // Builds a complete astral pattern on first use\n    function cacheAstral(slug, isNegated) {\n        var prop = isNegated ? 'a!' : 'a=';\n        return unicode[slug][prop] || (\n            unicode[slug][prop] = buildAstral(slug, isNegated)\n        );\n    }\n\n    // ==--------------------------==\n    // Core functionality\n    // ==--------------------------==\n\n    /*\n     * Add Unicode token syntax: \\p{..}, \\P{..}, \\p{^..}. Also add astral mode (flag A).\n     */\n    XRegExp.addToken(\n        // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n        /\\\\([pP])(?:{(\\^?)([^}]*)}|([A-Za-z]))/,\n        function(match, scope, flags) {\n            var ERR_DOUBLE_NEG = 'Invalid double negation ',\n                ERR_UNKNOWN_NAME = 'Unknown Unicode token ',\n                ERR_UNKNOWN_REF = 'Unicode token missing data ',\n                ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ',\n                ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes',\n                // Negated via \\P{..} or \\p{^..}\n                isNegated = match[1] === 'P' || !!match[2],\n                // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n                isAstralMode = flags.indexOf('A') > -1,\n                // Token lookup name. Check `[4]` first to avoid passing `undefined` via `\\p{}`\n                slug = normalize(match[4] || match[3]),\n                // Token data object\n                item = unicode[slug];\n\n            if (match[1] === 'P' && match[2]) {\n                throw new SyntaxError(ERR_DOUBLE_NEG + match[0]);\n            }\n            if (!unicode.hasOwnProperty(slug)) {\n                throw new SyntaxError(ERR_UNKNOWN_NAME + match[0]);\n            }\n\n            // Switch to the negated form of the referenced Unicode token\n            if (item.inverseOf) {\n                slug = normalize(item.inverseOf);\n                if (!unicode.hasOwnProperty(slug)) {\n                    throw new ReferenceError(ERR_UNKNOWN_REF + match[0] + ' -> ' + item.inverseOf);\n                }\n                item = unicode[slug];\n                isNegated = !isNegated;\n            }\n\n            if (!(item.bmp || isAstralMode)) {\n                throw new SyntaxError(ERR_ASTRAL_ONLY + match[0]);\n            }\n            if (isAstralMode) {\n                if (scope === 'class') {\n                    throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n                }\n\n                return cacheAstral(slug, isNegated);\n            }\n\n            return scope === 'class' ?\n                (isNegated ? cacheInvertedBmp(slug) : item.bmp) :\n                (isNegated ? '[^' : '[') + item.bmp + ']';\n        },\n        {\n            scope: 'all',\n            optionalFlags: 'A',\n            leadChar: '\\\\'\n        }\n    );\n\n    /**\n     * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n     *\n     * @param {Array} data Objects with named character ranges. Each object may have properties\n     *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n     *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n     *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n     *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n     *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n     *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n     *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n     *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n     *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n     *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n     *   character classes and alternation, and should use surrogate pairs to represent astral code\n     *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n     *   defined as the exact inverse of another token.\n     * @example\n     *\n     * // Basic use\n     * XRegExp.addUnicodeData([{\n     *   name: 'XDigit',\n     *   alias: 'Hexadecimal',\n     *   bmp: '0-9A-Fa-f'\n     * }]);\n     * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n     */\n    XRegExp.addUnicodeData = function(data) {\n        var ERR_NO_NAME = 'Unicode token requires name',\n            ERR_NO_DATA = 'Unicode token has no character data ',\n            item,\n            i;\n\n        for (i = 0; i < data.length; ++i) {\n            item = data[i];\n            if (!item.name) {\n                throw new Error(ERR_NO_NAME);\n            }\n            if (!(item.inverseOf || item.bmp || item.astral)) {\n                throw new Error(ERR_NO_DATA + item.name);\n            }\n            unicode[normalize(item.name)] = item;\n            if (item.alias) {\n                unicode[normalize(item.alias)] = item;\n            }\n        }\n\n        // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n        // flags might now produce different results\n        XRegExp.cache.flush('patterns');\n    };\n\n};\n"]}