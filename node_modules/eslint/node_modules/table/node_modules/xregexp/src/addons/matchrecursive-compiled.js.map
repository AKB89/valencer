{"version":3,"sources":["matchrecursive.js"],"names":[],"mappings":"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","file":"matchrecursive-compiled.js","sourcesContent":["/*!\n * XRegExp.matchRecursive 3.1.1\n * <xregexp.com>\n * Steven Levithan (c) 2009-2016 MIT License\n */\n\nmodule.exports = function(XRegExp) {\n    'use strict';\n\n    /**\n     * Returns a match detail object composed of the provided values.\n     */\n    function row(name, value, start, end) {\n        return {\n            name: name,\n            value: value,\n            start: start,\n            end: end\n        };\n    }\n\n    /**\n     * Returns an array of match strings between outermost left and right delimiters, or an array of\n     * objects with detailed match parts and position data. An error is thrown if delimiters are\n     * unbalanced within the data.\n     *\n     * @param {String} str String to search.\n     * @param {String} left Left delimiter as an XRegExp pattern.\n     * @param {String} right Right delimiter as an XRegExp pattern.\n     * @param {String} [flags] Any native or XRegExp flags, used for the left and right delimiters.\n     * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n     * @returns {Array} Array of matches, or an empty array.\n     * @example\n     *\n     * // Basic usage\n     * var str = '(t((e))s)t()(ing)';\n     * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n     * // -> ['t((e))s', '', 'ing']\n     *\n     * // Extended information mode with valueNames\n     * str = 'Here is <div> <div>an</div></div> example';\n     * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n     *   valueNames: ['between', 'left', 'match', 'right']\n     * });\n     * // -> [\n     * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n     * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n     * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n     * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n     * // {name: 'between', value: ' example',       start: 33, end: 41}\n     * // ]\n     *\n     * // Omitting unneeded parts with null valueNames, and using escapeChar\n     * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n     * XRegExp.matchRecursive(str, '{', '}', 'g', {\n     *   valueNames: ['literal', null, 'value', null],\n     *   escapeChar: '\\\\'\n     * });\n     * // -> [\n     * // {name: 'literal', value: '...',  start: 0, end: 3},\n     * // {name: 'value',   value: '1',    start: 4, end: 5},\n     * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n     * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n     * // ]\n     *\n     * // Sticky mode via flag y\n     * str = '<1><<<2>>><3>4<5>';\n     * XRegExp.matchRecursive(str, '<', '>', 'gy');\n     * // -> ['1', '<<2>>', '3']\n     */\n    XRegExp.matchRecursive = function(str, left, right, flags, options) {\n        flags = flags || '';\n        options = options || {};\n        var global = flags.indexOf('g') > -1,\n            sticky = flags.indexOf('y') > -1,\n            // Flag `y` is controlled internally\n            basicFlags = flags.replace(/y/g, ''),\n            escapeChar = options.escapeChar,\n            vN = options.valueNames,\n            output = [],\n            openTokens = 0,\n            delimStart = 0,\n            delimEnd = 0,\n            lastOuterEnd = 0,\n            outerStart,\n            innerStart,\n            leftMatch,\n            rightMatch,\n            esc;\n        left = XRegExp(left, basicFlags);\n        right = XRegExp(right, basicFlags);\n\n        if (escapeChar) {\n            if (escapeChar.length > 1) {\n                throw new Error('Cannot use more than one escape character');\n            }\n            escapeChar = XRegExp.escape(escapeChar);\n            // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`\n            esc = new RegExp(\n                '(?:' + escapeChar + '[\\\\S\\\\s]|(?:(?!' +\n                    XRegExp.union([left, right]).source +\n                    ')[^' + escapeChar + '])+)+',\n                // Flags `gy` not needed here\n                flags.replace(/[^imu]+/g, '')\n            );\n        }\n\n        while (true) {\n            // If using an escape character, advance to the delimiter's next starting position,\n            // skipping any escaped characters in between\n            if (escapeChar) {\n                delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n            }\n            leftMatch = XRegExp.exec(str, left, delimEnd);\n            rightMatch = XRegExp.exec(str, right, delimEnd);\n            // Keep the leftmost match only\n            if (leftMatch && rightMatch) {\n                if (leftMatch.index <= rightMatch.index) {\n                    rightMatch = null;\n                } else {\n                    leftMatch = null;\n                }\n            }\n            // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n            // LM | RM | OT | Result\n            // 1  | 0  | 1  | loop\n            // 1  | 0  | 0  | loop\n            // 0  | 1  | 1  | loop\n            // 0  | 1  | 0  | throw\n            // 0  | 0  | 1  | throw\n            // 0  | 0  | 0  | break\n            // The paths above don't include the sticky mode special case. The loop ends after the\n            // first completed match if not `global`.\n            if (leftMatch || rightMatch) {\n                delimStart = (leftMatch || rightMatch).index;\n                delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n            } else if (!openTokens) {\n                break;\n            }\n            if (sticky && !openTokens && delimStart > lastOuterEnd) {\n                break;\n            }\n            if (leftMatch) {\n                if (!openTokens) {\n                    outerStart = delimStart;\n                    innerStart = delimEnd;\n                }\n                ++openTokens;\n            } else if (rightMatch && openTokens) {\n                if (!--openTokens) {\n                    if (vN) {\n                        if (vN[0] && outerStart > lastOuterEnd) {\n                            output.push(row(vN[0], str.slice(lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n                        }\n                        if (vN[1]) {\n                            output.push(row(vN[1], str.slice(outerStart, innerStart), outerStart, innerStart));\n                        }\n                        if (vN[2]) {\n                            output.push(row(vN[2], str.slice(innerStart, delimStart), innerStart, delimStart));\n                        }\n                        if (vN[3]) {\n                            output.push(row(vN[3], str.slice(delimStart, delimEnd), delimStart, delimEnd));\n                        }\n                    } else {\n                        output.push(str.slice(innerStart, delimStart));\n                    }\n                    lastOuterEnd = delimEnd;\n                    if (!global) {\n                        break;\n                    }\n                }\n            } else {\n                throw new Error('Unbalanced delimiter found in string');\n            }\n            // If the delimiter matched an empty string, avoid an infinite loop\n            if (delimStart === delimEnd) {\n                ++delimEnd;\n            }\n        }\n\n        if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n            output.push(row(vN[0], str.slice(lastOuterEnd), lastOuterEnd, str.length));\n        }\n\n        return output;\n    };\n\n};\n"]}