{"version":3,"sources":["xregexp.js"],"names":[],"mappings":"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","file":"xregexp-compiled.js","sourcesContent":["/*!\n * XRegExp 3.1.1\n * <xregexp.com>\n * Steven Levithan (c) 2007-2016 MIT License\n */\n\n'use strict';\n\n/**\n * XRegExp provides augmented, extensible regular expressions. You get additional regex syntax and\n * flags, beyond what browsers support natively. XRegExp is also a regex utility belt with tools to\n * make your client-side grepping simpler and more powerful, while freeing you from related\n * cross-browser inconsistencies.\n */\n\n// ==--------------------------==\n// Private stuff\n// ==--------------------------==\n\n// Property name used for extended regex instance data\nvar REGEX_DATA = 'xregexp';\n// Optional features that can be installed and uninstalled\nvar features = {\n    astral: false,\n    natives: false\n};\n// Native methods to use and restore ('native' is an ES3 reserved keyword)\nvar nativ = {\n    exec: RegExp.prototype.exec,\n    test: RegExp.prototype.test,\n    match: String.prototype.match,\n    replace: String.prototype.replace,\n    split: String.prototype.split\n};\n// Storage for fixed/extended native methods\nvar fixed = {};\n// Storage for regexes cached by `XRegExp.cache`\nvar regexCache = {};\n// Storage for pattern details cached by the `XRegExp` constructor\nvar patternCache = {};\n// Storage for regex syntax tokens added internally or by `XRegExp.addToken`\nvar tokens = [];\n// Token scopes\nvar defaultScope = 'default';\nvar classScope = 'class';\n// Regexes that match native regex syntax, including octals\nvar nativeTokens = {\n    // Any native multicharacter token in default scope, or any single character\n    'default': /\\\\(?:0(?:[0-3][0-7]{0,2}|[4-7][0-7]?)?|[1-9]\\d*|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|\\(\\?(?:[:=!]|<[=!])|[?*+]\\?|{\\d+(?:,\\d*)?}\\??|[\\s\\S]/,\n    // Any native multicharacter token in character class scope, or any single character\n    'class': /\\\\(?:[0-3][0-7]{0,2}|[4-7][0-7]?|x[\\dA-Fa-f]{2}|u(?:[\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|c[A-Za-z]|[\\s\\S])|[\\s\\S]/\n};\n// Any backreference or dollar-prefixed character in replacement strings\nvar replacementToken = /\\$(?:{([\\w$]+)}|(\\d\\d?|[\\s\\S]))/g;\n// Check for correct `exec` handling of nonparticipating capturing groups\nvar correctExecNpcg = nativ.exec.call(/()??/, '')[1] === undefined;\n// Check for ES6 `flags` prop support\nvar hasFlagsProp = /x/.flags !== undefined;\n// Shortcut to `Object.prototype.toString`\nvar toString = {}.toString;\n\nfunction hasNativeFlag(flag) {\n    // Can't check based on the presense of properties/getters since browsers might support such\n    // properties even when they don't support the corresponding flag in regex construction (tested\n    // in Chrome 48, where `'unicode' in /x/` is true but trying to construct a regex with flag `u`\n    // throws an error)\n    var isSupported = true;\n    try {\n        // Can't use regex literals for testing even in a `try` because regex literals with\n        // unsupported flags cause a compilation error in IE\n        new RegExp('', flag);\n    } catch (exception) {\n        isSupported = false;\n    }\n    if (isSupported && flag === 'y') {\n        // Work around Safari 9.1.1 bug\n        return new RegExp('aa|.', 'y').test('b');\n    }\n    return isSupported;\n}\n// Check for ES6 `u` flag support\nvar hasNativeU = hasNativeFlag('u');\n// Check for ES6 `y` flag support\nvar hasNativeY = hasNativeFlag('y');\n// Tracker for known flags, including addon flags\nvar registeredFlags = {\n    g: true,\n    i: true,\n    m: true,\n    u: hasNativeU,\n    y: hasNativeY\n};\n\n/**\n * Attaches extended data and `XRegExp.prototype` properties to a regex object.\n *\n * @param {RegExp} regex Regex to augment.\n * @param {Array} captureNames Array with capture names, or `null`.\n * @param {String} xSource XRegExp pattern used to generate `regex`, or `null` if N/A.\n * @param {String} xFlags XRegExp flags used to generate `regex`, or `null` if N/A.\n * @param {Boolean} [isInternalOnly=false] Whether the regex will be used only for internal\n *   operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *   skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Augmented regex.\n */\nfunction augment(regex, captureNames, xSource, xFlags, isInternalOnly) {\n    var p;\n\n    regex[REGEX_DATA] = {\n        captureNames: captureNames\n    };\n\n    if (isInternalOnly) {\n        return regex;\n    }\n\n    // Can't auto-inherit these since the XRegExp constructor returns a nonprimitive value\n    if (regex.__proto__) {\n        regex.__proto__ = XRegExp.prototype;\n    } else {\n        for (p in XRegExp.prototype) {\n            // An `XRegExp.prototype.hasOwnProperty(p)` check wouldn't be worth it here, since this\n            // is performance sensitive, and enumerable `Object.prototype` or `RegExp.prototype`\n            // extensions exist on `regex.prototype` anyway\n            regex[p] = XRegExp.prototype[p];\n        }\n    }\n\n    regex[REGEX_DATA].source = xSource;\n    // Emulate the ES6 `flags` prop by ensuring flags are in alphabetical order\n    regex[REGEX_DATA].flags = xFlags ? xFlags.split('').sort().join('') : xFlags;\n\n    return regex;\n}\n\n/**\n * Removes any duplicate characters from the provided string.\n *\n * @param {String} str String to remove duplicate characters from.\n * @returns {String} String with any duplicate characters removed.\n */\nfunction clipDuplicates(str) {\n    return nativ.replace.call(str, /([\\s\\S])(?=[\\s\\S]*\\1)/g, '');\n}\n\n/**\n * Copies a regex object while preserving extended data and augmenting with `XRegExp.prototype`\n * properties. The copy has a fresh `lastIndex` property (set to zero). Allows adding and removing\n * flags g and y while copying the regex.\n *\n * @param {RegExp} regex Regex to copy.\n * @param {Object} [options] Options object with optional properties:\n *   <li>`addG` {Boolean} Add flag g while copying the regex.\n *   <li>`addY` {Boolean} Add flag y while copying the regex.\n *   <li>`removeG` {Boolean} Remove flag g while copying the regex.\n *   <li>`removeY` {Boolean} Remove flag y while copying the regex.\n *   <li>`isInternalOnly` {Boolean} Whether the copied regex will be used only for internal\n *     operations, and never exposed to users. For internal-only regexes, we can improve perf by\n *     skipping some operations like attaching `XRegExp.prototype` properties.\n * @returns {RegExp} Copy of the provided regex, possibly with modified flags.\n */\nfunction copyRegex(regex, options) {\n    if (!XRegExp.isRegExp(regex)) {\n        throw new TypeError('Type RegExp expected');\n    }\n\n    var xData = regex[REGEX_DATA] || {},\n        flags = getNativeFlags(regex),\n        flagsToAdd = '',\n        flagsToRemove = '',\n        xregexpSource = null,\n        xregexpFlags = null;\n\n    options = options || {};\n\n    if (options.removeG) {flagsToRemove += 'g';}\n    if (options.removeY) {flagsToRemove += 'y';}\n    if (flagsToRemove) {\n        flags = nativ.replace.call(flags, new RegExp('[' + flagsToRemove + ']+', 'g'), '');\n    }\n\n    if (options.addG) {flagsToAdd += 'g';}\n    if (options.addY) {flagsToAdd += 'y';}\n    if (flagsToAdd) {\n        flags = clipDuplicates(flags + flagsToAdd);\n    }\n\n    if (!options.isInternalOnly) {\n        if (xData.source !== undefined) {\n            xregexpSource = xData.source;\n        }\n        // null or undefined; don't want to add to `flags` if the previous value was null, since\n        // that indicates we're not tracking original precompilation flags\n        if (xData.flags != null) {\n            // Flags are only added for non-internal regexes by `XRegExp.globalize`. Flags are never\n            // removed for non-internal regexes, so don't need to handle it\n            xregexpFlags = flagsToAdd ? clipDuplicates(xData.flags + flagsToAdd) : xData.flags;\n        }\n    }\n\n    // Augment with `XRegExp.prototype` properties, but use the native `RegExp` constructor to avoid\n    // searching for special tokens. That would be wrong for regexes constructed by `RegExp`, and\n    // unnecessary for regexes constructed by `XRegExp` because the regex has already undergone the\n    // translation to native regex syntax\n    regex = augment(\n        new RegExp(regex.source, flags),\n        hasNamedCapture(regex) ? xData.captureNames.slice(0) : null,\n        xregexpSource,\n        xregexpFlags,\n        options.isInternalOnly\n    );\n\n    return regex;\n}\n\n/**\n * Converts hexadecimal to decimal.\n *\n * @param {String} hex\n * @returns {Number}\n */\nfunction dec(hex) {\n    return parseInt(hex, 16);\n}\n\n/**\n * Returns native `RegExp` flags used by a regex object.\n *\n * @param {RegExp} regex Regex to check.\n * @returns {String} Native flags in use.\n */\nfunction getNativeFlags(regex) {\n    return hasFlagsProp ?\n        regex.flags :\n        // Explicitly using `RegExp.prototype.toString` (rather than e.g. `String` or concatenation\n        // with an empty string) allows this to continue working predictably when\n        // `XRegExp.proptotype.toString` is overriden\n        nativ.exec.call(/\\/([a-z]*)$/i, RegExp.prototype.toString.call(regex))[1];\n}\n\n/**\n * Determines whether a regex has extended instance data used to track capture names.\n *\n * @param {RegExp} regex Regex to check.\n * @returns {Boolean} Whether the regex uses named capture.\n */\nfunction hasNamedCapture(regex) {\n    return !!(regex[REGEX_DATA] && regex[REGEX_DATA].captureNames);\n}\n\n/**\n * Converts decimal to hexadecimal.\n *\n * @param {Number|String} dec\n * @returns {String}\n */\nfunction hex(dec) {\n    return parseInt(dec, 10).toString(16);\n}\n\n/**\n * Returns the first index at which a given value can be found in an array.\n *\n * @param {Array} array Array to search.\n * @param {*} value Value to locate in the array.\n * @returns {Number} Zero-based index at which the item is found, or -1.\n */\nfunction indexOf(array, value) {\n    var len = array.length, i;\n\n    for (i = 0; i < len; ++i) {\n        if (array[i] === value) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n/**\n * Determines whether a value is of the specified type, by resolving its internal [[Class]].\n *\n * @param {*} value Object to check.\n * @param {String} type Type to check for, in TitleCase.\n * @returns {Boolean} Whether the object matches the type.\n */\nfunction isType(value, type) {\n    return toString.call(value) === '[object ' + type + ']';\n}\n\n/**\n * Checks whether the next nonignorable token after the specified position is a quantifier.\n *\n * @param {String} pattern Pattern to search within.\n * @param {Number} pos Index in `pattern` to search at.\n * @param {String} flags Flags used by the pattern.\n * @returns {Boolean} Whether the next token is a quantifier.\n */\nfunction isQuantifierNext(pattern, pos, flags) {\n    return nativ.test.call(\n        flags.indexOf('x') > -1 ?\n            // Ignore any leading whitespace, line comments, and inline comments\n            /^(?:\\s|#[^#\\n]*|\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/ :\n            // Ignore any leading inline comments\n            /^(?:\\(\\?#[^)]*\\))*(?:[?*+]|{\\d+(?:,\\d*)?})/,\n        pattern.slice(pos)\n    );\n}\n\n/**\n * Adds leading zeros if shorter than four characters. Used for fixed-length hexadecimal values.\n *\n * @param {String} str\n * @returns {String}\n */\nfunction pad4(str) {\n    while (str.length < 4) {\n        str = '0' + str;\n    }\n    return str;\n}\n\n/**\n * Checks for flag-related errors, and strips/applies flags in a leading mode modifier. Offloads\n * the flag preparation logic from the `XRegExp` constructor.\n *\n * @param {String} pattern Regex pattern, possibly with a leading mode modifier.\n * @param {String} flags Any combination of flags.\n * @returns {Object} Object with properties `pattern` and `flags`.\n */\nfunction prepareFlags(pattern, flags) {\n    var i;\n\n    // Recent browsers throw on duplicate flags, so copy this behavior for nonnative flags\n    if (clipDuplicates(flags) !== flags) {\n        throw new SyntaxError('Invalid duplicate regex flag ' + flags);\n    }\n\n    // Strip and apply a leading mode modifier with any combination of flags except g or y\n    pattern = nativ.replace.call(pattern, /^\\(\\?([\\w$]+)\\)/, function($0, $1) {\n        if (nativ.test.call(/[gy]/, $1)) {\n            throw new SyntaxError('Cannot use flag g or y in mode modifier ' + $0);\n        }\n        // Allow duplicate flags within the mode modifier\n        flags = clipDuplicates(flags + $1);\n        return '';\n    });\n\n    // Throw on unknown native or nonnative flags\n    for (i = 0; i < flags.length; ++i) {\n        if (!registeredFlags[flags.charAt(i)]) {\n            throw new SyntaxError('Unknown regex flag ' + flags.charAt(i));\n        }\n    }\n\n    return {\n        pattern: pattern,\n        flags: flags\n    };\n}\n\n/**\n * Prepares an options object from the given value.\n *\n * @param {String|Object} value Value to convert to an options object.\n * @returns {Object} Options object.\n */\nfunction prepareOptions(value) {\n    var options = {};\n\n    if (isType(value, 'String')) {\n        XRegExp.forEach(value, /[^\\s,]+/, function(match) {\n            options[match] = true;\n        });\n\n        return options;\n    }\n\n    return value;\n}\n\n/**\n * Registers a flag so it doesn't throw an 'unknown flag' error.\n *\n * @param {String} flag Single-character flag to register.\n */\nfunction registerFlag(flag) {\n    if (!/^[\\w$]$/.test(flag)) {\n        throw new Error('Flag must be a single character A-Za-z0-9_$');\n    }\n\n    registeredFlags[flag] = true;\n}\n\n/**\n * Runs built-in and custom regex syntax tokens in reverse insertion order at the specified\n * position, until a match is found.\n *\n * @param {String} pattern Original pattern from which an XRegExp object is being built.\n * @param {String} flags Flags being used to construct the regex.\n * @param {Number} pos Position to search for tokens within `pattern`.\n * @param {Number} scope Regex scope to apply: 'default' or 'class'.\n * @param {Object} context Context object to use for token handler functions.\n * @returns {Object} Object with properties `matchLength`, `output`, and `reparse`; or `null`.\n */\nfunction runTokens(pattern, flags, pos, scope, context) {\n    var i = tokens.length,\n        leadChar = pattern.charAt(pos),\n        result = null,\n        match,\n        t;\n\n    // Run in reverse insertion order\n    while (i--) {\n        t = tokens[i];\n        if (\n            (t.leadChar && t.leadChar !== leadChar) ||\n            (t.scope !== scope && t.scope !== 'all') ||\n            (t.flag && flags.indexOf(t.flag) === -1)\n        ) {\n            continue;\n        }\n\n        match = XRegExp.exec(pattern, t.regex, pos, 'sticky');\n        if (match) {\n            result = {\n                matchLength: match[0].length,\n                output: t.handler.call(context, match, scope, flags),\n                reparse: t.reparse\n            };\n            // Finished with token tests\n            break;\n        }\n    }\n\n    return result;\n}\n\n/**\n * Enables or disables implicit astral mode opt-in. When enabled, flag A is automatically added to\n * all new regexes created by XRegExp. This causes an error to be thrown when creating regexes if\n * the Unicode Base addon is not available, since flag A is registered by that addon.\n *\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\nfunction setAstral(on) {\n    features.astral = on;\n}\n\n/**\n * Enables or disables native method overrides.\n *\n * @param {Boolean} on `true` to enable; `false` to disable.\n */\nfunction setNatives(on) {\n    RegExp.prototype.exec = (on ? fixed : nativ).exec;\n    RegExp.prototype.test = (on ? fixed : nativ).test;\n    String.prototype.match = (on ? fixed : nativ).match;\n    String.prototype.replace = (on ? fixed : nativ).replace;\n    String.prototype.split = (on ? fixed : nativ).split;\n\n    features.natives = on;\n}\n\n/**\n * Returns the object, or throws an error if it is `null` or `undefined`. This is used to follow\n * the ES5 abstract operation `ToObject`.\n *\n * @param {*} value Object to check and return.\n * @returns {*} The provided object.\n */\nfunction toObject(value) {\n    // null or undefined\n    if (value == null) {\n        throw new TypeError('Cannot convert null or undefined to object');\n    }\n\n    return value;\n}\n\n// ==--------------------------==\n// Constructor\n// ==--------------------------==\n\n/**\n * Creates an extended regular expression object for matching text with a pattern. Differs from a\n * native regular expression in that additional syntax and flags are supported. The returned object\n * is in fact a native `RegExp` and works with all native methods.\n *\n * @class XRegExp\n * @constructor\n * @param {String|RegExp} pattern Regex pattern string, or an existing regex object to copy.\n * @param {String} [flags] Any combination of flags.\n *   Native flags:\n *     <li>`g` - global\n *     <li>`i` - ignore case\n *     <li>`m` - multiline anchors\n *     <li>`u` - unicode (ES6)\n *     <li>`y` - sticky (Firefox 3+, ES6)\n *   Additional XRegExp flags:\n *     <li>`n` - explicit capture\n *     <li>`s` - dot matches all (aka singleline)\n *     <li>`x` - free-spacing and line comments (aka extended)\n *     <li>`A` - astral (requires the Unicode Base addon)\n *   Flags cannot be provided when constructing one `RegExp` from another.\n * @returns {RegExp} Extended regular expression object.\n * @example\n *\n * // With named capture and flag x\n * XRegExp('(?<year>  [0-9]{4} ) -?  # year  \\n\\\n *          (?<month> [0-9]{2} ) -?  # month \\n\\\n *          (?<day>   [0-9]{2} )     # day   ', 'x');\n *\n * // Providing a regex object copies it. Native regexes are recompiled using native (not XRegExp)\n * // syntax. Copies maintain extended data, are augmented with `XRegExp.prototype` properties, and\n * // have fresh `lastIndex` properties (set to zero).\n * XRegExp(/regex/);\n */\nfunction XRegExp(pattern, flags) {\n    if (XRegExp.isRegExp(pattern)) {\n        if (flags !== undefined) {\n            throw new TypeError('Cannot supply flags when copying a RegExp');\n        }\n        return copyRegex(pattern);\n    }\n\n    // Copy the argument behavior of `RegExp`\n    pattern = pattern === undefined ? '' : String(pattern);\n    flags = flags === undefined ? '' : String(flags);\n\n    if (XRegExp.isInstalled('astral') && flags.indexOf('A') === -1) {\n        // This causes an error to be thrown if the Unicode Base addon is not available\n        flags += 'A';\n    }\n\n    if (!patternCache[pattern]) {\n        patternCache[pattern] = {};\n    }\n\n    if (!patternCache[pattern][flags]) {\n        var context = {\n            hasNamedCapture: false,\n            captureNames: []\n        };\n        var scope = defaultScope;\n        var output = '';\n        var pos = 0;\n        var result;\n\n        // Check for flag-related errors, and strip/apply flags in a leading mode modifier\n        var applied = prepareFlags(pattern, flags);\n        var appliedPattern = applied.pattern;\n        var appliedFlags = applied.flags;\n\n        // Use XRegExp's tokens to translate the pattern to a native regex pattern.\n        // `appliedPattern.length` may change on each iteration if tokens use `reparse`\n        while (pos < appliedPattern.length) {\n            do {\n                // Check for custom tokens at the current position\n                result = runTokens(appliedPattern, appliedFlags, pos, scope, context);\n                // If the matched token used the `reparse` option, splice its output into the\n                // pattern before running tokens again at the same position\n                if (result && result.reparse) {\n                    appliedPattern = appliedPattern.slice(0, pos) +\n                        result.output +\n                        appliedPattern.slice(pos + result.matchLength);\n                }\n            } while (result && result.reparse);\n\n            if (result) {\n                output += result.output;\n                pos += (result.matchLength || 1);\n            } else {\n                // Get the native token at the current position\n                var token = XRegExp.exec(appliedPattern, nativeTokens[scope], pos, 'sticky')[0];\n                output += token;\n                pos += token.length;\n                if (token === '[' && scope === defaultScope) {\n                    scope = classScope;\n                } else if (token === ']' && scope === classScope) {\n                    scope = defaultScope;\n                }\n            }\n        }\n\n        patternCache[pattern][flags] = {\n            // Use basic cleanup to collapse repeated empty groups like `(?:)(?:)` to `(?:)`. Empty\n            // groups are sometimes inserted during regex transpilation in order to keep tokens\n            // separated. However, more than one empty group in a row is never needed.\n            pattern: nativ.replace.call(output, /(?:\\(\\?:\\))+/g, '(?:)'),\n            // Strip all but native flags\n            flags: nativ.replace.call(appliedFlags, /[^gimuy]+/g, ''),\n            // `context.captureNames` has an item for each capturing group, even if unnamed\n            captures: context.hasNamedCapture ? context.captureNames : null\n        };\n    }\n\n    var generated = patternCache[pattern][flags];\n    return augment(\n        new RegExp(generated.pattern, generated.flags),\n        generated.captures,\n        pattern,\n        flags\n    );\n}\n\n// Add `RegExp.prototype` to the prototype chain\nXRegExp.prototype = new RegExp();\n\n// ==--------------------------==\n// Public properties\n// ==--------------------------==\n\n/**\n * The XRegExp version number as a string containing three dot-separated parts. For example,\n * '2.0.0-beta-3'.\n *\n * @static\n * @type String\n */\nXRegExp.version = '3.1.1';\n\n// ==--------------------------==\n// Public methods\n// ==--------------------------==\n\n// Intentionally undocumented; used in tests and addons\nXRegExp._hasNativeFlag = hasNativeFlag;\nXRegExp._dec = dec;\nXRegExp._hex = hex;\nXRegExp._pad4 = pad4;\n\n/**\n * Extends XRegExp syntax and allows custom flags. This is used internally and can be used to\n * create XRegExp addons. If more than one token can match the same string, the last added wins.\n *\n * @param {RegExp} regex Regex object that matches the new token.\n * @param {Function} handler Function that returns a new pattern string (using native regex syntax)\n *   to replace the matched token within all future XRegExp regexes. Has access to persistent\n *   properties of the regex being built, through `this`. Invoked with three arguments:\n *   <li>The match array, with named backreference properties.\n *   <li>The regex scope where the match was found: 'default' or 'class'.\n *   <li>The flags used by the regex, including any flags in a leading mode modifier.\n *   The handler function becomes part of the XRegExp construction process, so be careful not to\n *   construct XRegExps within the function or you will trigger infinite recursion.\n * @param {Object} [options] Options object with optional properties:\n *   <li>`scope` {String} Scope where the token applies: 'default', 'class', or 'all'.\n *   <li>`flag` {String} Single-character flag that triggers the token. This also registers the\n *     flag, which prevents XRegExp from throwing an 'unknown flag' error when the flag is used.\n *   <li>`optionalFlags` {String} Any custom flags checked for within the token `handler` that are\n *     not required to trigger the token. This registers the flags, to prevent XRegExp from\n *     throwing an 'unknown flag' error when any of the flags are used.\n *   <li>`reparse` {Boolean} Whether the `handler` function's output should not be treated as\n *     final, and instead be reparseable by other tokens (including the current token). Allows\n *     token chaining or deferring.\n *   <li>`leadChar` {String} Single character that occurs at the beginning of any successful match\n *     of the token (not always applicable). This doesn't change the behavior of the token unless\n *     you provide an erroneous value. However, providing it can increase the token's performance\n *     since the token can be skipped at any positions where this character doesn't appear.\n * @example\n *\n * // Basic usage: Add \\a for the ALERT control code\n * XRegExp.addToken(\n *   /\\\\a/,\n *   function() {return '\\\\x07';},\n *   {scope: 'all'}\n * );\n * XRegExp('\\\\a[\\\\a-\\\\n]+').test('\\x07\\n\\x07'); // -> true\n *\n * // Add the U (ungreedy) flag from PCRE and RE2, which reverses greedy and lazy quantifiers.\n * // Since `scope` is not specified, it uses 'default' (i.e., transformations apply outside of\n * // character classes only)\n * XRegExp.addToken(\n *   /([?*+]|{\\d+(?:,\\d*)?})(\\??)/,\n *   function(match) {return match[1] + (match[2] ? '' : '?');},\n *   {flag: 'U'}\n * );\n * XRegExp('a+', 'U').exec('aaa')[0]; // -> 'a'\n * XRegExp('a+?', 'U').exec('aaa')[0]; // -> 'aaa'\n */\nXRegExp.addToken = function(regex, handler, options) {\n    options = options || {};\n    var optionalFlags = options.optionalFlags, i;\n\n    if (options.flag) {\n        registerFlag(options.flag);\n    }\n\n    if (optionalFlags) {\n        optionalFlags = nativ.split.call(optionalFlags, '');\n        for (i = 0; i < optionalFlags.length; ++i) {\n            registerFlag(optionalFlags[i]);\n        }\n    }\n\n    // Add to the private list of syntax tokens\n    tokens.push({\n        regex: copyRegex(regex, {\n            addG: true,\n            addY: hasNativeY,\n            isInternalOnly: true\n        }),\n        handler: handler,\n        scope: options.scope || defaultScope,\n        flag: options.flag,\n        reparse: options.reparse,\n        leadChar: options.leadChar\n    });\n\n    // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and flags\n    // might now produce different results\n    XRegExp.cache.flush('patterns');\n};\n\n/**\n * Caches and returns the result of calling `XRegExp(pattern, flags)`. On any subsequent call with\n * the same pattern and flag combination, the cached copy of the regex is returned.\n *\n * @param {String} pattern Regex pattern string.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Cached XRegExp object.\n * @example\n *\n * while (match = XRegExp.cache('.', 'gs').exec(str)) {\n *   // The regex is compiled once only\n * }\n */\nXRegExp.cache = function(pattern, flags) {\n    if (!regexCache[pattern]) {\n        regexCache[pattern] = {};\n    }\n    return regexCache[pattern][flags] || (\n        regexCache[pattern][flags] = XRegExp(pattern, flags)\n    );\n};\n\n// Intentionally undocumented; used in tests\nXRegExp.cache.flush = function(cacheName) {\n    if (cacheName === 'patterns') {\n        // Flush the pattern cache used by the `XRegExp` constructor\n        patternCache = {};\n    } else {\n        // Flush the regex cache populated by `XRegExp.cache`\n        regexCache = {};\n    }\n};\n\n/**\n * Escapes any regular expression metacharacters, for use when matching literal strings. The result\n * can safely be used at any point within a regex that uses any flags.\n *\n * @param {String} str String to escape.\n * @returns {String} String with regex metacharacters escaped.\n * @example\n *\n * XRegExp.escape('Escaped? <.>');\n * // -> 'Escaped\\?\\ <\\.>'\n */\nXRegExp.escape = function(str) {\n    return nativ.replace.call(toObject(str), /[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n};\n\n/**\n * Executes a regex search in a specified string. Returns a match array or `null`. If the provided\n * regex uses named capture, named backreference properties are included on the match array.\n * Optional `pos` and `sticky` arguments specify the search start position, and whether the match\n * must start at the specified position only. The `lastIndex` property of the provided regex is not\n * used, but is updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.exec` and can be used reliably cross-browser.\n *\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Array} Match array with named backreference properties, or `null`.\n * @example\n *\n * // Basic use, with named backreference\n * var match = XRegExp.exec('U+2620', XRegExp('U\\\\+(?<hex>[0-9A-F]{4})'));\n * match.hex; // -> '2620'\n *\n * // With pos and sticky, in a loop\n * var pos = 2, result = [], match;\n * while (match = XRegExp.exec('<1><2><3><4>5<6>', /<(\\d)>/, pos, 'sticky')) {\n *   result.push(match[1]);\n *   pos = match.index + match[0].length;\n * }\n * // result -> ['2', '3', '4']\n */\nXRegExp.exec = function(str, regex, pos, sticky) {\n    var cacheKey = 'g',\n        addY = false,\n        match,\n        r2;\n\n    addY = hasNativeY && !!(sticky || (regex.sticky && sticky !== false));\n    if (addY) {\n        cacheKey += 'y';\n    }\n\n    regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n    // Shares cached copies with `XRegExp.match`/`replace`\n    r2 = regex[REGEX_DATA][cacheKey] || (\n        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n            addG: true,\n            addY: addY,\n            removeY: sticky === false,\n            isInternalOnly: true\n        })\n    );\n\n    r2.lastIndex = pos = pos || 0;\n\n    // Fixed `exec` required for `lastIndex` fix, named backreferences, etc.\n    match = fixed.exec.call(r2, str);\n\n    if (sticky && match && match.index !== pos) {\n        match = null;\n    }\n\n    if (regex.global) {\n        regex.lastIndex = match ? r2.lastIndex : 0;\n    }\n\n    return match;\n};\n\n/**\n * Executes a provided function once per regex match. Searches always start at the beginning of the\n * string and continue until the end, regardless of the state of the regex's `global` property and\n * initial `lastIndex`.\n *\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Function} callback Function to execute for each match. Invoked with four arguments:\n *   <li>The match array, with named backreference properties.\n *   <li>The zero-based match index.\n *   <li>The string being traversed.\n *   <li>The regex object being used to traverse the string.\n * @example\n *\n * // Extracts every other digit from a string\n * var evens = [];\n * XRegExp.forEach('1a2345', /\\d/, function(match, i) {\n *   if (i % 2) evens.push(+match[0]);\n * });\n * // evens -> [2, 4]\n */\nXRegExp.forEach = function(str, regex, callback) {\n    var pos = 0,\n        i = -1,\n        match;\n\n    while ((match = XRegExp.exec(str, regex, pos))) {\n        // Because `regex` is provided to `callback`, the function could use the deprecated/\n        // nonstandard `RegExp.prototype.compile` to mutate the regex. However, since `XRegExp.exec`\n        // doesn't use `lastIndex` to set the search position, this can't lead to an infinite loop,\n        // at least. Actually, because of the way `XRegExp.exec` caches globalized versions of\n        // regexes, mutating the regex will not have any effect on the iteration or matched strings,\n        // which is a nice side effect that brings extra safety.\n        callback(match, ++i, str, regex);\n\n        pos = match.index + (match[0].length || 1);\n    }\n};\n\n/**\n * Copies a regex object and adds flag `g`. The copy maintains extended data, is augmented with\n * `XRegExp.prototype` properties, and has a fresh `lastIndex` property (set to zero). Native\n * regexes are not recompiled using XRegExp syntax.\n *\n * @param {RegExp} regex Regex to globalize.\n * @returns {RegExp} Copy of the provided regex with flag `g` added.\n * @example\n *\n * var globalCopy = XRegExp.globalize(/regex/);\n * globalCopy.global; // -> true\n */\nXRegExp.globalize = function(regex) {\n    return copyRegex(regex, {addG: true});\n};\n\n/**\n * Installs optional features according to the specified options. Can be undone using\n * `XRegExp.uninstall`.\n *\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.install({\n *   // Enables support for astral code points in Unicode addons (implicitly sets flag A)\n *   astral: true,\n *\n *   // DEPRECATED: Overrides native regex methods with fixed/extended versions\n *   natives: true\n * });\n *\n * // With an options string\n * XRegExp.install('astral natives');\n */\nXRegExp.install = function(options) {\n    options = prepareOptions(options);\n\n    if (!features.astral && options.astral) {\n        setAstral(true);\n    }\n\n    if (!features.natives && options.natives) {\n        setNatives(true);\n    }\n};\n\n/**\n * Checks whether an individual optional feature is installed.\n *\n * @param {String} feature Name of the feature to check. One of:\n *   <li>`astral`\n *   <li>`natives`\n * @returns {Boolean} Whether the feature is installed.\n * @example\n *\n * XRegExp.isInstalled('astral');\n */\nXRegExp.isInstalled = function(feature) {\n    return !!(features[feature]);\n};\n\n/**\n * Returns `true` if an object is a regex; `false` if it isn't. This works correctly for regexes\n * created in another frame, when `instanceof` and `constructor` checks would fail.\n *\n * @param {*} value Object to check.\n * @returns {Boolean} Whether the object is a `RegExp` object.\n * @example\n *\n * XRegExp.isRegExp('string'); // -> false\n * XRegExp.isRegExp(/regex/i); // -> true\n * XRegExp.isRegExp(RegExp('^', 'm')); // -> true\n * XRegExp.isRegExp(XRegExp('(?s).')); // -> true\n */\nXRegExp.isRegExp = function(value) {\n    return toString.call(value) === '[object RegExp]';\n    //return isType(value, 'RegExp');\n};\n\n/**\n * Returns the first matched string, or in global mode, an array containing all matched strings.\n * This is essentially a more convenient re-implementation of `String.prototype.match` that gives\n * the result types you actually want (string instead of `exec`-style array in match-first mode,\n * and an empty array instead of `null` when no matches are found in match-all mode). It also lets\n * you override flag g and ignore `lastIndex`, and fixes browser bugs.\n *\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {String} [scope='one'] Use 'one' to return the first match as a string. Use 'all' to\n *   return an array of all matched strings. If not explicitly specified and `regex` uses flag g,\n *   `scope` is 'all'.\n * @returns {String|Array} In match-first mode: First match as a string, or `null`. In match-all\n *   mode: Array of all matched strings, or an empty array.\n * @example\n *\n * // Match first\n * XRegExp.match('abc', /\\w/); // -> 'a'\n * XRegExp.match('abc', /\\w/g, 'one'); // -> 'a'\n * XRegExp.match('abc', /x/g, 'one'); // -> null\n *\n * // Match all\n * XRegExp.match('abc', /\\w/g); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /\\w/, 'all'); // -> ['a', 'b', 'c']\n * XRegExp.match('abc', /x/, 'all'); // -> []\n */\nXRegExp.match = function(str, regex, scope) {\n    var global = (regex.global && scope !== 'one') || scope === 'all',\n        cacheKey = ((global ? 'g' : '') + (regex.sticky ? 'y' : '')) || 'noGY',\n        result,\n        r2;\n\n    regex[REGEX_DATA] = regex[REGEX_DATA] || {};\n\n    // Shares cached copies with `XRegExp.exec`/`replace`\n    r2 = regex[REGEX_DATA][cacheKey] || (\n        regex[REGEX_DATA][cacheKey] = copyRegex(regex, {\n            addG: !!global,\n            removeG: scope === 'one',\n            isInternalOnly: true\n        })\n    );\n\n    result = nativ.match.call(toObject(str), r2);\n\n    if (regex.global) {\n        regex.lastIndex = (\n            (scope === 'one' && result) ?\n                // Can't use `r2.lastIndex` since `r2` is nonglobal in this case\n                (result.index + result[0].length) : 0\n        );\n    }\n\n    return global ? (result || []) : (result && result[0]);\n};\n\n/**\n * Retrieves the matches from searching a string using a chain of regexes that successively search\n * within previous matches. The provided `chain` array can contain regexes and or objects with\n * `regex` and `backref` properties. When a backreference is specified, the named or numbered\n * backreference is passed forward to the next regex or returned.\n *\n * @param {String} str String to search.\n * @param {Array} chain Regexes that each search for matches within preceding results.\n * @returns {Array} Matches by the last regex in the chain, or an empty array.\n * @example\n *\n * // Basic usage; matches numbers within <b> tags\n * XRegExp.matchChain('1 <b>2</b> 3 <b>4 a 56</b>', [\n *   XRegExp('(?is)<b>.*?</b>'),\n *   /\\d+/\n * ]);\n * // -> ['2', '4', '56']\n *\n * // Passing forward and returning specific backreferences\n * html = '<a href=\"http://xregexp.com/api/\">XRegExp</a>\\\n *         <a href=\"http://www.google.com/\">Google</a>';\n * XRegExp.matchChain(html, [\n *   {regex: /<a href=\"([^\"]+)\">/i, backref: 1},\n *   {regex: XRegExp('(?i)^https?://(?<domain>[^/?#]+)'), backref: 'domain'}\n * ]);\n * // -> ['xregexp.com', 'www.google.com']\n */\nXRegExp.matchChain = function(str, chain) {\n    return (function recurseChain(values, level) {\n        var item = chain[level].regex ? chain[level] : {regex: chain[level]};\n        var matches = [];\n\n        function addMatch(match) {\n            if (item.backref) {\n                // Safari 4.0.5 (but not 5.0.5+) inappropriately uses sparse arrays to hold the\n                // `undefined`s for backreferences to nonparticipating capturing groups. In such\n                // cases, a `hasOwnProperty` or `in` check on its own would inappropriately throw\n                // the exception, so also check if the backreference is a number that is within the\n                // bounds of the array.\n                if (!(match.hasOwnProperty(item.backref) || +item.backref < match.length)) {\n                    throw new ReferenceError('Backreference to undefined group: ' + item.backref);\n                }\n\n                matches.push(match[item.backref] || '');\n            } else {\n                matches.push(match[0]);\n            }\n        }\n\n        for (var i = 0; i < values.length; ++i) {\n            XRegExp.forEach(values[i], item.regex, addMatch);\n        }\n\n        return ((level === chain.length - 1) || !matches.length) ?\n            matches :\n            recurseChain(matches, level + 1);\n    }([str], 0));\n};\n\n/**\n * Returns a new string with one or all matches of a pattern replaced. The pattern can be a string\n * or regex, and the replacement can be a string or a function to be called for each match. To\n * perform a global search and replace, use the optional `scope` argument or include flag g if using\n * a regex. Replacement strings can use `${n}` for named and numbered backreferences. Replacement\n * functions can use named backreferences via `arguments[0].name`. Also fixes browser bugs compared\n * to the native `String.prototype.replace` and can be used reliably cross-browser.\n *\n * @param {String} str String to search.\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n *   Replacement strings can include special replacement syntax:\n *     <li>$$ - Inserts a literal $ character.\n *     <li>$&, $0 - Inserts the matched substring.\n *     <li>$` - Inserts the string that precedes the matched substring (left context).\n *     <li>$' - Inserts the string that follows the matched substring (right context).\n *     <li>$n, $nn - Where n/nn are digits referencing an existent capturing group, inserts\n *       backreference n/nn.\n *     <li>${n} - Where n is a name or any number of digits that reference an existent capturing\n *       group, inserts backreference n.\n *   Replacement functions are invoked with three or more arguments:\n *     <li>The matched substring (corresponds to $& above). Named backreferences are accessible as\n *       properties of this first argument.\n *     <li>0..n arguments, one for each backreference (corresponding to $1, $2, etc. above).\n *     <li>The zero-based index of the match within the total search string.\n *     <li>The total string being searched.\n * @param {String} [scope='one'] Use 'one' to replace the first match only, or 'all'. If not\n *   explicitly specified and using a regex with flag g, `scope` is 'all'.\n * @returns {String} New string with one or all matches replaced.\n * @example\n *\n * // Regex search, using named backreferences in replacement string\n * var name = XRegExp('(?<first>\\\\w+) (?<last>\\\\w+)');\n * XRegExp.replace('John Smith', name, '${last}, ${first}');\n * // -> 'Smith, John'\n *\n * // Regex search, using named backreferences in replacement function\n * XRegExp.replace('John Smith', name, function(match) {\n *   return match.last + ', ' + match.first;\n * });\n * // -> 'Smith, John'\n *\n * // String search, with replace-all\n * XRegExp.replace('RegExp builds RegExps', 'RegExp', 'XRegExp', 'all');\n * // -> 'XRegExp builds XRegExps'\n */\nXRegExp.replace = function(str, search, replacement, scope) {\n    var isRegex = XRegExp.isRegExp(search),\n        global = (search.global && scope !== 'one') || scope === 'all',\n        cacheKey = ((global ? 'g' : '') + (search.sticky ? 'y' : '')) || 'noGY',\n        s2 = search,\n        result;\n\n    if (isRegex) {\n        search[REGEX_DATA] = search[REGEX_DATA] || {};\n\n        // Shares cached copies with `XRegExp.exec`/`match`. Since a copy is used, `search`'s\n        // `lastIndex` isn't updated *during* replacement iterations\n        s2 = search[REGEX_DATA][cacheKey] || (\n            search[REGEX_DATA][cacheKey] = copyRegex(search, {\n                addG: !!global,\n                removeG: scope === 'one',\n                isInternalOnly: true\n            })\n        );\n    } else if (global) {\n        s2 = new RegExp(XRegExp.escape(String(search)), 'g');\n    }\n\n    // Fixed `replace` required for named backreferences, etc.\n    result = fixed.replace.call(toObject(str), s2, replacement);\n\n    if (isRegex && search.global) {\n        // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n        search.lastIndex = 0;\n    }\n\n    return result;\n};\n\n/**\n * Performs batch processing of string replacements. Used like `XRegExp.replace`, but accepts an\n * array of replacement details. Later replacements operate on the output of earlier replacements.\n * Replacement details are accepted as an array with a regex or string to search for, the\n * replacement string or function, and an optional scope of 'one' or 'all'. Uses the XRegExp\n * replacement text syntax, which supports named backreference properties via `${name}`.\n *\n * @param {String} str String to search.\n * @param {Array} replacements Array of replacement detail arrays.\n * @returns {String} New string with all replacements.\n * @example\n *\n * str = XRegExp.replaceEach(str, [\n *   [XRegExp('(?<name>a)'), 'z${name}'],\n *   [/b/gi, 'y'],\n *   [/c/g, 'x', 'one'], // scope 'one' overrides /g\n *   [/d/, 'w', 'all'],  // scope 'all' overrides lack of /g\n *   ['e', 'v', 'all'],  // scope 'all' allows replace-all for strings\n *   [/f/g, function($0) {\n *     return $0.toUpperCase();\n *   }]\n * ]);\n */\nXRegExp.replaceEach = function(str, replacements) {\n    var i, r;\n\n    for (i = 0; i < replacements.length; ++i) {\n        r = replacements[i];\n        str = XRegExp.replace(str, r[0], r[1], r[2]);\n    }\n\n    return str;\n};\n\n/**\n * Splits a string into an array of strings using a regex or string separator. Matches of the\n * separator are not included in the result array. However, if `separator` is a regex that contains\n * capturing groups, backreferences are spliced into the result each time `separator` is matched.\n * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably\n * cross-browser.\n *\n * @param {String} str String to split.\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n * @example\n *\n * // Basic use\n * XRegExp.split('a b c', ' ');\n * // -> ['a', 'b', 'c']\n *\n * // With limit\n * XRegExp.split('a b c', ' ', 2);\n * // -> ['a', 'b']\n *\n * // Backreferences in result array\n * XRegExp.split('..word1..', /([a-z]+)(\\d+)/i);\n * // -> ['..', 'word', '1', '..']\n */\nXRegExp.split = function(str, separator, limit) {\n    return fixed.split.call(toObject(str), separator, limit);\n};\n\n/**\n * Executes a regex search in a specified string. Returns `true` or `false`. Optional `pos` and\n * `sticky` arguments specify the search start position, and whether the match must start at the\n * specified position only. The `lastIndex` property of the provided regex is not used, but is\n * updated for compatibility. Also fixes browser bugs compared to the native\n * `RegExp.prototype.test` and can be used reliably cross-browser.\n *\n * @param {String} str String to search.\n * @param {RegExp} regex Regex to search with.\n * @param {Number} [pos=0] Zero-based index at which to start the search.\n * @param {Boolean|String} [sticky=false] Whether the match must start at the specified position\n *   only. The string `'sticky'` is accepted as an alternative to `true`.\n * @returns {Boolean} Whether the regex matched the provided value.\n * @example\n *\n * // Basic use\n * XRegExp.test('abc', /c/); // -> true\n *\n * // With pos and sticky\n * XRegExp.test('abc', /c/, 0, 'sticky'); // -> false\n * XRegExp.test('abc', /c/, 2, 'sticky'); // -> true\n */\nXRegExp.test = function(str, regex, pos, sticky) {\n    // Do this the easy way :-)\n    return !!XRegExp.exec(str, regex, pos, sticky);\n};\n\n/**\n * Uninstalls optional features according to the specified options. All optional features start out\n * uninstalled, so this is used to undo the actions of `XRegExp.install`.\n *\n * @param {Object|String} options Options object or string.\n * @example\n *\n * // With an options object\n * XRegExp.uninstall({\n *   // Disables support for astral code points in Unicode addons\n *   astral: true,\n *\n *   // DEPRECATED: Restores native regex methods\n *   natives: true\n * });\n *\n * // With an options string\n * XRegExp.uninstall('astral natives');\n */\nXRegExp.uninstall = function(options) {\n    options = prepareOptions(options);\n\n    if (features.astral && options.astral) {\n        setAstral(false);\n    }\n\n    if (features.natives && options.natives) {\n        setNatives(false);\n    }\n};\n\n/**\n * Returns an XRegExp object that is the union of the given patterns. Patterns can be provided as\n * regex objects or strings. Metacharacters are escaped in patterns provided as strings.\n * Backreferences in provided regex objects are automatically renumbered to work correctly within\n * the larger combined pattern. Native flags used by provided regexes are ignored in favor of the\n * `flags` argument.\n *\n * @param {Array} patterns Regexes and strings to combine.\n * @param {String} [flags] Any combination of XRegExp flags.\n * @returns {RegExp} Union of the provided regexes and strings.\n * @example\n *\n * XRegExp.union(['a+b*c', /(dogs)\\1/, /(cats)\\1/], 'i');\n * // -> /a\\+b\\*c|(dogs)\\1|(cats)\\2/i\n */\nXRegExp.union = function(patterns, flags) {\n    var numCaptures = 0;\n    var numPriorCaptures;\n    var captureNames;\n\n    function rewrite(match, paren, backref) {\n        var name = captureNames[numCaptures - numPriorCaptures];\n\n        // Capturing group\n        if (paren) {\n            ++numCaptures;\n            // If the current capture has a name, preserve the name\n            if (name) {\n                return '(?<' + name + '>';\n            }\n        // Backreference\n        } else if (backref) {\n            // Rewrite the backreference\n            return '\\\\' + (+backref + numPriorCaptures);\n        }\n\n        return match;\n    }\n\n    if (!(isType(patterns, 'Array') && patterns.length)) {\n        throw new TypeError('Must provide a nonempty array of patterns to merge');\n    }\n\n    var parts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*]/g;\n    var output = [];\n    var pattern;\n    for (var i = 0; i < patterns.length; ++i) {\n        pattern = patterns[i];\n\n        if (XRegExp.isRegExp(pattern)) {\n            numPriorCaptures = numCaptures;\n            captureNames = (pattern[REGEX_DATA] && pattern[REGEX_DATA].captureNames) || [];\n\n            // Rewrite backreferences. Passing to XRegExp dies on octals and ensures patterns are\n            // independently valid; helps keep this simple. Named captures are put back\n            output.push(nativ.replace.call(XRegExp(pattern.source).source, parts, rewrite));\n        } else {\n            output.push(XRegExp.escape(pattern));\n        }\n    }\n\n    return XRegExp(output.join('|'), flags);\n};\n\n// ==--------------------------==\n// Fixed/extended native methods\n// ==--------------------------==\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `RegExp.prototype.exec`. Calling `XRegExp.install('natives')` uses this to\n * override the native method. Use via `XRegExp.exec` without overriding natives.\n *\n * @param {String} str String to search.\n * @returns {Array} Match array with named backreference properties, or `null`.\n */\nfixed.exec = function(str) {\n    var origLastIndex = this.lastIndex,\n        match = nativ.exec.apply(this, arguments),\n        name,\n        r2,\n        i;\n\n    if (match) {\n        // Fix browsers whose `exec` methods don't return `undefined` for nonparticipating capturing\n        // groups. This fixes IE 5.5-8, but not IE 9's quirks mode or emulation of older IEs. IE 9\n        // in standards mode follows the spec.\n        if (!correctExecNpcg && match.length > 1 && indexOf(match, '') > -1) {\n            r2 = copyRegex(this, {\n                removeG: true,\n                isInternalOnly: true\n            });\n            // Using `str.slice(match.index)` rather than `match[0]` in case lookahead allowed\n            // matching due to characters outside the match\n            nativ.replace.call(String(str).slice(match.index), r2, function() {\n                var len = arguments.length, i;\n                // Skip index 0 and the last 2\n                for (i = 1; i < len - 2; ++i) {\n                    if (arguments[i] === undefined) {\n                        match[i] = undefined;\n                    }\n                }\n            });\n        }\n\n        // Attach named capture properties\n        if (this[REGEX_DATA] && this[REGEX_DATA].captureNames) {\n            // Skip index 0\n            for (i = 1; i < match.length; ++i) {\n                name = this[REGEX_DATA].captureNames[i - 1];\n                if (name) {\n                    match[name] = match[i];\n                }\n            }\n        }\n\n        // Fix browsers that increment `lastIndex` after zero-length matches\n        if (this.global && !match[0].length && (this.lastIndex > match.index)) {\n            this.lastIndex = match.index;\n        }\n    }\n\n    if (!this.global) {\n        // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n        this.lastIndex = origLastIndex;\n    }\n\n    return match;\n};\n\n/**\n * Fixes browser bugs in the native `RegExp.prototype.test`. Calling `XRegExp.install('natives')`\n * uses this to override the native method.\n *\n * @param {String} str String to search.\n * @returns {Boolean} Whether the regex matched the provided value.\n */\nfixed.test = function(str) {\n    // Do this the easy way :-)\n    return !!fixed.exec.call(this, str);\n};\n\n/**\n * Adds named capture support (with backreferences returned as `result.name`), and fixes browser\n * bugs in the native `String.prototype.match`. Calling `XRegExp.install('natives')` uses this to\n * override the native method.\n *\n * @param {RegExp|*} regex Regex to search with. If not a regex object, it is passed to `RegExp`.\n * @returns {Array} If `regex` uses flag g, an array of match strings or `null`. Without flag g,\n *   the result of calling `regex.exec(this)`.\n */\nfixed.match = function(regex) {\n    var result;\n\n    if (!XRegExp.isRegExp(regex)) {\n        // Use the native `RegExp` rather than `XRegExp`\n        regex = new RegExp(regex);\n    } else if (regex.global) {\n        result = nativ.match.apply(this, arguments);\n        // Fixes IE bug\n        regex.lastIndex = 0;\n\n        return result;\n    }\n\n    return fixed.exec.call(regex, toObject(this));\n};\n\n/**\n * Adds support for `${n}` tokens for named and numbered backreferences in replacement text, and\n * provides named backreferences to replacement functions as `arguments[0].name`. Also fixes browser\n * bugs in replacement text syntax when performing a replacement using a nonregex search value, and\n * the value of a replacement regex's `lastIndex` property during replacement iterations and upon\n * completion. Calling `XRegExp.install('natives')` uses this to override the native method. Note\n * that this doesn't support SpiderMonkey's proprietary third (`flags`) argument. Use via\n * `XRegExp.replace` without overriding natives.\n *\n * @param {RegExp|String} search Search pattern to be replaced.\n * @param {String|Function} replacement Replacement string or a function invoked to create it.\n * @returns {String} New string with one or all matches replaced.\n */\nfixed.replace = function(search, replacement) {\n    var isRegex = XRegExp.isRegExp(search),\n        origLastIndex,\n        captureNames,\n        result;\n\n    if (isRegex) {\n        if (search[REGEX_DATA]) {\n            captureNames = search[REGEX_DATA].captureNames;\n        }\n        // Only needed if `search` is nonglobal\n        origLastIndex = search.lastIndex;\n    } else {\n        search += ''; // Type-convert\n    }\n\n    // Don't use `typeof`; some older browsers return 'function' for regex objects\n    if (isType(replacement, 'Function')) {\n        // Stringifying `this` fixes a bug in IE < 9 where the last argument in replacement\n        // functions isn't type-converted to a string\n        result = nativ.replace.call(String(this), search, function() {\n            var args = arguments, i;\n            if (captureNames) {\n                // Change the `arguments[0]` string primitive to a `String` object that can store\n                // properties. This really does need to use `String` as a constructor\n                args[0] = new String(args[0]);\n                // Store named backreferences on the first argument\n                for (i = 0; i < captureNames.length; ++i) {\n                    if (captureNames[i]) {\n                        args[0][captureNames[i]] = args[i + 1];\n                    }\n                }\n            }\n            // Update `lastIndex` before calling `replacement`. Fixes IE, Chrome, Firefox, Safari\n            // bug (last tested IE 9, Chrome 17, Firefox 11, Safari 5.1)\n            if (isRegex && search.global) {\n                search.lastIndex = args[args.length - 2] + args[0].length;\n            }\n            // ES6 specs the context for replacement functions as `undefined`\n            return replacement.apply(undefined, args);\n        });\n    } else {\n        // Ensure that the last value of `args` will be a string when given nonstring `this`,\n        // while still throwing on null or undefined context\n        result = nativ.replace.call(this == null ? this : String(this), search, function() {\n            // Keep this function's `arguments` available through closure\n            var args = arguments;\n            return nativ.replace.call(String(replacement), replacementToken, function($0, $1, $2) {\n                var n;\n                // Named or numbered backreference with curly braces\n                if ($1) {\n                    // XRegExp behavior for `${n}`:\n                    // 1. Backreference to numbered capture, if `n` is an integer. Use `0` for the\n                    //    entire match. Any number of leading zeros may be used.\n                    // 2. Backreference to named capture `n`, if it exists and is not an integer\n                    //    overridden by numbered capture. In practice, this does not overlap with\n                    //    numbered capture since XRegExp does not allow named capture to use a bare\n                    //    integer as the name.\n                    // 3. If the name or number does not refer to an existing capturing group, it's\n                    //    an error.\n                    n = +$1; // Type-convert; drop leading zeros\n                    if (n <= args.length - 3) {\n                        return args[n] || '';\n                    }\n                    // Groups with the same name is an error, else would need `lastIndexOf`\n                    n = captureNames ? indexOf(captureNames, $1) : -1;\n                    if (n < 0) {\n                        throw new SyntaxError('Backreference to undefined group ' + $0);\n                    }\n                    return args[n + 1] || '';\n                }\n                // Else, special variable or numbered backreference without curly braces\n                if ($2 === '$') { // $$\n                    return '$';\n                }\n                if ($2 === '&' || +$2 === 0) { // $&, $0 (not followed by 1-9), $00\n                    return args[0];\n                }\n                if ($2 === '`') { // $` (left context)\n                    return args[args.length - 1].slice(0, args[args.length - 2]);\n                }\n                if ($2 === \"'\") { // $' (right context)\n                    return args[args.length - 1].slice(args[args.length - 2] + args[0].length);\n                }\n                // Else, numbered backreference without curly braces\n                $2 = +$2; // Type-convert; drop leading zero\n                // XRegExp behavior for `$n` and `$nn`:\n                // - Backrefs end after 1 or 2 digits. Use `${..}` for more digits.\n                // - `$1` is an error if no capturing groups.\n                // - `$10` is an error if less than 10 capturing groups. Use `${1}0` instead.\n                // - `$01` is `$1` if at least one capturing group, else it's an error.\n                // - `$0` (not followed by 1-9) and `$00` are the entire match.\n                // Native behavior, for comparison:\n                // - Backrefs end after 1 or 2 digits. Cannot reference capturing group 100+.\n                // - `$1` is a literal `$1` if no capturing groups.\n                // - `$10` is `$1` followed by a literal `0` if less than 10 capturing groups.\n                // - `$01` is `$1` if at least one capturing group, else it's a literal `$01`.\n                // - `$0` is a literal `$0`.\n                if (!isNaN($2)) {\n                    if ($2 > args.length - 3) {\n                        throw new SyntaxError('Backreference to undefined group ' + $0);\n                    }\n                    return args[$2] || '';\n                }\n                // `$` followed by an unsupported char is an error, unlike native JS\n                throw new SyntaxError('Invalid token ' + $0);\n            });\n        });\n    }\n\n    if (isRegex) {\n        if (search.global) {\n            // Fixes IE, Safari bug (last tested IE 9, Safari 5.1)\n            search.lastIndex = 0;\n        } else {\n            // Fixes IE, Opera bug (last tested IE 9, Opera 11.6)\n            search.lastIndex = origLastIndex;\n        }\n    }\n\n    return result;\n};\n\n/**\n * Fixes browser bugs in the native `String.prototype.split`. Calling `XRegExp.install('natives')`\n * uses this to override the native method. Use via `XRegExp.split` without overriding natives.\n *\n * @param {RegExp|String} separator Regex or string to use for separating the string.\n * @param {Number} [limit] Maximum number of items to include in the result array.\n * @returns {Array} Array of substrings.\n */\nfixed.split = function(separator, limit) {\n    if (!XRegExp.isRegExp(separator)) {\n        // Browsers handle nonregex split correctly, so use the faster native method\n        return nativ.split.apply(this, arguments);\n    }\n\n    var str = String(this),\n        output = [],\n        origLastIndex = separator.lastIndex,\n        lastLastIndex = 0,\n        lastLength;\n\n    // Values for `limit`, per the spec:\n    // If undefined: pow(2,32) - 1\n    // If 0, Infinity, or NaN: 0\n    // If positive number: limit = floor(limit); if (limit >= pow(2,32)) limit -= pow(2,32);\n    // If negative number: pow(2,32) - floor(abs(limit))\n    // If other: Type-convert, then use the above rules\n    // This line fails in very strange ways for some values of `limit` in Opera 10.5-10.63, unless\n    // Opera Dragonfly is open (go figure). It works in at least Opera 9.5-10.1 and 11+\n    limit = (limit === undefined ? -1 : limit) >>> 0;\n\n    XRegExp.forEach(str, separator, function(match) {\n        // This condition is not the same as `if (match[0].length)`\n        if ((match.index + match[0].length) > lastLastIndex) {\n            output.push(str.slice(lastLastIndex, match.index));\n            if (match.length > 1 && match.index < str.length) {\n                Array.prototype.push.apply(output, match.slice(1));\n            }\n            lastLength = match[0].length;\n            lastLastIndex = match.index + lastLength;\n        }\n    });\n\n    if (lastLastIndex === str.length) {\n        if (!nativ.test.call(separator, '') || lastLength) {\n            output.push('');\n        }\n    } else {\n        output.push(str.slice(lastLastIndex));\n    }\n\n    separator.lastIndex = origLastIndex;\n    return output.length > limit ? output.slice(0, limit) : output;\n};\n\n// ==--------------------------==\n// Built-in syntax/flag tokens\n// ==--------------------------==\n\n/*\n * Letter escapes that natively match literal characters: `\\a`, `\\A`, etc. These should be\n * SyntaxErrors but are allowed in web reality. XRegExp makes them errors for cross-browser\n * consistency and to reserve their syntax, but lets them be superseded by addons.\n */\nXRegExp.addToken(\n    /\\\\([ABCE-RTUVXYZaeg-mopqyz]|c(?![A-Za-z])|u(?![\\dA-Fa-f]{4}|{[\\dA-Fa-f]+})|x(?![\\dA-Fa-f]{2}))/,\n    function(match, scope) {\n        // \\B is allowed in default scope only\n        if (match[1] === 'B' && scope === defaultScope) {\n            return match[0];\n        }\n        throw new SyntaxError('Invalid escape ' + match[0]);\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Unicode code point escape with curly braces: `\\u{N..}`. `N..` is any one or more digit\n * hexadecimal number from 0-10FFFF, and can include leading zeros. Requires the native ES6 `u` flag\n * to support code points greater than U+FFFF. Avoids converting code points above U+FFFF to\n * surrogate pairs (which could be done without flag `u`), since that could lead to broken behavior\n * if you follow a `\\u{N..}` token that references a code point above U+FFFF with a quantifier, or\n * if you use the same in a character class.\n */\nXRegExp.addToken(\n    /\\\\u{([\\dA-Fa-f]+)}/,\n    function(match, scope, flags) {\n        var code = dec(match[1]);\n        if (code > 0x10FFFF) {\n            throw new SyntaxError('Invalid Unicode code point ' + match[0]);\n        }\n        if (code <= 0xFFFF) {\n            // Converting to \\uNNNN avoids needing to escape the literal character and keep it\n            // separate from preceding tokens\n            return '\\\\u' + pad4(hex(code));\n        }\n        // If `code` is between 0xFFFF and 0x10FFFF, require and defer to native handling\n        if (hasNativeU && flags.indexOf('u') > -1) {\n            return match[0];\n        }\n        throw new SyntaxError('Cannot use Unicode code point above \\\\u{FFFF} without flag u');\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Empty character class: `[]` or `[^]`. This fixes a critical cross-browser syntax inconsistency.\n * Unless this is standardized (per the ES spec), regex syntax can't be accurately parsed because\n * character class endings can't be determined.\n */\nXRegExp.addToken(\n    /\\[(\\^?)]/,\n    function(match) {\n        // For cross-browser compatibility with ES3, convert [] to \\b\\B and [^] to [\\s\\S].\n        // (?!) should work like \\b\\B, but is unreliable in some versions of Firefox\n        return match[1] ? '[\\\\s\\\\S]' : '\\\\b\\\\B';\n    },\n    {leadChar: '['}\n);\n\n/*\n * Comment pattern: `(?# )`. Inline comments are an alternative to the line comments allowed in\n * free-spacing mode (flag x).\n */\nXRegExp.addToken(\n    /\\(\\?#[^)]*\\)/,\n    function(match, scope, flags) {\n        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.\n        // inadvertedly changing `\\1(?#)1` to `\\11`.\n        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?\n            '' : '(?:)';\n    },\n    {leadChar: '('}\n);\n\n/*\n * Whitespace and line comments, in free-spacing mode (aka extended mode, flag x) only.\n */\nXRegExp.addToken(\n    /\\s+|#[^\\n]*\\n?/,\n    function(match, scope, flags) {\n        // Keep tokens separated unless the following token is a quantifier. This avoids e.g.\n        // inadvertedly changing `\\1 1` to `\\11`.\n        return isQuantifierNext(match.input, match.index + match[0].length, flags) ?\n            '' : '(?:)';\n    },\n    {flag: 'x'}\n);\n\n/*\n * Dot, in dotall mode (aka singleline mode, flag s) only.\n */\nXRegExp.addToken(\n    /\\./,\n    function() {\n        return '[\\\\s\\\\S]';\n    },\n    {\n        flag: 's',\n        leadChar: '.'\n    }\n);\n\n/*\n * Named backreference: `\\k<name>`. Backreference names can use the characters A-Z, a-z, 0-9, _,\n * and $ only. Also allows numbered backreferences as `\\k<n>`.\n */\nXRegExp.addToken(\n    /\\\\k<([\\w$]+)>/,\n    function(match) {\n        // Groups with the same name is an error, else would need `lastIndexOf`\n        var index = isNaN(match[1]) ? (indexOf(this.captureNames, match[1]) + 1) : +match[1],\n            endIndex = match.index + match[0].length;\n        if (!index || index > this.captureNames.length) {\n            throw new SyntaxError('Backreference to undefined group ' + match[0]);\n        }\n        // Keep backreferences separate from subsequent literal numbers. This avoids e.g.\n        // inadvertedly changing `(?<n>)\\k<n>1` to `()\\11`.\n        return '\\\\' + index + (\n            endIndex === match.input.length || isNaN(match.input.charAt(endIndex)) ?\n                '' : '(?:)'\n        );\n    },\n    {leadChar: '\\\\'}\n);\n\n/*\n * Numbered backreference or octal, plus any following digits: `\\0`, `\\11`, etc. Octals except `\\0`\n * not followed by 0-9 and backreferences to unopened capture groups throw an error. Other matches\n * are returned unaltered. IE < 9 doesn't support backreferences above `\\99` in regex syntax.\n */\nXRegExp.addToken(\n    /\\\\(\\d+)/,\n    function(match, scope) {\n        if (\n            !(\n                scope === defaultScope &&\n                /^[1-9]/.test(match[1]) &&\n                +match[1] <= this.captureNames.length\n            ) &&\n            match[1] !== '0'\n        ) {\n            throw new SyntaxError('Cannot use octal escape or backreference to undefined group ' +\n                match[0]);\n        }\n        return match[0];\n    },\n    {\n        scope: 'all',\n        leadChar: '\\\\'\n    }\n);\n\n/*\n * Named capturing group; match the opening delimiter only: `(?<name>`. Capture names can use the\n * characters A-Z, a-z, 0-9, _, and $ only. Names can't be integers. Supports Python-style\n * `(?P<name>` as an alternate syntax to avoid issues in some older versions of Opera which natively\n * supported the Python-style syntax. Otherwise, XRegExp might treat numbered backreferences to\n * Python-style named capture as octals.\n */\nXRegExp.addToken(\n    /\\(\\?P?<([\\w$]+)>/,\n    function(match) {\n        // Disallow bare integers as names because named backreferences are added to match arrays\n        // and therefore numeric properties may lead to incorrect lookups\n        if (!isNaN(match[1])) {\n            throw new SyntaxError('Cannot use integer as capture name ' + match[0]);\n        }\n        if (match[1] === 'length' || match[1] === '__proto__') {\n            throw new SyntaxError('Cannot use reserved word as capture name ' + match[0]);\n        }\n        if (indexOf(this.captureNames, match[1]) > -1) {\n            throw new SyntaxError('Cannot use same name for multiple groups ' + match[0]);\n        }\n        this.captureNames.push(match[1]);\n        this.hasNamedCapture = true;\n        return '(';\n    },\n    {leadChar: '('}\n);\n\n/*\n * Capturing group; match the opening parenthesis only. Required for support of named capturing\n * groups. Also adds explicit capture mode (flag n).\n */\nXRegExp.addToken(\n    /\\((?!\\?)/,\n    function(match, scope, flags) {\n        if (flags.indexOf('n') > -1) {\n            return '(?:';\n        }\n        this.captureNames.push(null);\n        return '(';\n    },\n    {\n        optionalFlags: 'n',\n        leadChar: '('\n    }\n);\n\nmodule.exports = XRegExp;\n"]}