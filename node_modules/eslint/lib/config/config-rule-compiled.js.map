{"version":3,"sources":["config-rule.js"],"names":[],"mappings":"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","file":"config-rule-compiled.js","sourcesContent":["/**\n * @fileoverview Create configurations for a rule\n * @author Ian VanSchooten\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar rules = require(\"../rules\"),\n    loadRules = require(\"../load-rules\");\n\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Wrap all of the elements of an array into arrays.\n * @param   {*[]}     xs Any array.\n * @returns {Array[]}    An array of arrays.\n */\nfunction explodeArray(xs) {\n    return xs.reduce(function(accumulator, x) {\n        accumulator.push([x]);\n        return accumulator;\n    }, []);\n}\n\n/**\n * Mix two arrays such that each element of the second array is concatenated\n * onto each element of the first array.\n *\n * For example:\n * combineArrays([a, [b, c]], [x, y]); // -> [[a, x], [a, y], [b, c, x], [b, c, y]]\n *\n * @param   {array} arr1 The first array to combine.\n * @param   {array} arr2 The second array to combine.\n * @returns {array}      A mixture of the elements of the first and second arrays.\n */\nfunction combineArrays(arr1, arr2) {\n    var res = [];\n\n    if (arr1.length === 0) {\n        return explodeArray(arr2);\n    }\n    if (arr2.length === 0) {\n        return explodeArray(arr1);\n    }\n    arr1.forEach(function(x1) {\n        arr2.forEach(function(x2) {\n            res.push([].concat(x1, x2));\n        });\n    });\n    return res;\n}\n\n/**\n * Group together valid rule configurations based on object properties\n *\n * e.g.:\n * groupByProperty([\n *     {before: true},\n *     {before: false},\n *     {after: true},\n *     {after: false}\n * ]);\n *\n * will return:\n * [\n *     [{before: true}, {before: false}],\n *     [{after: true}, {after: false}]\n * ]\n *\n * @param   {Object[]} objects Array of objects, each with one property/value pair\n * @returns {Array[]}          Array of arrays of objects grouped by property\n */\nfunction groupByProperty(objects) {\n    var groupedObj = objects.reduce(function(accumulator, obj) {\n        var prop = Object.keys(obj)[0];\n\n        accumulator[prop] = accumulator[prop] ? accumulator[prop].concat(obj) : [obj];\n        return accumulator;\n    }, {});\n\n    return Object.keys(groupedObj).map(function(prop) {\n        return groupedObj[prop];\n    });\n}\n\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Configuration settings for a rule.\n *\n * A configuration can be a single number (severity), or an array where the first\n * element in the array is the severity, and is the only required element.\n * Configs may also have one or more additional elements to specify rule\n * configuration or options.\n *\n * @typedef {array|number} ruleConfig\n * @param {number}  0  The rule's severity (0, 1, 2).\n */\n\n/**\n * Object whose keys are rule names and values are arrays of valid ruleConfig items\n * which should be linted against the target source code to determine error counts.\n * (a ruleConfigSet.ruleConfigs).\n *\n * e.g. rulesConfig = {\n *     \"comma-dangle\": [2, [2, \"always\"], [2, \"always-multiline\"], [2, \"never\"]],\n *     \"no-console\": [2]\n * }\n * @typedef rulesConfig\n */\n\n\n/**\n * Create valid rule configurations by combining two arrays,\n * with each array containing multiple objects each with a\n * single property/value pair and matching properties.\n *\n * e.g.:\n * combinePropertyObjects(\n *     [{before: true}, {before: false}],\n *     [{after: true}, {after: false}]\n * );\n *\n * will return:\n * [\n *     {before: true, after: true},\n *     {before: true, after: false},\n *     {before: false, after: true},\n *     {before: false, after: false}\n * ]\n *\n * @param   {Object[]} objArr1 Single key/value objects, all with the same key\n * @param   {Object[]} objArr2 Single key/value objects, all with another key\n * @returns {Object[]}         Combined objects for each combination of input properties and values\n */\nfunction combinePropertyObjects(objArr1, objArr2) {\n    var res = [];\n\n    if (objArr1.length === 0) {\n        return objArr2;\n    }\n    if (objArr2.length === 0) {\n        return objArr1;\n    }\n    objArr1.forEach(function(obj1) {\n        objArr2.forEach(function(obj2) {\n            var combinedObj = {};\n            var obj1Props = Object.keys(obj1);\n            var obj2Props = Object.keys(obj2);\n\n            obj1Props.forEach(function(prop1) {\n                combinedObj[prop1] = obj1[prop1];\n            });\n            obj2Props.forEach(function(prop2) {\n                combinedObj[prop2] = obj2[prop2];\n            });\n            res.push(combinedObj);\n        });\n    });\n    return res;\n}\n\n /**\n  * Creates a new instance of a rule configuration set\n  *\n  * A rule configuration set is an array of configurations that are valid for a\n  * given rule.  For example, the configuration set for the \"semi\" rule could be:\n  *\n  * ruleConfigSet.ruleConfigs // -> [[2], [2, \"always\"], [2, \"never\"]]\n  *\n  * @param {ruleConfig[]} configs Valid rule configurations\n  * @constructor\n  */\nfunction RuleConfigSet(configs) {\n\n    /**\n    * Stored valid rule configurations for this instance\n    * @type {array}\n    */\n    this.ruleConfigs = configs || [];\n\n}\n\nRuleConfigSet.prototype = {\n\n    constructor: RuleConfigSet,\n\n    /**\n    * Add a severity level to the front of all configs in the instance.\n    * This should only be called after all configs have been added to the instance.\n    *\n    * @param {number} [severity=2] The level of severity for the rule (0, 1, 2)\n    * @returns {void}\n    */\n    addErrorSeverity: function(severity) {\n        severity = severity || 2;\n\n        this.ruleConfigs = this.ruleConfigs.map(function(config) {\n            config.unshift(severity);\n            return config;\n        });\n\n        // Add a single config at the beginning consisting of only the severity\n        this.ruleConfigs.unshift(severity);\n    },\n\n    /**\n    * Add rule configs from an array of strings (schema enums)\n    * @param  {string[]} enums Array of valid rule options (e.g. [\"always\", \"never\"])\n    * @returns {void}\n    */\n    addEnums: function(enums) {\n        this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, enums));\n    },\n\n    /**\n    * Add rule configurations from a schema object\n    * @param  {Object} obj Schema item with type === \"object\"\n    * @returns {void}\n    */\n    addObject: function(obj) {\n        var objectConfigSet = {\n            objectConfigs: [],\n            add: function(property, values) {\n                var optionObj;\n\n                for (var idx = 0; idx < values.length; idx++) {\n                    optionObj = {};\n                    optionObj[property] = values[idx];\n                    this.objectConfigs.push(optionObj);\n                }\n            },\n\n            combine: function() {\n                this.objectConfigs = groupByProperty(this.objectConfigs).reduce(function(accumulator, objArr) {\n                    return combinePropertyObjects(accumulator, objArr);\n                }, []);\n            }\n        };\n\n        /*\n         * The object schema could have multiple independent properties.\n         * If any contain enums or booleans, they can be added and then combined\n         */\n        Object.keys(obj.properties).forEach(function(prop) {\n            if (obj.properties[prop].enum) {\n                objectConfigSet.add(prop, obj.properties[prop].enum);\n            }\n            if (obj.properties[prop].type && obj.properties[prop].type === \"boolean\") {\n                objectConfigSet.add(prop, [true, false]);\n            }\n        });\n        objectConfigSet.combine();\n\n        if (objectConfigSet.objectConfigs.length > 0) {\n            this.ruleConfigs = this.ruleConfigs.concat(combineArrays(this.ruleConfigs, objectConfigSet.objectConfigs));\n        }\n    }\n};\n\n/**\n* Generate valid rule configurations based on a schema object\n* @param   {Object} schema  A rule's schema object\n* @returns {array[]}        Valid rule configurations\n*/\nfunction generateConfigsFromSchema(schema) {\n    var configSet = new RuleConfigSet();\n\n    if (Array.isArray(schema)) {\n        schema.forEach(function(opt) {\n            if (opt.enum) {\n                configSet.addEnums(opt.enum);\n            }\n\n            if (opt.type && opt.type === \"object\") {\n                configSet.addObject(opt);\n            }\n\n            if (opt.oneOf) {\n\n                // TODO (IanVS): not yet implemented\n            }\n        });\n    }\n    configSet.addErrorSeverity();\n    return configSet.ruleConfigs;\n}\n\n/**\n* Generate possible rule configurations for all of the core rules\n* @returns {rulesConfig} Hash of rule names and arrays of possible configurations\n*/\nfunction createCoreRuleConfigs() {\n    var ruleList = loadRules();\n\n    return Object.keys(ruleList).reduce(function(accumulator, id) {\n        var rule = rules.get(id);\n        var schema = (typeof rule === \"function\") ? rule.schema : rule.meta.schema;\n\n        accumulator[id] = generateConfigsFromSchema(schema);\n        return accumulator;\n    }, {});\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    generateConfigsFromSchema: generateConfigsFromSchema,\n    createCoreRuleConfigs: createCoreRuleConfigs\n};\n"]}