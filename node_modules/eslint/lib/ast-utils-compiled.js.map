{"version":3,"sources":["ast-utils.js"],"names":[],"mappings":"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","file":"ast-utils-compiled.js","sourcesContent":["/**\n * @fileoverview Common utils for AST.\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar esutils = require(\"esutils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/;\nvar arrayOrTypedArrayPattern = /Array$/;\nvar arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/;\nvar bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/;\nvar breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/;\nvar thisTagPattern = /^[\\s\\*]*@this/m;\n\n/**\n * Checks reference if is non initializer and writable.\n * @param {Reference} reference - A reference to check.\n * @param {int} index - The index of the reference in the references.\n * @param {Reference[]} references - The array that the reference belongs to.\n * @returns {boolean} Success/Failure\n * @private\n */\nfunction isModifyingReference(reference, index, references) {\n    var identifier = reference.identifier,\n        modifyingDifferentIdentifier;\n\n    /*\n     * Destructuring assignments can have multiple default value, so\n     * possibly there are multiple writeable references for the same\n     * identifier.\n     */\n    modifyingDifferentIdentifier = index === 0 ||\n        references[index - 1].identifier !== identifier;\n\n    return (identifier &&\n        reference.init === false &&\n        reference.isWrite() &&\n        modifyingDifferentIdentifier\n    );\n}\n\n/**\n * Checks whether or not a node is a constructor.\n * @param {ASTNode} node - A function node to check.\n * @returns {boolean} Wehether or not a node is a constructor.\n */\nfunction isES5Constructor(node) {\n    return (\n        node.id &&\n        node.id.name[0] !== node.id.name[0].toLocaleLowerCase()\n    );\n}\n\n/**\n * Finds a function node from ancestors of a node.\n * @param {ASTNode} node - A start node to find.\n * @returns {Node|null} A found function node.\n */\nfunction getUpperFunction(node) {\n    while (node) {\n        if (anyFunctionPattern.test(node.type)) {\n            return node;\n        }\n        node = node.parent;\n    }\n    return null;\n}\n\n/**\n * Checks whether or not a node is `null` or `undefined`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `null` or `undefined`.\n * @public\n */\nfunction isNullOrUndefined(node) {\n    return (\n        (node.type === \"Literal\" && node.value === null) ||\n        (node.type === \"Identifier\" && node.name === \"undefined\") ||\n        (node.type === \"UnaryExpression\" && node.operator === \"void\")\n    );\n}\n\n/**\n * Checks whether or not a node is callee.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is callee.\n */\nfunction isCallee(node) {\n    return node.parent.type === \"CallExpression\" && node.parent.callee === node;\n}\n\n/**\n * Checks whether or not a node is `Reclect.apply`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Reclect.apply`.\n */\nfunction isReflectApply(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        node.object.name === \"Reflect\" &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"apply\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is `Array.from`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a `Array.from`.\n */\nfunction isArrayFromMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        node.object.type === \"Identifier\" &&\n        arrayOrTypedArrayPattern.test(node.object.name) &&\n        node.property.type === \"Identifier\" &&\n        node.property.name === \"from\" &&\n        node.computed === false\n    );\n}\n\n/**\n * Checks whether or not a node is a method which has `thisArg`.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} Whether or not the node is a method which has `thisArg`.\n */\nfunction isMethodWhichHasThisArg(node) {\n    while (node) {\n        if (node.type === \"Identifier\") {\n            return arrayMethodPattern.test(node.name);\n        }\n        if (node.type === \"MemberExpression\" && !node.computed) {\n            node = node.property;\n            continue;\n        }\n\n        break;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether or not a node has a `@this` tag in its comments.\n * @param {ASTNode} node - A node to check.\n * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n * @returns {boolean} Whether or not the node has a `@this` tag in its comments.\n */\nfunction hasJSDocThisTag(node, sourceCode) {\n    var jsdocComment = sourceCode.getJSDocComment(node);\n\n    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {\n        return true;\n    }\n\n    // Checks `@this` in its leading comments for callbacks,\n    // because callbacks don't have its JSDoc comment.\n    // e.g.\n    //     sinon.test(/* @this sinon.Sandbox */function() { this.spy(); });\n    return sourceCode.getComments(node).leading.some(function(comment) {\n        return thisTagPattern.test(comment.value);\n    });\n}\n\n/**\n * Determines if a node is surrounded by parentheses.\n * @param {SourceCode} sourceCode The ESLint source code object\n * @param {ASTNode} node The node to be checked.\n * @returns {boolean} True if the node is parenthesised.\n * @private\n */\nfunction isParenthesised(sourceCode, node) {\n    var previousToken = sourceCode.getTokenBefore(node),\n        nextToken = sourceCode.getTokenAfter(node);\n\n    return Boolean(previousToken && nextToken) &&\n        previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n        nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n\n    /**\n     * Determines whether two adjacent tokens are on the same line.\n     * @param {Object} left - The left token object.\n     * @param {Object} right - The right token object.\n     * @returns {boolean} Whether or not the tokens are on the same line.\n     * @public\n     */\n    isTokenOnSameLine: function(left, right) {\n        return left.loc.end.line === right.loc.start.line;\n    },\n\n    isNullOrUndefined: isNullOrUndefined,\n    isCallee: isCallee,\n    isES5Constructor: isES5Constructor,\n    getUpperFunction: getUpperFunction,\n    isArrayFromMethod: isArrayFromMethod,\n    isParenthesised: isParenthesised,\n\n    /**\n     * Checks whether or not a given node is a string literal.\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is a string literal.\n     */\n    isStringLiteral: function(node) {\n        return (\n            (node.type === \"Literal\" && typeof node.value === \"string\") ||\n            node.type === \"TemplateLiteral\"\n        );\n    },\n\n    /**\n     * Checks whether a given node is a breakable statement or not.\n     * The node is breakable if the node is one of the following type:\n     *\n     * - DoWhileStatement\n     * - ForInStatement\n     * - ForOfStatement\n     * - ForStatement\n     * - SwitchStatement\n     * - WhileStatement\n     *\n     * @param {ASTNode} node - A node to check.\n     * @returns {boolean} `true` if the node is breakable.\n     */\n    isBreakableStatement: function(node) {\n        return breakableTypePattern.test(node.type);\n    },\n\n    /**\n     * Gets the label if the parent node of a given node is a LabeledStatement.\n     *\n     * @param {ASTNode} node - A node to get.\n     * @returns {string|null} The label or `null`.\n     */\n    getLabel: function(node) {\n        if (node.parent.type === \"LabeledStatement\") {\n            return node.parent.label.name;\n        }\n        return null;\n    },\n\n    /**\n     * Gets references which are non initializer and writable.\n     * @param {Reference[]} references - An array of references.\n     * @returns {Reference[]} An array of only references which are non initializer and writable.\n     * @public\n     */\n    getModifyingReferences: function(references) {\n        return references.filter(isModifyingReference);\n    },\n\n    /**\n     * Validate that a string passed in is surrounded by the specified character\n     * @param  {string} val The text to check.\n     * @param  {string} character The character to see if it's surrounded by.\n     * @returns {boolean} True if the text is surrounded by the character, false if not.\n     * @private\n     */\n    isSurroundedBy: function(val, character) {\n        return val[0] === character && val[val.length - 1] === character;\n    },\n\n    /**\n     * Returns whether the provided node is an ESLint directive comment or not\n     * @param {LineComment|BlockComment} node The node to be checked\n     * @returns {boolean} `true` if the node is an ESLint directive comment\n     */\n    isDirectiveComment: function(node) {\n        var comment = node.value.trim();\n\n        return (\n            node.type === \"Line\" && comment.indexOf(\"eslint-\") === 0 ||\n            node.type === \"Block\" && (\n                comment.indexOf(\"global \") === 0 ||\n                comment.indexOf(\"eslint \") === 0 ||\n                comment.indexOf(\"eslint-\") === 0\n            )\n        );\n    },\n\n    /**\n     * Gets the trailing statement of a given node.\n     *\n     *     if (code)\n     *         consequent;\n     *\n     * When taking this `IfStatement`, returns `consequent;` statement.\n     *\n     * @param {ASTNode} A node to get.\n     * @returns {ASTNode|null} The trailing statement's node.\n     */\n    getTrailingStatement: esutils.ast.trailingStatement,\n\n    /**\n     * Finds the variable by a given name in a given scope and its upper scopes.\n     *\n     * @param {escope.Scope} initScope - A scope to start find.\n     * @param {string} name - A variable name to find.\n     * @returns {escope.Variable|null} A found variable or `null`.\n     */\n    getVariableByName: function(initScope, name) {\n        var scope = initScope;\n\n        while (scope) {\n            var variable = scope.set.get(name);\n\n            if (variable) {\n                return variable;\n            }\n\n            scope = scope.upper;\n        }\n\n        return null;\n    },\n\n    /**\n     * Checks whether or not a given function node is the default `this` binding.\n     *\n     * First, this checks the node:\n     *\n     * - The function name does not start with uppercase (it's a constructor).\n     * - The function does not have a JSDoc comment that has a @this tag.\n     *\n     * Next, this checks the location of the node.\n     * If the location is below, this judges `this` is valid.\n     *\n     * - The location is not on an object literal.\n     * - The location does not assign to a property.\n     * - The location is not on an ES2015 class.\n     * - The location does not call its `bind`/`call`/`apply` method directly.\n     * - The function is not a callback of array methods (such as `.forEach()`) if `thisArg` is given.\n     *\n     * @param {ASTNode} node - A function node to check.\n     * @param {SourceCode} sourceCode - A SourceCode instance to get comments.\n     * @returns {boolean} The function node is the default `this` binding.\n     */\n    isDefaultThisBinding: function(node, sourceCode) {\n        if (isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {\n            return false;\n        }\n\n        while (node) {\n            var parent = node.parent;\n\n            switch (parent.type) {\n\n                /*\n                 * Looks up the destination.\n                 * e.g., obj.foo = nativeFoo || function foo() { ... };\n                 */\n                case \"LogicalExpression\":\n                case \"ConditionalExpression\":\n                    node = parent;\n                    break;\n\n                // If the upper function is IIFE, checks the destination of the return value.\n                // e.g.\n                //   obj.foo = (function() {\n                //     // setup...\n                //     return function foo() { ... };\n                //   })();\n                case \"ReturnStatement\":\n                    var func = getUpperFunction(parent);\n\n                    if (func === null || !isCallee(func)) {\n                        return true;\n                    }\n                    node = func.parent;\n                    break;\n\n                // e.g.\n                //   var obj = { foo() { ... } };\n                //   var obj = { foo: function() { ... } };\n                case \"Property\":\n                    return false;\n\n                // e.g.\n                //   obj.foo = foo() { ... };\n                case \"AssignmentExpression\":\n                    return (\n                        parent.right !== node ||\n                        parent.left.type !== \"MemberExpression\"\n                    );\n\n                // e.g.\n                //   class A { constructor() { ... } }\n                //   class A { foo() { ... } }\n                //   class A { get foo() { ... } }\n                //   class A { set foo() { ... } }\n                //   class A { static foo() { ... } }\n                case \"MethodDefinition\":\n                    return false;\n\n                // e.g.\n                //   var foo = function foo() { ... }.bind(obj);\n                //   (function foo() { ... }).call(obj);\n                //   (function foo() { ... }).apply(obj, []);\n                case \"MemberExpression\":\n                    return (\n                        parent.object !== node ||\n                        parent.property.type !== \"Identifier\" ||\n                        !bindOrCallOrApplyPattern.test(parent.property.name) ||\n                        !isCallee(parent) ||\n                        parent.parent.arguments.length === 0 ||\n                        isNullOrUndefined(parent.parent.arguments[0])\n                    );\n\n                // e.g.\n                //   Reflect.apply(function() {}, obj, []);\n                //   Array.from([], function() {}, obj);\n                //   list.forEach(function() {}, obj);\n                case \"CallExpression\":\n                    if (isReflectApply(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    if (isArrayFromMethod(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 3 ||\n                            parent.arguments[1] !== node ||\n                            isNullOrUndefined(parent.arguments[2])\n                        );\n                    }\n                    if (isMethodWhichHasThisArg(parent.callee)) {\n                        return (\n                            parent.arguments.length !== 2 ||\n                            parent.arguments[0] !== node ||\n                            isNullOrUndefined(parent.arguments[1])\n                        );\n                    }\n                    return true;\n\n                // Otherwise `this` is default.\n                default:\n                    return true;\n            }\n        }\n\n        /* istanbul ignore next */\n        return true;\n    }\n};\n"]}