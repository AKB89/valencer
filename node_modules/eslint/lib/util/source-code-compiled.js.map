{"version":3,"sources":["source-code.js"],"names":[],"mappings":"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","file":"source-code-compiled.js","sourcesContent":["/**\n * @fileoverview Abstraction of JavaScript source code.\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar lodash = require(\"lodash\"),\n    createTokenStore = require(\"../token-store.js\"),\n    Traverser = require(\"./traverser\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\n/**\n * Validates that the given AST has the required information.\n * @param {ASTNode} ast The Program node of the AST to check.\n * @throws {Error} If the AST doesn't contain the correct information.\n * @returns {void}\n * @private\n */\nfunction validate(ast) {\n\n    if (!ast.tokens) {\n        throw new Error(\"AST is missing the tokens array.\");\n    }\n\n    if (!ast.comments) {\n        throw new Error(\"AST is missing the comments array.\");\n    }\n\n    if (!ast.loc) {\n        throw new Error(\"AST is missing location information.\");\n    }\n\n    if (!ast.range) {\n        throw new Error(\"AST is missing range information\");\n    }\n}\n\n/**\n * Finds a JSDoc comment node in an array of comment nodes.\n * @param {ASTNode[]} comments The array of comment nodes to search.\n * @param {int} line Line number to look around\n * @returns {ASTNode} The node if found, null if not.\n * @private\n */\nfunction findJSDocComment(comments, line) {\n\n    if (comments) {\n        for (var i = comments.length - 1; i >= 0; i--) {\n            if (comments[i].type === \"Block\" && comments[i].value.charAt(0) === \"*\") {\n\n                if (line - comments[i].loc.end.line <= 1) {\n                    return comments[i];\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * Check to see if its a ES6 export declaration\n * @param {ASTNode} astNode - any node\n * @returns {boolean} whether the given node represents a export declaration\n * @private\n */\nfunction looksLikeExport(astNode) {\n    return astNode.type === \"ExportDefaultDeclaration\" || astNode.type === \"ExportNamedDeclaration\" ||\n        astNode.type === \"ExportAllDeclaration\" || astNode.type === \"ExportSpecifier\";\n}\n\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Represents parsed source code.\n * @param {string} text - The source code text.\n * @param {ASTNode} ast - The Program node of the AST representing the code. This AST should be created from the text that BOM was stripped.\n * @constructor\n */\nfunction SourceCode(text, ast) {\n    validate(ast);\n\n    /**\n     * The flag to indicate that the source code has Unicode BOM.\n     * @type boolean\n     */\n    this.hasBOM = (text.charCodeAt(0) === 0xFEFF);\n\n    /**\n     * The original text source code.\n     * BOM was stripped from this text.\n     * @type string\n     */\n    this.text = (this.hasBOM ? text.slice(1) : text);\n\n    /**\n     * The parsed AST for the source code.\n     * @type ASTNode\n     */\n    this.ast = ast;\n\n    /**\n     * The source code split into lines according to ECMA-262 specification.\n     * This is done to avoid each rule needing to do so separately.\n     * @type string[]\n     */\n    this.lines = SourceCode.splitLines(this.text);\n\n    this.tokensAndComments = ast.tokens.concat(ast.comments).sort(function(left, right) {\n        return left.range[0] - right.range[0];\n    });\n\n    // create token store methods\n    var tokenStore = createTokenStore(ast.tokens);\n\n    Object.keys(tokenStore).forEach(function(methodName) {\n        this[methodName] = tokenStore[methodName];\n    }, this);\n\n    var tokensAndCommentsStore = createTokenStore(this.tokensAndComments);\n\n    this.getTokenOrCommentBefore = tokensAndCommentsStore.getTokenBefore;\n    this.getTokenOrCommentAfter = tokensAndCommentsStore.getTokenAfter;\n\n    // don't allow modification of this object\n    Object.freeze(this);\n    Object.freeze(this.lines);\n}\n\n/**\n * Split the source code into multiple lines based on the line delimiters\n * @param {string} text Source code as a string\n * @returns {string[]} Array of source code lines\n * @public\n */\nSourceCode.splitLines = function(text) {\n    return text.split(/\\r\\n|\\r|\\n|\\u2028|\\u2029/g);\n};\n\nSourceCode.prototype = {\n    constructor: SourceCode,\n\n    /**\n     * Gets the source code for the given node.\n     * @param {ASTNode=} node The AST node to get the text for.\n     * @param {int=} beforeCount The number of characters before the node to retrieve.\n     * @param {int=} afterCount The number of characters after the node to retrieve.\n     * @returns {string} The text representing the AST node.\n     */\n    getText: function(node, beforeCount, afterCount) {\n        if (node) {\n            return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0),\n                node.range[1] + (afterCount || 0));\n        } else {\n            return this.text;\n        }\n\n    },\n\n    /**\n     * Gets the entire source text split into an array of lines.\n     * @returns {Array} The source text as an array of lines.\n     */\n    getLines: function() {\n        return this.lines;\n    },\n\n    /**\n     * Retrieves an array containing all comments in the source code.\n     * @returns {ASTNode[]} An array of comment nodes.\n     */\n    getAllComments: function() {\n        return this.ast.comments;\n    },\n\n    /**\n     * Gets all comments for the given node.\n     * @param {ASTNode} node The AST node to get the comments for.\n     * @returns {Object} The list of comments indexed by their position.\n     * @public\n     */\n    getComments: function(node) {\n\n        var leadingComments = node.leadingComments || [],\n            trailingComments = node.trailingComments || [];\n\n        /*\n         * espree adds a \"comments\" array on Program nodes rather than\n         * leadingComments/trailingComments. Comments are only left in the\n         * Program node comments array if there is no executable code.\n         */\n        if (node.type === \"Program\") {\n            if (node.body.length === 0) {\n                leadingComments = node.comments;\n            }\n        }\n\n        return {\n            leading: leadingComments,\n            trailing: trailingComments\n        };\n    },\n\n    /**\n     * Retrieves the JSDoc comment for a given node.\n     * @param {ASTNode} node The AST node to get the comment for.\n     * @returns {ASTNode} The BlockComment node containing the JSDoc for the\n     *      given node or null if not found.\n     * @public\n     */\n    getJSDocComment: function(node) {\n\n        var parent = node.parent;\n\n        switch (node.type) {\n            case \"ClassDeclaration\":\n            case \"FunctionDeclaration\":\n                if (looksLikeExport(parent)) {\n                    return findJSDocComment(parent.leadingComments, parent.loc.start.line);\n                }\n                return findJSDocComment(node.leadingComments, node.loc.start.line);\n\n            case \"ClassExpression\":\n                return findJSDocComment(parent.parent.leadingComments, parent.parent.loc.start.line);\n\n            case \"ArrowFunctionExpression\":\n            case \"FunctionExpression\":\n\n                if (parent.type !== \"CallExpression\" && parent.type !== \"NewExpression\") {\n                    while (parent && !parent.leadingComments && !/Function/.test(parent.type) && parent.type !== \"MethodDefinition\" && parent.type !== \"Property\") {\n                        parent = parent.parent;\n                    }\n\n                    return parent && (parent.type !== \"FunctionDeclaration\") ? findJSDocComment(parent.leadingComments, parent.loc.start.line) : null;\n                } else if (node.leadingComments) {\n                    return findJSDocComment(node.leadingComments, node.loc.start.line);\n                }\n\n            // falls through\n\n            default:\n                return null;\n        }\n    },\n\n    /**\n     * Gets the deepest node containing a range index.\n     * @param {int} index Range index of the desired node.\n     * @returns {ASTNode} The node if found or null if not found.\n     */\n    getNodeByRangeIndex: function(index) {\n        var result = null,\n            resultParent = null,\n            traverser = new Traverser();\n\n        traverser.traverse(this.ast, {\n            enter: function(node, parent) {\n                if (node.range[0] <= index && index < node.range[1]) {\n                    result = node;\n                    resultParent = parent;\n                } else {\n                    this.skip();\n                }\n            },\n            leave: function(node) {\n                if (node === result) {\n                    this.break();\n                }\n            }\n        });\n\n        return result ? lodash.assign({parent: resultParent}, result) : null;\n    },\n\n    /**\n     * Determines if two tokens have at least one whitespace character\n     * between them. This completely disregards comments in making the\n     * determination, so comments count as zero-length substrings.\n     * @param {Token} first The token to check after.\n     * @param {Token} second The token to check before.\n     * @returns {boolean} True if there is only space between tokens, false\n     *  if there is anything other than whitespace between tokens.\n     */\n    isSpaceBetweenTokens: function(first, second) {\n        var text = this.text.slice(first.range[1], second.range[0]);\n\n        return /\\s/.test(text.replace(/\\/\\*.*?\\*\\//g, \"\"));\n    }\n};\n\n\nmodule.exports = SourceCode;\n"]}