{"version":3,"sources":["module-resolver.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,IAAI,SAAS,QAAQ,QAAR,CAAb;IACI,SAAS,QAAQ,QAAR,CADb;;;;;;AAOA,IAAI,kBAAkB;;;;;;;;;;AAUlB,eAAa,OAAO,KAAP,GAAe,OAAO,KAAP,CAAa,MAAb,CAAoB,OAAO,WAA3B,CAAf,GAAyD,OAAO,WAAP,CAAmB,MAAnB;AAVpD,CAAtB;;;;;;;;;AAoBA,SAAS,cAAT,CAAwB,OAAxB,EAAiC;AAC7B,YAAU,WAAW,EAArB;;AAEA,OAAK,OAAL,GAAe,OAAO,MAAP,CAAc,EAAd,EAAkB,eAAlB,EAAmC,OAAnC,CAAf;AACH;;AAED,eAAe,SAAf,GAA2B;;;;;;;;;;;AAWvB,WAAS,UAAS,IAAT,EAAe,eAAf,EAAgC;;;;;;;AAOrC,QAAI,cAAc,KAAK,OAAL,CAAa,WAAb,CAAyB,MAAzB,EAAlB;;AAEA,gBAAY,OAAZ,CAAoB,eAApB;;;;;;;AAOA,QAAI,SAAS,OAAO,SAAP,CAAiB,IAAjB,EAAuB,WAAvB,CAAb,C;;AAEA,QAAI,CAAC,MAAL,EAAa;AACT,YAAM,IAAI,KAAJ,CAAU,yBAAyB,IAAzB,GAAgC,GAA1C,CAAN;AACH;;AAED,WAAO,MAAP;AAEH;;AAnCsB,CAA3B;;;;;;AA2CA,OAAO,OAAP,GAAiB,cAAjB","file":"module-resolver-compiled.js","sourcesContent":["/**\n * @fileoverview Implements the Node.js require.resolve algorithm\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar lodash = require(\"lodash\"),\n    Module = require(\"module\");\n\n//------------------------------------------------------------------------------\n// Private\n//------------------------------------------------------------------------------\n\nvar DEFAULT_OPTIONS = {\n\n    /*\n     * module.paths is an array of paths to search for resolving things relative\n     * to this file. Module.globalPaths contains all of the special Node.js\n     * directories that can also be searched for modules.\n     *\n     * Need to check for existence of module.paths because Jest seems not to\n     * include it. See https://github.com/eslint/eslint/issues/5791.\n     */\n    lookupPaths: module.paths ? module.paths.concat(Module.globalPaths) : Module.globalPaths.concat()\n};\n\n/**\n * Resolves modules based on a set of options.\n * @param {Object} options The options for resolving modules.\n * @param {string[]} options.lookupPaths An array of paths to include in the\n *      lookup with the highest priority paths coming first.\n * @constructor\n */\nfunction ModuleResolver(options) {\n    options = options || {};\n\n    this.options = lodash.assign({}, DEFAULT_OPTIONS, options);\n}\n\nModuleResolver.prototype = {\n\n    /**\n     * Resolves the file location of a given module relative to the configured\n     * lookup paths.\n     * @param {string} name The module name to resolve.\n     * @param {string} extraLookupPath An extra path to look into for the module.\n     *      This path is used with the highest priority.\n     * @returns {string} The resolved file path for the module.\n     * @throws {Error} If the module cannot be resolved.\n     */\n    resolve: function(name, extraLookupPath) {\n\n        /*\n         * First, clone the lookup paths so we're not messing things up for\n         * subsequent calls to this function. Then, move the extraLookupPath to the\n         * top of the lookup paths list so it will be searched first.\n         */\n        var lookupPaths = this.options.lookupPaths.concat();\n\n        lookupPaths.unshift(extraLookupPath);\n\n        /**\n         * Module._findPath is an internal method to Node.js, then one they use to\n         * lookup file paths when require() is called. So, we are hooking into the\n         * exact same logic that Node.js uses.\n         */\n        var result = Module._findPath(name, lookupPaths);   // eslint-disable-line no-underscore-dangle\n\n        if (!result) {\n            throw new Error(\"Cannot find module '\" + name + \"'\");\n        }\n\n        return result;\n\n    }\n\n};\n\n//------------------------------------------------------------------------------\n// Public API\n//------------------------------------------------------------------------------\n\nmodule.exports = ModuleResolver;\n"]}