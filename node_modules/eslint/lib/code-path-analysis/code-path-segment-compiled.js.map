{"version":3,"sources":["code-path-segment.js"],"names":[],"mappings":"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","file":"code-path-segment-compiled.js","sourcesContent":["/**\n * @fileoverview A class of the code path segment.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar debug = require(\"./debug-helpers\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Replaces unused segments with the previous segments of each unused segment.\n *\n * @param {CodePathSegment[]} segments - An array of segments to replace.\n * @returns {CodePathSegment[]} The replaced array.\n */\nfunction flattenUnusedSegments(segments) {\n    var done = Object.create(null);\n    var retv = [];\n\n    for (var i = 0; i < segments.length; ++i) {\n        var segment = segments[i];\n\n        // Ignores duplicated.\n        if (done[segment.id]) {\n            continue;\n        }\n\n        // Use previous segments if unused.\n        if (!segment.internal.used) {\n            for (var j = 0; j < segment.allPrevSegments.length; ++j) {\n                var prevSegment = segment.allPrevSegments[j];\n\n                if (!done[prevSegment.id]) {\n                    done[prevSegment.id] = true;\n                    retv.push(prevSegment);\n                }\n            }\n        } else {\n            done[segment.id] = true;\n            retv.push(segment);\n        }\n    }\n\n    return retv;\n}\n\n/**\n * Checks whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path segment.\n *\n * @constructor\n * @param {string} id - An identifier.\n * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n *   This array includes unreachable segments.\n * @param {boolean} reachable - A flag which shows this is reachable.\n */\nfunction CodePathSegment(id, allPrevSegments, reachable) {\n\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * An array of the next segments.\n     * @type {CodePathSegment[]}\n     */\n    this.nextSegments = [];\n\n    /**\n     * An array of the previous segments.\n     * @type {CodePathSegment[]}\n     */\n    this.prevSegments = allPrevSegments.filter(isReachable);\n\n    /**\n     * An array of the next segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n    this.allNextSegments = [];\n\n    /**\n     * An array of the previous segments.\n     * This array includes unreachable segments.\n     * @type {CodePathSegment[]}\n     */\n    this.allPrevSegments = allPrevSegments;\n\n    /**\n     * A flag which shows this is reachable.\n     * @type {boolean}\n     */\n    this.reachable = reachable;\n\n    // Internal data.\n    Object.defineProperty(this, \"internal\", {value: {\n        used: false,\n        loopedPrevSegments: []\n    }});\n\n    /* istanbul ignore if */\n    if (debug.enabled) {\n        this.internal.nodes = [];\n        this.internal.exitNodes = [];\n    }\n}\n\nCodePathSegment.prototype = {\n    constructor: CodePathSegment,\n\n    /**\n     * Checks a given previous segment is coming from the end of a loop.\n     *\n     * @param {CodePathSegment} segment - A previous segment to check.\n     * @returns {boolean} `true` if the segment is coming from the end of a loop.\n     */\n    isLoopedPrevSegment: function(segment) {\n        return this.internal.loopedPrevSegments.indexOf(segment) !== -1;\n    }\n};\n\n/**\n * Creates the root segment.\n *\n * @param {string} id - An identifier.\n * @returns {CodePathSegment} The created segment.\n */\nCodePathSegment.newRoot = function(id) {\n    return new CodePathSegment(id, [], true);\n};\n\n/**\n * Creates a segment that follows given segments.\n *\n * @param {string} id - An identifier.\n * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n * @returns {CodePathSegment} The created segment.\n */\nCodePathSegment.newNext = function(id, allPrevSegments) {\n    return new CodePathSegment(\n        id,\n        flattenUnusedSegments(allPrevSegments),\n        allPrevSegments.some(isReachable));\n};\n\n/**\n * Creates an unreachable segment that follows given segments.\n *\n * @param {string} id - An identifier.\n * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n * @returns {CodePathSegment} The created segment.\n */\nCodePathSegment.newUnreachable = function(id, allPrevSegments) {\n    var segment = new CodePathSegment(id, flattenUnusedSegments(allPrevSegments), false);\n\n    // In `if (a) return a; foo();` case, the unreachable segment preceded by\n    // the return statement is not used but must not be remove.\n    CodePathSegment.markUsed(segment);\n\n    return segment;\n};\n\n/**\n * Creates a segment that follows given segments.\n * This factory method does not connect with `allPrevSegments`.\n * But this inherits `reachable` flag.\n *\n * @param {string} id - An identifier.\n * @param {CodePathSegment[]} allPrevSegments - An array of the previous segments.\n * @returns {CodePathSegment} The created segment.\n */\nCodePathSegment.newDisconnected = function(id, allPrevSegments) {\n    return new CodePathSegment(id, [], allPrevSegments.some(isReachable));\n};\n\n/**\n * Makes a given segment being used.\n *\n * And this function registers the segment into the previous segments as a next.\n *\n * @param {CodePathSegment} segment - A segment to mark.\n * @returns {void}\n */\nCodePathSegment.markUsed = function(segment) {\n    if (segment.internal.used) {\n        return;\n    }\n    segment.internal.used = true;\n\n    var i;\n\n    if (segment.reachable) {\n        for (i = 0; i < segment.allPrevSegments.length; ++i) {\n            var prevSegment = segment.allPrevSegments[i];\n\n            prevSegment.allNextSegments.push(segment);\n            prevSegment.nextSegments.push(segment);\n        }\n    } else {\n        for (i = 0; i < segment.allPrevSegments.length; ++i) {\n            segment.allPrevSegments[i].allNextSegments.push(segment);\n        }\n    }\n};\n\n/**\n * Marks a previous segment as looped.\n *\n * @param {CodePathSegment} segment - A segment.\n * @param {CodePathSegment} prevSegment - A previous segment to mark.\n * @returns {void}\n */\nCodePathSegment.markPrevSegmentAsLooped = function(segment, prevSegment) {\n    segment.internal.loopedPrevSegments.push(prevSegment);\n};\n\nmodule.exports = CodePathSegment;\n"]}