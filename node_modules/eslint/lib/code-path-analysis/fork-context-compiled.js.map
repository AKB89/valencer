{"version":3,"sources":["fork-context.js"],"names":[],"mappings":"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","file":"fork-context-compiled.js","sourcesContent":["/**\n * @fileoverview A class to operate forking.\n *\n * This is state of forking.\n * This has a fork list and manages it.\n *\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar assert = require(\"assert\"),\n    CodePathSegment = require(\"./code-path-segment\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Gets whether or not a given segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to get.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Creates new segments from the specific range of `context.segmentsList`.\n *\n * When `context.segmentsList` is `[[a, b], [c, d], [e, f]]`, `begin` is `0`, and\n * `end` is `-1`, this creates `[g, h]`. This `g` is from `a`, `c`, and `e`.\n * This `h` is from `b`, `d`, and `f`.\n *\n * @param {ForkContext} context - An instance.\n * @param {number} begin - The first index of the previous segments.\n * @param {number} end - The last index of the previous segments.\n * @param {function} create - A factory function of new segments.\n * @returns {CodePathSegment[]} New segments.\n */\nfunction makeSegments(context, begin, end, create) {\n    var list = context.segmentsList;\n\n    if (begin < 0) {\n        begin = list.length + begin;\n    }\n    if (end < 0) {\n        end = list.length + end;\n    }\n\n    var segments = [];\n\n    for (var i = 0; i < context.count; ++i) {\n        var allPrevSegments = [];\n\n        for (var j = begin; j <= end; ++j) {\n            allPrevSegments.push(list[j][i]);\n        }\n\n        segments.push(create(context.idGenerator.next(), allPrevSegments));\n    }\n\n    return segments;\n}\n\n/**\n * `segments` becomes doubly in a `finally` block. Then if a code path exits by a\n * control statement (such as `break`, `continue`) from the `finally` block, the\n * destination's segments may be half of the source segments. In that case, this\n * merges segments.\n *\n * @param {ForkContext} context - An instance.\n * @param {CodePathSegment[]} segments - Segments to merge.\n * @returns {CodePathSegment[]} The merged segments.\n */\nfunction mergeExtraSegments(context, segments) {\n    while (segments.length > context.count) {\n        var merged = [];\n\n        for (var i = 0, length = segments.length / 2 | 0; i < length; ++i) {\n            merged.push(CodePathSegment.newNext(\n                context.idGenerator.next(),\n                [segments[i], segments[i + length]]\n            ));\n        }\n        segments = merged;\n    }\n    return segments;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class to manage forking.\n *\n * @constructor\n * @param {IdGenerator} idGenerator - An identifier generator for segments.\n * @param {ForkContext|null} upper - An upper fork context.\n * @param {number} count - A number of parallel segments.\n */\nfunction ForkContext(idGenerator, upper, count) {\n    this.idGenerator = idGenerator;\n    this.upper = upper;\n    this.count = count;\n    this.segmentsList = [];\n}\n\nForkContext.prototype = {\n    constructor: ForkContext,\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get head() {\n        var list = this.segmentsList;\n\n        return list.length === 0 ? [] : list[list.length - 1];\n    },\n\n    /**\n     * A flag which shows empty.\n     * @type {boolean}\n     */\n    get empty() {\n        return this.segmentsList.length === 0;\n    },\n\n    /**\n     * A flag which shows reachable.\n     * @type {boolean}\n     */\n    get reachable() {\n        var segments = this.head;\n\n        return segments.length > 0 && segments.some(isReachable);\n    },\n\n    /**\n     * Creates new segments from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeNext: function(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newNext);\n    },\n\n    /**\n     * Creates new segments from this context.\n     * The new segments is always unreachable.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeUnreachable: function(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newUnreachable);\n    },\n\n    /**\n     * Creates new segments from this context.\n     * The new segments don't have connections for previous segments.\n     * But these inherit the reachable flag from this context.\n     *\n     * @param {number} begin - The first index of previous segments.\n     * @param {number} end - The last index of previous segments.\n     * @returns {CodePathSegment[]} New segments.\n     */\n    makeDisconnected: function(begin, end) {\n        return makeSegments(this, begin, end, CodePathSegment.newDisconnected);\n    },\n\n    /**\n     * Adds segments into this context.\n     * The added segments become the head.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    add: function(segments) {\n        assert(segments.length >= this.count, segments.length + \" >= \" + this.count);\n\n        this.segmentsList.push(mergeExtraSegments(this, segments));\n    },\n\n    /**\n     * Replaces the head segments with given segments.\n     * The current head segments are removed.\n     *\n     * @param {CodePathSegment[]} segments - Segments to add.\n     * @returns {void}\n     */\n    replaceHead: function(segments) {\n        assert(segments.length >= this.count, segments.length + \" >= \" + this.count);\n\n        this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));\n    },\n\n    /**\n     * Adds all segments of a given fork context into this context.\n     *\n     * @param {ForkContext} context - A fork context to add.\n     * @returns {void}\n     */\n    addAll: function(context) {\n        assert(context.count === this.count);\n\n        var source = context.segmentsList;\n\n        for (var i = 0; i < source.length; ++i) {\n            this.segmentsList.push(source[i]);\n        }\n    },\n\n    /**\n     * Clears all secments in this context.\n     *\n     * @returns {void}\n     */\n    clear: function() {\n        this.segmentsList = [];\n    }\n};\n\n/**\n * Creates the root fork context.\n *\n * @param {IdGenerator} idGenerator - An identifier generator for segments.\n * @returns {ForkContext} New fork context.\n */\nForkContext.newRoot = function(idGenerator) {\n    var context = new ForkContext(idGenerator, null, 1);\n\n    context.add([CodePathSegment.newRoot(idGenerator.next())]);\n\n    return context;\n};\n\n/**\n * Creates an empty fork context preceded by a given context.\n *\n * @param {ForkContext} parentContext - The parent fork context.\n * @param {boolean} forkLeavingPath - A flag which shows inside of `finally` block.\n * @returns {ForkContext} New fork context.\n */\nForkContext.newEmpty = function(parentContext, forkLeavingPath) {\n    return new ForkContext(\n        parentContext.idGenerator,\n        parentContext,\n        (forkLeavingPath ? 2 : 1) * parentContext.count);\n};\n\nmodule.exports = ForkContext;\n"]}