{"version":3,"sources":["code-path-analyzer.js"],"names":[],"mappings":"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","file":"code-path-analyzer-compiled.js","sourcesContent":["/**\n * @fileoverview A class of the code path analyzer.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar assert = require(\"assert\"),\n    CodePath = require(\"./code-path\"),\n    CodePathSegment = require(\"./code-path-segment\"),\n    IdGenerator = require(\"./id-generator\"),\n    debug = require(\"./debug-helpers\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a `case` node (not `default` node).\n *\n * @param {ASTNode} node - A `SwitchCase` node to check.\n * @returns {boolean} `true` if the node is a `case` node (not `default` node).\n */\nfunction isCaseNode(node) {\n    return Boolean(node.test);\n}\n\n/**\n * Checks whether or not a given logical expression node goes different path\n * between the `true` case and the `false` case.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a test of a choice statement.\n */\nfunction isForkingByTrueOrFalse(node) {\n    var parent = node.parent;\n\n    switch (parent.type) {\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n            return parent.test === node;\n\n        case \"LogicalExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Gets the boolean value of a given literal node.\n *\n * This is used to detect infinity loops (e.g. `while (true) {}`).\n * Statements preceded by an infinity loop are unreachable if the loop didn't\n * have any `break` statement.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {boolean|undefined} a boolean value if the node is a Literal node,\n *   otherwise `undefined`.\n */\nfunction getBooleanValueIfSimpleConstant(node) {\n    if (node.type === \"Literal\") {\n        return Boolean(node.value);\n    }\n    return void 0;\n}\n\n/**\n * Checks that a given identifier node is a reference or not.\n *\n * This is used to detect the first throwable node in a `try` block.\n *\n * @param {ASTNode} node - An Identifier node to check.\n * @returns {boolean} `true` if the node is a reference.\n */\nfunction isIdentifierReference(node) {\n    var parent = node.parent;\n\n    switch (parent.type) {\n        case \"LabeledStatement\":\n        case \"BreakStatement\":\n        case \"ContinueStatement\":\n        case \"ArrayPattern\":\n        case \"RestElement\":\n        case \"ImportSpecifier\":\n        case \"ImportDefaultSpecifier\":\n        case \"ImportNamespaceSpecifier\":\n        case \"CatchClause\":\n            return false;\n\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n        case \"ClassDeclaration\":\n        case \"ClassExpression\":\n        case \"VariableDeclarator\":\n            return parent.id !== node;\n\n        case \"Property\":\n        case \"MethodDefinition\":\n            return (\n                parent.key !== node ||\n                parent.computed ||\n                parent.shorthand\n            );\n\n        case \"AssignmentPattern\":\n            return parent.key !== node;\n\n        default:\n            return true;\n    }\n}\n\n/**\n * Updates the current segment with the head segment.\n * This is similar to local branches and tracking branches of git.\n *\n * To separate the current and the head is in order to not make useless segments.\n *\n * In this process, both \"onCodePathSegmentStart\" and \"onCodePathSegmentEnd\"\n * events are fired.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction forwardCurrentToHead(analyzer, node) {\n    var codePath = analyzer.codePath;\n    var state = CodePath.getState(codePath);\n    var currentSegments = state.currentSegments;\n    var headSegments = state.headSegments;\n    var end = Math.max(currentSegments.length, headSegments.length);\n    var i, currentSegment, headSegment;\n\n    // Fires leaving events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && currentSegment) {\n            debug.dump(\"onCodePathSegmentEnd \" + currentSegment.id);\n\n            if (currentSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentEnd\",\n                    currentSegment,\n                    node);\n            }\n        }\n    }\n\n    // Update state.\n    state.currentSegments = headSegments;\n\n    // Fires entering events.\n    for (i = 0; i < end; ++i) {\n        currentSegment = currentSegments[i];\n        headSegment = headSegments[i];\n\n        if (currentSegment !== headSegment && headSegment) {\n            debug.dump(\"onCodePathSegmentStart \" + headSegment.id);\n\n            CodePathSegment.markUsed(headSegment);\n            if (headSegment.reachable) {\n                analyzer.emitter.emit(\n                    \"onCodePathSegmentStart\",\n                    headSegment,\n                    node);\n            }\n        }\n    }\n\n}\n\n/**\n * Updates the current segment with empty.\n * This is called at the last of functions or the program.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction leaveFromCurrentSegment(analyzer, node) {\n    var state = CodePath.getState(analyzer.codePath);\n    var currentSegments = state.currentSegments;\n\n    for (var i = 0; i < currentSegments.length; ++i) {\n        var currentSegment = currentSegments[i];\n\n        debug.dump(\"onCodePathSegmentEnd \" + currentSegment.id);\n        if (currentSegment.reachable) {\n            analyzer.emitter.emit(\n                \"onCodePathSegmentEnd\",\n                currentSegment,\n                node);\n        }\n    }\n\n    state.currentSegments = [];\n}\n\n/**\n * Updates the code path due to the position of a given node in the parent node\n * thereof.\n *\n * For example, if the node is `parent.consequent`, this creates a fork from the\n * current path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction preprocess(analyzer, node) {\n    var codePath = analyzer.codePath;\n    var state = CodePath.getState(codePath);\n    var parent = node.parent;\n\n    switch (parent.type) {\n        case \"LogicalExpression\":\n            if (parent.right === node) {\n                state.makeLogicalRight();\n            }\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n\n            /*\n             * Fork if this node is at `consequent`/`alternate`.\n             * `popForkContext()` exists at `IfStatement:exit` and\n             * `ConditionalExpression:exit`.\n             */\n            if (parent.consequent === node) {\n                state.makeIfConsequent();\n            } else if (parent.alternate === node) {\n                state.makeIfAlternate();\n            }\n            break;\n\n        case \"SwitchCase\":\n            if (parent.consequent[0] === node) {\n                state.makeSwitchCaseBody(false, !parent.test);\n            }\n            break;\n\n        case \"TryStatement\":\n            if (parent.handler === node) {\n                state.makeCatchBlock();\n            } else if (parent.finalizer === node) {\n                state.makeFinallyBlock();\n            }\n            break;\n\n        case \"WhileStatement\":\n            if (parent.test === node) {\n                state.makeWhileTest(getBooleanValueIfSimpleConstant(node));\n            } else {\n                assert(parent.body === node);\n                state.makeWhileBody();\n            }\n            break;\n\n        case \"DoWhileStatement\":\n            if (parent.body === node) {\n                state.makeDoWhileBody();\n            } else {\n                assert(parent.test === node);\n                state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));\n            }\n            break;\n\n        case \"ForStatement\":\n            if (parent.test === node) {\n                state.makeForTest(getBooleanValueIfSimpleConstant(node));\n            } else if (parent.update === node) {\n                state.makeForUpdate();\n            } else if (parent.body === node) {\n                state.makeForBody();\n            }\n            break;\n\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            if (parent.left === node) {\n                state.makeForInOfLeft();\n            } else if (parent.right === node) {\n                state.makeForInOfRight();\n            } else {\n                assert(parent.body === node);\n                state.makeForInOfBody();\n            }\n            break;\n\n        case \"AssignmentPattern\":\n\n            /*\n             * Fork if this node is at `right`.\n             * `left` is executed always, so it uses the current path.\n             * `popForkContext()` exists at `AssignmentPattern:exit`.\n             */\n            if (parent.right === node) {\n                state.pushForkContext();\n                state.forkBypassPath();\n                state.forkPath();\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n/**\n * Updates the code path due to the type of a given node in entering.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToEnter(analyzer, node) {\n    var codePath = analyzer.codePath;\n    var state = codePath && CodePath.getState(codePath);\n    var parent = node.parent;\n\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            if (codePath) {\n\n                // Emits onCodePathSegmentStart events if updated.\n                forwardCurrentToHead(analyzer, node);\n                debug.dumpState(node, state, false);\n            }\n\n            // Create the code path of this scope.\n            codePath = analyzer.codePath = new CodePath(\n                analyzer.idGenerator.next(),\n                codePath,\n                analyzer.onLooped\n            );\n            state = CodePath.getState(codePath);\n\n            // Emits onCodePathStart events.\n            debug.dump(\"onCodePathStart \" + codePath.id);\n            analyzer.emitter.emit(\"onCodePathStart\", codePath, node);\n            break;\n\n        case \"LogicalExpression\":\n            state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));\n            break;\n\n        case \"ConditionalExpression\":\n        case \"IfStatement\":\n            state.pushChoiceContext(\"test\", false);\n            break;\n\n        case \"SwitchStatement\":\n            state.pushSwitchContext(\n                node.cases.some(isCaseNode),\n                astUtils.getLabel(node));\n            break;\n\n        case \"TryStatement\":\n            state.pushTryContext(Boolean(node.finalizer));\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * Fork if this node is after the 2st node in `cases`.\n             * It's similar to `else` blocks.\n             * The next `test` node is processed in this path.\n             */\n            if (parent.discriminant !== node && parent.cases[0] !== node) {\n                state.forkPath();\n            }\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.pushLoopContext(node.type, astUtils.getLabel(node));\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.pushBreakContext(false, node.label.name);\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    // Emits onCodePathSegmentStart events if updated.\n    forwardCurrentToHead(analyzer, node);\n    debug.dumpState(node, state, false);\n}\n\n/**\n * Updates the code path due to the type of a given node in leaving.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction processCodePathToExit(analyzer, node) {\n    var codePath = analyzer.codePath;\n    var state = CodePath.getState(codePath);\n    var dontForward = false;\n\n    switch (node.type) {\n        case \"IfStatement\":\n        case \"ConditionalExpression\":\n        case \"LogicalExpression\":\n            state.popChoiceContext();\n            break;\n\n        case \"SwitchStatement\":\n            state.popSwitchContext();\n            break;\n\n        case \"SwitchCase\":\n\n            /*\n             * This is the same as the process at the 1st `consequent` node in\n             * `preprocess` function.\n             * Must do if this `consequent` is empty.\n             */\n            if (node.consequent.length === 0) {\n                state.makeSwitchCaseBody(true, !node.test);\n            }\n            if (state.forkContext.reachable) {\n                dontForward = true;\n            }\n            break;\n\n        case \"TryStatement\":\n            state.popTryContext();\n            break;\n\n        case \"BreakStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeBreak(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ContinueStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeContinue(node.label && node.label.name);\n            dontForward = true;\n            break;\n\n        case \"ReturnStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeReturn();\n            dontForward = true;\n            break;\n\n        case \"ThrowStatement\":\n            forwardCurrentToHead(analyzer, node);\n            state.makeThrow();\n            dontForward = true;\n            break;\n\n        case \"Identifier\":\n            if (isIdentifierReference(node)) {\n                state.makeFirstThrowablePathInTryBlock();\n                dontForward = true;\n            }\n            break;\n\n        case \"CallExpression\":\n        case \"MemberExpression\":\n        case \"NewExpression\":\n            state.makeFirstThrowablePathInTryBlock();\n            break;\n\n        case \"WhileStatement\":\n        case \"DoWhileStatement\":\n        case \"ForStatement\":\n        case \"ForInStatement\":\n        case \"ForOfStatement\":\n            state.popLoopContext();\n            break;\n\n        case \"AssignmentPattern\":\n            state.popForkContext();\n            break;\n\n        case \"LabeledStatement\":\n            if (!astUtils.isBreakableStatement(node.body)) {\n                state.popBreakContext();\n            }\n            break;\n\n        default:\n            break;\n    }\n\n    /*\n     * Skip updating the current segment to avoid creating useless segments if\n     * the node type is the same as the parent node type.\n     */\n    if (!dontForward && (!node.parent || node.type !== node.parent.type)) {\n\n        // Emits onCodePathSegmentStart events if updated.\n        forwardCurrentToHead(analyzer, node);\n    }\n    debug.dumpState(node, state, true);\n}\n\n/**\n * Updates the code path to finalize the current code path.\n *\n * @param {CodePathAnalyzer} analyzer - The instance.\n * @param {ASTNode} node - The current AST node.\n * @returns {void}\n */\nfunction postprocess(analyzer, node) {\n    switch (node.type) {\n        case \"Program\":\n        case \"FunctionDeclaration\":\n        case \"FunctionExpression\":\n        case \"ArrowFunctionExpression\":\n            var codePath = analyzer.codePath;\n\n            // Mark the current path as the final node.\n            CodePath.getState(codePath).makeFinal();\n\n            // Emits onCodePathSegmentEnd event of the current segments.\n            leaveFromCurrentSegment(analyzer, node);\n\n            // Emits onCodePathEnd event of this code path.\n            debug.dump(\"onCodePathEnd \" + codePath.id);\n            analyzer.emitter.emit(\"onCodePathEnd\", codePath, node);\n            debug.dumpDot(codePath);\n\n            codePath = analyzer.codePath = analyzer.codePath.upper;\n            if (codePath) {\n                debug.dumpState(node, CodePath.getState(codePath), true);\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * The class to analyze code paths.\n * This class implements the EventGenerator interface.\n *\n * @constructor\n * @param {EventGenerator} eventGenerator - An event generator to wrap.\n */\nfunction CodePathAnalyzer(eventGenerator) {\n    this.original = eventGenerator;\n    this.emitter = eventGenerator.emitter;\n    this.codePath = null;\n    this.idGenerator = new IdGenerator(\"s\");\n    this.currentNode = null;\n    this.onLooped = this.onLooped.bind(this);\n}\n\nCodePathAnalyzer.prototype = {\n    constructor: CodePathAnalyzer,\n\n    /**\n     * Does the process to enter a given AST node.\n     * This updates state of analysis and calls `enterNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is entering.\n     * @returns {void}\n     */\n    enterNode: function(node) {\n        this.currentNode = node;\n\n        // Updates the code path due to node's position in its parent node.\n        if (node.parent) {\n            preprocess(this, node);\n        }\n\n        // Updates the code path.\n        // And emits onCodePathStart/onCodePathSegmentStart events.\n        processCodePathToEnter(this, node);\n\n        // Emits node events.\n        this.original.enterNode(node);\n\n        this.currentNode = null;\n    },\n\n    /**\n     * Does the process to leave a given AST node.\n     * This updates state of analysis and calls `leaveNode` of the wrapped.\n     *\n     * @param {ASTNode} node - A node which is leaving.\n     * @returns {void}\n     */\n    leaveNode: function(node) {\n        this.currentNode = node;\n\n        // Updates the code path.\n        // And emits onCodePathStart/onCodePathSegmentStart events.\n        processCodePathToExit(this, node);\n\n        // Emits node events.\n        this.original.leaveNode(node);\n\n        // Emits the last onCodePathStart/onCodePathSegmentStart events.\n        postprocess(this, node);\n\n        this.currentNode = null;\n    },\n\n    /**\n     * This is called on a code path looped.\n     * Then this raises a looped event.\n     *\n     * @param {CodePathSegment} fromSegment - A segment of prev.\n     * @param {CodePathSegment} toSegment - A segment of next.\n     * @returns {void}\n     */\n    onLooped: function(fromSegment, toSegment) {\n        if (fromSegment.reachable && toSegment.reachable) {\n            debug.dump(\"onCodePathSegmentLoop \" + fromSegment.id + \" -> \" + toSegment.id);\n            this.emitter.emit(\n                \"onCodePathSegmentLoop\",\n                fromSegment,\n                toSegment,\n                this.currentNode\n            );\n        }\n    }\n};\n\nmodule.exports = CodePathAnalyzer;\n"]}