{"version":3,"sources":["code-path-state.js"],"names":[],"mappings":"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","file":"code-path-state-compiled.js","sourcesContent":["/**\n * @fileoverview A class to manage state of generating a code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar CodePathSegment = require(\"./code-path-segment\"),\n    ForkContext = require(\"./fork-context\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Adds given segments into the `dest` array.\n * If the `others` array does not includes the given segments, adds to the `all`\n * array as well.\n *\n * This adds only reachable and used segments.\n *\n * @param {CodePathSegment[]} dest - A destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} others - Another destination array (`returnedSegments` or `thrownSegments`).\n * @param {CodePathSegment[]} all - The unified destination array (`finalSegments`).\n * @param {CodePathSegment[]} segments - Segments to add.\n * @returns {void}\n */\nfunction addToReturnedOrThrown(dest, others, all, segments) {\n    for (var i = 0; i < segments.length; ++i) {\n        var segment = segments[i];\n\n        dest.push(segment);\n        if (others.indexOf(segment) === -1) {\n            all.push(segment);\n        }\n    }\n}\n\n/**\n * Gets a loop-context for a `continue` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `continue` statement.\n * @returns {LoopContext} A loop-context for a `continue` statement.\n */\nfunction getContinueContext(state, label) {\n    if (!label) {\n        return state.loopContext;\n    }\n\n    var context = state.loopContext;\n\n    while (context) {\n        if (context.label === label) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `break` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @param {string} label - The label of a `break` statement.\n * @returns {LoopContext|SwitchContext} A context for a `break` statement.\n */\nfunction getBreakContext(state, label) {\n    var context = state.breakContext;\n\n    while (context) {\n        if (label ? context.label === label : context.breakable) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    /* istanbul ignore next: foolproof (syntax error) */\n    return null;\n}\n\n/**\n * Gets a context for a `return` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `return` statement.\n */\nfunction getReturnContext(state) {\n    var context = state.tryContext;\n\n    while (context) {\n        if (context.hasFinalizer && context.position !== \"finally\") {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Gets a context for a `throw` statement.\n *\n * @param {CodePathState} state - A state to get.\n * @returns {TryContext|CodePathState} A context for a `throw` statement.\n */\nfunction getThrowContext(state) {\n    var context = state.tryContext;\n\n    while (context) {\n        if (context.position === \"try\" ||\n            (context.hasFinalizer && context.position === \"catch\")\n        ) {\n            return context;\n        }\n        context = context.upper;\n    }\n\n    return state;\n}\n\n/**\n * Removes a given element from a given array.\n *\n * @param {any[]} xs - An array to remove the specific element.\n * @param {any} x - An element to be removed.\n * @returns {void}\n */\nfunction remove(xs, x) {\n    xs.splice(xs.indexOf(x), 1);\n}\n\n/**\n * Disconnect given segments.\n *\n * This is used in a process for switch statements.\n * If there is the \"default\" chunk before other cases, the order is different\n * between node's and running's.\n *\n * @param {CodePathSegment[]} prevSegments - Forward segments to disconnect.\n * @param {CodePathSegment[]} nextSegments - Backward segments to disconnect.\n * @returns {void}\n */\nfunction removeConnection(prevSegments, nextSegments) {\n    for (var i = 0; i < prevSegments.length; ++i) {\n        var prevSegment = prevSegments[i];\n        var nextSegment = nextSegments[i];\n\n        remove(prevSegment.nextSegments, nextSegment);\n        remove(prevSegment.allNextSegments, nextSegment);\n        remove(nextSegment.prevSegments, prevSegment);\n        remove(nextSegment.allPrevSegments, prevSegment);\n    }\n}\n\n/**\n * Creates looping path.\n *\n * @param {CodePathState} state - The instance.\n * @param {CodePathSegment[]} fromSegments - Segments which are source.\n * @param {CodePathSegment[]} toSegments - Segments which are destination.\n * @returns {void}\n */\nfunction makeLooped(state, fromSegments, toSegments) {\n    var end = Math.min(fromSegments.length, toSegments.length);\n\n    for (var i = 0; i < end; ++i) {\n        var fromSegment = fromSegments[i];\n        var toSegment = toSegments[i];\n\n        if (toSegment.reachable) {\n            fromSegment.nextSegments.push(toSegment);\n        }\n        if (fromSegment.reachable) {\n            toSegment.prevSegments.push(fromSegment);\n        }\n        fromSegment.allNextSegments.push(toSegment);\n        toSegment.allPrevSegments.push(fromSegment);\n\n        if (toSegment.allPrevSegments.length >= 2) {\n            CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);\n        }\n\n        state.notifyLooped(fromSegment, toSegment);\n    }\n}\n\n/**\n * Finalizes segments of `test` chunk of a ForStatement.\n *\n * - Adds `false` paths to paths which are leaving from the loop.\n * - Sets `true` paths to paths which go to the body.\n *\n * @param {LoopContext} context - A loop context to modify.\n * @param {ChoiceContext} choiceContext - A choice context of this loop.\n * @param {CodePathSegment[]} head - The current head paths.\n * @returns {void}\n */\nfunction finalizeTestSegmentsOfFor(context, choiceContext, head) {\n    if (!choiceContext.processed) {\n        choiceContext.trueForkContext.add(head);\n        choiceContext.falseForkContext.add(head);\n    }\n\n    if (context.test !== true) {\n        context.brokenForkContext.addAll(choiceContext.falseForkContext);\n    }\n    context.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A class which manages state to analyze code paths.\n *\n * @constructor\n * @param {IdGenerator} idGenerator - An id generator to generate id for code\n *   path segments.\n * @param {function} onLooped - A callback function to notify looping.\n */\nfunction CodePathState(idGenerator, onLooped) {\n    this.idGenerator = idGenerator;\n    this.notifyLooped = onLooped;\n    this.forkContext = ForkContext.newRoot(idGenerator);\n    this.choiceContext = null;\n    this.switchContext = null;\n    this.tryContext = null;\n    this.loopContext = null;\n    this.breakContext = null;\n\n    this.currentSegments = [];\n    this.initialSegment = this.forkContext.head[0];\n\n    // returnedSegments and thrownSegments push elements into finalSegments also.\n    var final = this.finalSegments = [];\n    var returned = this.returnedForkContext = [];\n    var thrown = this.thrownForkContext = [];\n\n    returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);\n    thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);\n}\n\nCodePathState.prototype = {\n    constructor: CodePathState,\n\n    /**\n     * The head segments.\n     * @type {CodePathSegment[]}\n     */\n    get headSegments() {\n        return this.forkContext.head;\n    },\n\n    /**\n     * The parent forking context.\n     * This is used for the root of new forks.\n     * @type {ForkContext}\n     */\n    get parentForkContext() {\n        var current = this.forkContext;\n\n        return current && current.upper;\n    },\n\n    /**\n     * Creates and stacks new forking context.\n     *\n     * @param {boolean} forkLeavingPath - A flag which shows being in a\n     *   \"finally\" block.\n     * @returns {ForkContext} The created context.\n     */\n    pushForkContext: function(forkLeavingPath) {\n        this.forkContext = ForkContext.newEmpty(\n            this.forkContext,\n            forkLeavingPath\n        );\n\n        return this.forkContext;\n    },\n\n    /**\n     * Pops and merges the last forking context.\n     * @returns {ForkContext} The last context.\n     */\n    popForkContext: function() {\n        var lastContext = this.forkContext;\n\n        this.forkContext = lastContext.upper;\n        this.forkContext.replaceHead(lastContext.makeNext(0, -1));\n\n        return lastContext;\n    },\n\n    /**\n     * Creates a new path.\n     * @returns {void}\n     */\n    forkPath: function() {\n        this.forkContext.add(this.parentForkContext.makeNext(-1, -1));\n    },\n\n    /**\n     * Creates a bypass path.\n     * This is used for such as IfStatement which does not have \"else\" chunk.\n     *\n     * @returns {void}\n     */\n    forkBypassPath: function() {\n        this.forkContext.add(this.parentForkContext.head);\n    },\n\n    //--------------------------------------------------------------------------\n    // ConditionalExpression, LogicalExpression, IfStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context for ConditionalExpression, LogicalExpression,\n     * IfStatement, WhileStatement, DoWhileStatement, or ForStatement.\n     *\n     * LogicalExpressions have cases that it goes different paths between the\n     * `true` case and the `false` case.\n     *\n     * For Example:\n     *\n     *     if (a || b) {\n     *         foo();\n     *     } else {\n     *         bar();\n     *     }\n     *\n     * In this case, `b` is evaluated always in the code path of the `else`\n     * block, but it's not so in the code path of the `if` block.\n     * So there are 3 paths.\n     *\n     *     a -> foo();\n     *     a -> b -> foo();\n     *     a -> b -> bar();\n     *\n     * @param {string} kind - A kind string.\n     *   If the new context is LogicalExpression's, this is `\"&&\"` or `\"||\"`.\n     *   If it's IfStatement's or ConditionalExpression's, this is `\"test\"`.\n     *   Otherwise, this is `\"loop\"`.\n     * @param {boolean} isForkingAsResult - A flag that shows that goes different\n     *   paths between `true` and `false`.\n     * @returns {void}\n     */\n    pushChoiceContext: function(kind, isForkingAsResult) {\n        this.choiceContext = {\n            upper: this.choiceContext,\n            kind: kind,\n            isForkingAsResult: isForkingAsResult,\n            trueForkContext: ForkContext.newEmpty(this.forkContext),\n            falseForkContext: ForkContext.newEmpty(this.forkContext),\n            processed: false\n        };\n    },\n\n    /**\n     * Pops the last choice context and finalizes it.\n     *\n     * @returns {ChoiceContext} The popped context.\n     */\n    popChoiceContext: function() {\n        var context = this.choiceContext;\n\n        this.choiceContext = context.upper;\n\n        var forkContext = this.forkContext;\n        var headSegments = forkContext.head;\n\n        switch (context.kind) {\n            case \"&&\":\n            case \"||\":\n\n                /*\n                 * If any result were not transferred from child contexts,\n                 * this sets the head segments to both cases.\n                 * The head segments are the path of the right-hand operand.\n                 */\n                if (!context.processed) {\n                    context.trueForkContext.add(headSegments);\n                    context.falseForkContext.add(headSegments);\n                }\n\n                /*\n                 * Transfers results to upper context if this context is in\n                 * test chunk.\n                 */\n                if (context.isForkingAsResult) {\n                    var parentContext = this.choiceContext;\n\n                    parentContext.trueForkContext.addAll(context.trueForkContext);\n                    parentContext.falseForkContext.addAll(context.falseForkContext);\n                    parentContext.processed = true;\n\n                    return context;\n                }\n\n                break;\n\n            case \"test\":\n                if (!context.processed) {\n\n                    /*\n                     * The head segments are the path of the `if` block here.\n                     * Updates the `true` path with the end of the `if` block.\n                     */\n                    context.trueForkContext.clear();\n                    context.trueForkContext.add(headSegments);\n                } else {\n\n                    /*\n                     * The head segments are the path of the `else` block here.\n                     * Updates the `false` path with the end of the `else`\n                     * block.\n                     */\n                    context.falseForkContext.clear();\n                    context.falseForkContext.add(headSegments);\n                }\n\n                break;\n\n            case \"loop\":\n\n                /*\n                 * Loops are addressed in popLoopContext().\n                 * This is called from popLoopContext().\n                 */\n                return context;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Merges all paths.\n        var prevForkContext = context.trueForkContext;\n\n        prevForkContext.addAll(context.falseForkContext);\n        forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n\n        return context;\n    },\n\n    /**\n     * Makes a code path segment of the right-hand operand of a logical\n     * expression.\n     *\n     * @returns {void}\n     */\n    makeLogicalRight: function() {\n        var context = this.choiceContext;\n        var forkContext = this.forkContext;\n\n        if (context.processed) {\n\n            /*\n             * This got segments already from the child choice context.\n             * Creates the next path from own true/false fork context.\n             */\n            var prevForkContext =\n                context.kind === \"&&\" ? context.trueForkContext :\n                /* kind === \"||\" */ context.falseForkContext;\n\n            forkContext.replaceHead(prevForkContext.makeNext(0, -1));\n            prevForkContext.clear();\n\n            context.processed = false;\n        } else {\n\n            /*\n             * This did not get segments from the child choice context.\n             * So addresses the head segments.\n             * The head segments are the path of the left-hand operand.\n             */\n            if (context.kind === \"&&\") {\n\n                // The path does short-circuit if false.\n                context.falseForkContext.add(forkContext.head);\n            } else {\n\n                // The path does short-circuit if true.\n                context.trueForkContext.add(forkContext.head);\n            }\n\n            forkContext.replaceHead(forkContext.makeNext(-1, -1));\n        }\n    },\n\n    /**\n     * Makes a code path segment of the `if` block.\n     *\n     * @returns {void}\n     */\n    makeIfConsequent: function() {\n        var context = this.choiceContext;\n        var forkContext = this.forkContext;\n\n        /*\n         * If any result were not transferred from child contexts,\n         * this sets the head segments to both cases.\n         * The head segments are the path of the test expression.\n         */\n        if (!context.processed) {\n            context.trueForkContext.add(forkContext.head);\n            context.falseForkContext.add(forkContext.head);\n        }\n\n        context.processed = false;\n\n        // Creates new path from the `true` case.\n        forkContext.replaceHead(\n            context.trueForkContext.makeNext(0, -1)\n        );\n    },\n\n    /**\n     * Makes a code path segment of the `else` block.\n     *\n     * @returns {void}\n     */\n    makeIfAlternate: function() {\n        var context = this.choiceContext;\n        var forkContext = this.forkContext;\n\n        /*\n         * The head segments are the path of the `if` block.\n         * Updates the `true` path with the end of the `if` block.\n         */\n        context.trueForkContext.clear();\n        context.trueForkContext.add(forkContext.head);\n        context.processed = true;\n\n        // Creates new path from the `false` case.\n        forkContext.replaceHead(\n            context.falseForkContext.makeNext(0, -1)\n        );\n    },\n\n    //--------------------------------------------------------------------------\n    // SwitchStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of SwitchStatement and stacks it.\n     *\n     * @param {boolean} hasCase - `true` if the switch statement has one or more\n     *   case parts.\n     * @param {string|null} label - The label text.\n     * @returns {void}\n     */\n    pushSwitchContext: function(hasCase, label) {\n        this.switchContext = {\n            upper: this.switchContext,\n            hasCase: hasCase,\n            defaultSegments: null,\n            defaultBodySegments: null,\n            foundDefault: false,\n            lastIsDefault: false,\n            countForks: 0\n        };\n\n        this.pushBreakContext(true, label);\n    },\n\n    /**\n     * Pops the last context of SwitchStatement and finalizes it.\n     *\n     * - Disposes all forking stack for `case` and `default`.\n     * - Creates the next code path segment from `context.brokenForkContext`.\n     * - If the last `SwitchCase` node is not a `default` part, creates a path\n     *   to the `default` body.\n     *\n     * @returns {void}\n     */\n    popSwitchContext: function() {\n        var context = this.switchContext;\n\n        this.switchContext = context.upper;\n\n        var forkContext = this.forkContext;\n        var brokenForkContext = this.popBreakContext().brokenForkContext;\n\n        if (context.countForks === 0) {\n\n            /*\n             * When there is only one `default` chunk and there is one or more\n             * `break` statements, even if forks are nothing, it needs to merge\n             * those.\n             */\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.makeNext(-1, -1));\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n\n            return;\n        }\n\n        var lastSegments = forkContext.head;\n\n        this.forkBypassPath();\n        var lastCaseSegments = forkContext.head;\n\n        /*\n         * `brokenForkContext` is used to make the next segment.\n         * It must add the last segment into `brokenForkContext`.\n         */\n        brokenForkContext.add(lastSegments);\n\n        /*\n         * A path which is failed in all case test should be connected to path\n         * of `default` chunk.\n         */\n        if (!context.lastIsDefault) {\n            if (context.defaultBodySegments) {\n\n                /*\n                 * Remove a link from `default` label to its chunk.\n                 * It's false route.\n                 */\n                removeConnection(context.defaultSegments, context.defaultBodySegments);\n                makeLooped(this, lastCaseSegments, context.defaultBodySegments);\n            } else {\n\n                /*\n                 * It handles the last case body as broken if `default` chunk\n                 * does not exist.\n                 */\n                brokenForkContext.add(lastCaseSegments);\n            }\n        }\n\n        // Pops the segment context stack until the entry segment.\n        for (var i = 0; i < context.countForks; ++i) {\n            this.forkContext = this.forkContext.upper;\n        }\n\n        /*\n         * Creates a path from all brokenForkContext paths.\n         * This is a path after switch statement.\n         */\n        this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n    },\n\n    /**\n     * Makes a code path segment for a `SwitchCase` node.\n     *\n     * @param {boolean} isEmpty - `true` if the body is empty.\n     * @param {boolean} isDefault - `true` if the body is the default case.\n     * @returns {void}\n     */\n    makeSwitchCaseBody: function(isEmpty, isDefault) {\n        var context = this.switchContext;\n\n        if (!context.hasCase) {\n            return;\n        }\n\n        /*\n         * Merge forks.\n         * The parent fork context has two segments.\n         * Those are from the current case and the body of the previous case.\n         */\n        var parentForkContext = this.forkContext;\n        var forkContext = this.pushForkContext();\n\n        forkContext.add(parentForkContext.makeNext(0, -1));\n\n        /*\n         * Save `default` chunk info.\n         * If the `default` label is not at the last, we must make a path from\n         * the last `case` to the `default` chunk.\n         */\n        if (isDefault) {\n            context.defaultSegments = parentForkContext.head;\n            if (isEmpty) {\n                context.foundDefault = true;\n            } else {\n                context.defaultBodySegments = forkContext.head;\n            }\n        } else {\n            if (!isEmpty && context.foundDefault) {\n                context.foundDefault = false;\n                context.defaultBodySegments = forkContext.head;\n            }\n        }\n\n        context.lastIsDefault = isDefault;\n        context.countForks += 1;\n    },\n\n    //--------------------------------------------------------------------------\n    // TryStatement\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of TryStatement and stacks it.\n     *\n     * @param {boolean} hasFinalizer - `true` if the try statement has a\n     *   `finally` block.\n     * @returns {void}\n     */\n    pushTryContext: function(hasFinalizer) {\n        this.tryContext = {\n            upper: this.tryContext,\n            position: \"try\",\n            hasFinalizer: hasFinalizer,\n\n            returnedForkContext: hasFinalizer\n                ? ForkContext.newEmpty(this.forkContext)\n                : null,\n\n            thrownForkContext: ForkContext.newEmpty(this.forkContext),\n            lastOfTryIsReachable: false,\n            lastOfCatchIsReachable: false\n        };\n    },\n\n    /**\n     * Pops the last context of TryStatement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popTryContext: function() {\n        var context = this.tryContext;\n\n        this.tryContext = context.upper;\n\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block merely.\n            this.popForkContext();\n            return;\n        }\n\n        /*\n         * The following process is executed only when there is the `finally`\n         * block.\n         */\n\n        var returned = context.returnedForkContext;\n        var thrown = context.thrownForkContext;\n\n        if (returned.empty && thrown.empty) {\n            return;\n        }\n\n        // Separate head to normal paths and leaving paths.\n        var headSegments = this.forkContext.head;\n\n        this.forkContext = this.forkContext.upper;\n        var normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);\n        var leavingSegments = headSegments.slice(headSegments.length / 2 | 0);\n\n        // Forwards the leaving path to upper contexts.\n        if (!returned.empty) {\n            getReturnContext(this).returnedForkContext.add(leavingSegments);\n        }\n        if (!thrown.empty) {\n            getThrowContext(this).thrownForkContext.add(leavingSegments);\n        }\n\n        // Sets the normal path as the next.\n        this.forkContext.replaceHead(normalSegments);\n\n        // If both paths of the `try` block and the `catch` block are\n        // unreachable, the next path becomes unreachable as well.\n        if (!context.lastOfTryIsReachable && !context.lastOfCatchIsReachable) {\n            this.forkContext.makeUnreachable();\n        }\n    },\n\n    /**\n     * Makes a code path segment for a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeCatchBlock: function() {\n        var context = this.tryContext;\n        var forkContext = this.forkContext;\n        var thrown = context.thrownForkContext;\n\n        // Update state.\n        context.position = \"catch\";\n        context.thrownForkContext = ForkContext.newEmpty(forkContext);\n        context.lastOfTryIsReachable = forkContext.reachable;\n\n        // Merge thrown paths.\n        thrown.add(forkContext.head);\n        var thrownSegments = thrown.makeNext(0, -1);\n\n        // Fork to a bypass and the merged thrown path.\n        this.pushForkContext();\n        this.forkBypassPath();\n        this.forkContext.add(thrownSegments);\n    },\n\n    /**\n     * Makes a code path segment for a `finally` block.\n     *\n     * In the `finally` block, parallel paths are created. The parallel paths\n     * are used as leaving-paths. The leaving-paths are paths from `return`\n     * statements and `throw` statements in a `try` block or a `catch` block.\n     *\n     * @returns {void}\n     */\n    makeFinallyBlock: function() {\n        var context = this.tryContext;\n        var forkContext = this.forkContext;\n        var returned = context.returnedForkContext;\n        var thrown = context.thrownForkContext;\n        var headOfLeavingSegments = forkContext.head;\n\n        // Update state.\n        if (context.position === \"catch\") {\n\n            // Merges two paths from the `try` block and `catch` block.\n            this.popForkContext();\n            forkContext = this.forkContext;\n\n            context.lastOfCatchIsReachable = forkContext.reachable;\n        } else {\n            context.lastOfTryIsReachable = forkContext.reachable;\n        }\n        context.position = \"finally\";\n\n        if (returned.empty && thrown.empty) {\n\n            // This path does not leave.\n            return;\n        }\n\n        /*\n         * Create a parallel segment from merging returned and thrown.\n         * This segment will leave at the end of this finally block.\n         */\n        var segments = forkContext.makeNext(-1, -1);\n        var j;\n\n        for (var i = 0; i < forkContext.count; ++i) {\n            var prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];\n\n            for (j = 0; j < returned.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);\n            }\n            for (j = 0; j < thrown.segmentsList.length; ++j) {\n                prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);\n            }\n\n            segments.push(CodePathSegment.newNext(\n                this.idGenerator.next(),\n                prevSegsOfLeavingSegment));\n        }\n\n        this.pushForkContext(true);\n        this.forkContext.add(segments);\n    },\n\n    /**\n     * Makes a code path segment from the first throwable node to the `catch`\n     * block or the `finally` block.\n     *\n     * @returns {void}\n     */\n    makeFirstThrowablePathInTryBlock: function() {\n        var forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        var context = getThrowContext(this);\n\n        if (context === this ||\n            context.position !== \"try\" ||\n            !context.thrownForkContext.empty\n        ) {\n            return;\n        }\n\n        context.thrownForkContext.add(forkContext.head);\n        forkContext.replaceHead(forkContext.makeNext(-1, -1));\n    },\n\n    //--------------------------------------------------------------------------\n    // Loop Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates a context object of a loop statement and stacks it.\n     *\n     * @param {string} type - The type of the node which was triggered. One of\n     *   `WhileStatement`, `DoWhileStatement`, `ForStatement`, `ForInStatement`,\n     *   and `ForStatement`.\n     * @param {string|null} label - A label of the node which was triggered.\n     * @returns {void}\n     */\n    pushLoopContext: function(type, label) {\n        var forkContext = this.forkContext;\n        var breakContext = this.pushBreakContext(true, label);\n\n        switch (type) {\n            case \"WhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type: type,\n                    label: label,\n                    test: void 0,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"DoWhileStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type: type,\n                    label: label,\n                    test: void 0,\n                    entrySegments: null,\n                    continueForkContext: ForkContext.newEmpty(forkContext),\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForStatement\":\n                this.pushChoiceContext(\"loop\", false);\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type: type,\n                    label: label,\n                    test: void 0,\n                    endOfInitSegments: null,\n                    testSegments: null,\n                    endOfTestSegments: null,\n                    updateSegments: null,\n                    endOfUpdateSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                this.loopContext = {\n                    upper: this.loopContext,\n                    type: type,\n                    label: label,\n                    prevSegments: null,\n                    leftSegments: null,\n                    endOfLeftSegments: null,\n                    continueDestSegments: null,\n                    brokenForkContext: breakContext.brokenForkContext\n                };\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unknown type: \\\"\" + type + \"\\\"\");\n        }\n    },\n\n    /**\n     * Pops the last context of a loop statement and finalizes it.\n     *\n     * @returns {void}\n     */\n    popLoopContext: function() {\n        var context = this.loopContext;\n\n        this.loopContext = context.upper;\n\n        var forkContext = this.forkContext;\n        var brokenForkContext = this.popBreakContext().brokenForkContext;\n        var choiceContext;\n\n        // Creates a looped path.\n        switch (context.type) {\n            case \"WhileStatement\":\n            case \"ForStatement\":\n                choiceContext = this.popChoiceContext();\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.continueDestSegments);\n                break;\n\n            case \"DoWhileStatement\":\n                choiceContext = this.popChoiceContext();\n\n                if (!choiceContext.processed) {\n                    choiceContext.trueForkContext.add(forkContext.head);\n                    choiceContext.falseForkContext.add(forkContext.head);\n                }\n                if (context.test !== true) {\n                    brokenForkContext.addAll(choiceContext.falseForkContext);\n                }\n\n                // `true` paths go to looping.\n                var segmentsList = choiceContext.trueForkContext.segmentsList;\n\n                for (var i = 0; i < segmentsList.length; ++i) {\n                    makeLooped(\n                        this,\n                        segmentsList[i],\n                        context.entrySegments);\n                }\n                break;\n\n            case \"ForInStatement\":\n            case \"ForOfStatement\":\n                brokenForkContext.add(forkContext.head);\n                makeLooped(\n                    this,\n                    forkContext.head,\n                    context.leftSegments);\n                break;\n\n            /* istanbul ignore next */\n            default:\n                throw new Error(\"unreachable\");\n        }\n\n        // Go next.\n        if (brokenForkContext.empty) {\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        } else {\n            forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n        }\n    },\n\n    /**\n     * Makes a code path segment for the test part of a WhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeWhileTest: function(test) {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n        var testSegments = forkContext.makeNext(0, -1);\n\n        // Update state.\n        context.test = test;\n        context.continueDestSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    },\n\n    /**\n     * Makes a code path segment for the body part of a WhileStatement.\n     *\n     * @returns {void}\n     */\n    makeWhileBody: function() {\n        var context = this.loopContext;\n        var choiceContext = this.choiceContext;\n        var forkContext = this.forkContext;\n\n        if (!choiceContext.processed) {\n            choiceContext.trueForkContext.add(forkContext.head);\n            choiceContext.falseForkContext.add(forkContext.head);\n        }\n\n        // Update state.\n        if (context.test !== true) {\n            context.brokenForkContext.addAll(choiceContext.falseForkContext);\n        }\n        forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));\n    },\n\n    /**\n     * Makes a code path segment for the body part of a DoWhileStatement.\n     *\n     * @returns {void}\n     */\n    makeDoWhileBody: function() {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n        var bodySegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.entrySegments = bodySegments;\n        forkContext.replaceHead(bodySegments);\n    },\n\n    /**\n     * Makes a code path segment for the test part of a DoWhileStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeDoWhileTest: function(test) {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n\n        context.test = test;\n\n        // Creates paths of `continue` statements.\n        if (!context.continueForkContext.empty) {\n            context.continueForkContext.add(forkContext.head);\n            var testSegments = context.continueForkContext.makeNext(0, -1);\n\n            forkContext.replaceHead(testSegments);\n        }\n    },\n\n    /**\n     * Makes a code path segment for the test part of a ForStatement.\n     *\n     * @param {boolean|undefined} test - The test value (only when constant).\n     * @returns {void}\n     */\n    makeForTest: function(test) {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n        var endOfInitSegments = forkContext.head;\n        var testSegments = forkContext.makeNext(-1, -1);\n\n        // Update state.\n        context.test = test;\n        context.endOfInitSegments = endOfInitSegments;\n        context.continueDestSegments = context.testSegments = testSegments;\n        forkContext.replaceHead(testSegments);\n    },\n\n    /**\n     * Makes a code path segment for the update part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForUpdate: function() {\n        var context = this.loopContext;\n        var choiceContext = this.choiceContext;\n        var forkContext = this.forkContext;\n\n        // Make the next paths of the test.\n        if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head);\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        // Update state.\n        var updateSegments = forkContext.makeDisconnected(-1, -1);\n\n        context.continueDestSegments = context.updateSegments = updateSegments;\n        forkContext.replaceHead(updateSegments);\n    },\n\n    /**\n     * Makes a code path segment for the body part of a ForStatement.\n     *\n     * @returns {void}\n     */\n    makeForBody: function() {\n        var context = this.loopContext;\n        var choiceContext = this.choiceContext;\n        var forkContext = this.forkContext;\n\n        // Update state.\n        if (context.updateSegments) {\n            context.endOfUpdateSegments = forkContext.head;\n\n            // `update` -> `test`\n            if (context.testSegments) {\n                makeLooped(\n                    this,\n                    context.endOfUpdateSegments,\n                    context.testSegments);\n            }\n        } else if (context.testSegments) {\n            finalizeTestSegmentsOfFor(\n                context,\n                choiceContext,\n                forkContext.head);\n        } else {\n            context.endOfInitSegments = forkContext.head;\n        }\n\n        var bodySegments = context.endOfTestSegments;\n\n        if (!bodySegments) {\n\n            /*\n             * If there is not the `test` part, the `body` path comes from the\n             * `init` part and the `update` part.\n             */\n            var prevForkContext = ForkContext.newEmpty(forkContext);\n\n            prevForkContext.add(context.endOfInitSegments);\n            if (context.endOfUpdateSegments) {\n                prevForkContext.add(context.endOfUpdateSegments);\n            }\n\n            bodySegments = prevForkContext.makeNext(0, -1);\n        }\n        context.continueDestSegments = context.continueDestSegments || bodySegments;\n        forkContext.replaceHead(bodySegments);\n    },\n\n    /**\n     * Makes a code path segment for the left part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfLeft: function() {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n        var leftSegments = forkContext.makeDisconnected(-1, -1);\n\n        // Update state.\n        context.prevSegments = forkContext.head;\n        context.leftSegments = context.continueDestSegments = leftSegments;\n        forkContext.replaceHead(leftSegments);\n    },\n\n    /**\n     * Makes a code path segment for the right part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfRight: function() {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n        var temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.prevSegments);\n        var rightSegments = temp.makeNext(-1, -1);\n\n        // Update state.\n        context.endOfLeftSegments = forkContext.head;\n        forkContext.replaceHead(rightSegments);\n    },\n\n    /**\n     * Makes a code path segment for the body part of a ForInStatement and a\n     * ForOfStatement.\n     *\n     * @returns {void}\n     */\n    makeForInOfBody: function() {\n        var context = this.loopContext;\n        var forkContext = this.forkContext;\n        var temp = ForkContext.newEmpty(forkContext);\n\n        temp.add(context.endOfLeftSegments);\n        var bodySegments = temp.makeNext(-1, -1);\n\n        // Make a path: `right` -> `left`.\n        makeLooped(this, forkContext.head, context.leftSegments);\n\n        // Update state.\n        context.brokenForkContext.add(forkContext.head);\n        forkContext.replaceHead(bodySegments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Control Statements\n    //--------------------------------------------------------------------------\n\n    /**\n     * Creates new context for BreakStatement.\n     *\n     * @param {boolean} breakable - The flag to indicate it can break by\n     *      an unlabeled BreakStatement.\n     * @param {string|null} label - The label of this context.\n     * @returns {object} The new context.\n     */\n    pushBreakContext: function(breakable, label) {\n        this.breakContext = {\n            upper: this.breakContext,\n            breakable: breakable,\n            label: label,\n            brokenForkContext: ForkContext.newEmpty(this.forkContext)\n        };\n        return this.breakContext;\n    },\n\n    /**\n     * Removes the top item of the break context stack.\n     *\n     * @returns {object} The removed context.\n     */\n    popBreakContext: function() {\n        var context = this.breakContext;\n        var forkContext = this.forkContext;\n\n        this.breakContext = context.upper;\n\n        // Process this context here for other than switches and loops.\n        if (!context.breakable) {\n            var brokenForkContext = context.brokenForkContext;\n\n            if (!brokenForkContext.empty) {\n                brokenForkContext.add(forkContext.head);\n                forkContext.replaceHead(brokenForkContext.makeNext(0, -1));\n            }\n        }\n\n        return context;\n    },\n\n    /**\n     * Makes a path for a `break` statement.\n     *\n     * It registers the head segment to a context of `break`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the break statement.\n     * @returns {void}\n     */\n    makeBreak: function(label) {\n        var forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        var context = getBreakContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            context.brokenForkContext.add(forkContext.head);\n        }\n\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    },\n\n    /**\n     * Makes a path for a `continue` statement.\n     *\n     * It makes a looping path.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @param {string} label - A label of the continue statement.\n     * @returns {void}\n     */\n    makeContinue: function(label) {\n        var forkContext = this.forkContext;\n\n        if (!forkContext.reachable) {\n            return;\n        }\n\n        var context = getContinueContext(this, label);\n\n        /* istanbul ignore else: foolproof (syntax error) */\n        if (context) {\n            if (context.continueDestSegments) {\n                makeLooped(this, forkContext.head, context.continueDestSegments);\n\n                // If the context is a for-in/of loop, this effects a break also.\n                if (context.type === \"ForInStatement\" ||\n                    context.type === \"ForOfStatement\"\n                ) {\n                    context.brokenForkContext.add(forkContext.head);\n                }\n            } else {\n                context.continueForkContext.add(forkContext.head);\n            }\n        }\n        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n    },\n\n    /**\n     * Makes a path for a `return` statement.\n     *\n     * It registers the head segment to a context of `return`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeReturn: function() {\n        var forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getReturnContext(this).returnedForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    },\n\n    /**\n     * Makes a path for a `throw` statement.\n     *\n     * It registers the head segment to a context of `throw`.\n     * It makes new unreachable segment, then it set the head with the segment.\n     *\n     * @returns {void}\n     */\n    makeThrow: function() {\n        var forkContext = this.forkContext;\n\n        if (forkContext.reachable) {\n            getThrowContext(this).thrownForkContext.add(forkContext.head);\n            forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));\n        }\n    },\n\n    /**\n     * Makes the final path.\n     * @returns {void}\n     */\n    makeFinal: function() {\n        var segments = this.currentSegments;\n\n        if (segments.length > 0 && segments[0].reachable) {\n            this.returnedForkContext.add(segments);\n        }\n    }\n};\n\nmodule.exports = CodePathState;\n"]}