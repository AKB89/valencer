{"version":3,"sources":["code-path.js"],"names":[],"mappings":"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","file":"code-path-compiled.js","sourcesContent":["/**\n * @fileoverview A class of the code path.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar CodePathState = require(\"./code-path-state\");\nvar IdGenerator = require(\"./id-generator\");\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * A code path.\n *\n * @constructor\n * @param {string} id - An identifier.\n * @param {CodePath|null} upper - The code path of the upper function scope.\n * @param {function} onLooped - A callback function to notify looping.\n */\nfunction CodePath(id, upper, onLooped) {\n\n    /**\n     * The identifier of this code path.\n     * Rules use it to store additional information of each rule.\n     * @type {string}\n     */\n    this.id = id;\n\n    /**\n     * The code path of the upper function scope.\n     * @type {CodePath|null}\n     */\n    this.upper = upper;\n\n    /**\n     * The code paths of nested function scopes.\n     * @type {CodePath[]}\n     */\n    this.childCodePaths = [];\n\n    // Initializes internal state.\n    Object.defineProperty(\n        this,\n        \"internal\",\n        {value: new CodePathState(new IdGenerator(id + \"_\"), onLooped)});\n\n    // Adds this into `childCodePaths` of `upper`.\n    if (upper) {\n        upper.childCodePaths.push(this);\n    }\n}\n\nCodePath.prototype = {\n    constructor: CodePath,\n\n    /**\n     * The initial code path segment.\n     * @type {CodePathSegment}\n     */\n    get initialSegment() {\n        return this.internal.initialSegment;\n    },\n\n    /**\n     * Final code path segments.\n     * This array is a mix of `returnedSegments` and `thrownSegments`.\n     * @type {CodePathSegment[]}\n     */\n    get finalSegments() {\n        return this.internal.finalSegments;\n    },\n\n    /**\n     * Final code path segments which is with `return` statements.\n     * This array contains the last path segment if it's reachable.\n     * Since the reachable last path returns `undefined`.\n     * @type {CodePathSegment[]}\n     */\n    get returnedSegments() {\n        return this.internal.returnedForkContext;\n    },\n\n    /**\n     * Final code path segments which is with `throw` statements.\n     * @type {CodePathSegment[]}\n     */\n    get thrownSegments() {\n        return this.internal.thrownForkContext;\n    },\n\n    /**\n     * Current code path segments.\n     * @type {CodePathSegment[]}\n     */\n    get currentSegments() {\n        return this.internal.currentSegments;\n    },\n\n    /**\n     * Traverses all segments in this code path.\n     *\n     *     codePath.traverseSegments(function(segment, controller) {\n     *         // do something.\n     *     });\n     *\n     * This method enumerates segments in order from the head.\n     *\n     * The `controller` object has two methods.\n     *\n     * - `controller.skip()` - Skip the following segments in this branch.\n     * - `controller.break()` - Skip all following segments.\n     *\n     * @param {object} [options] - Omittable.\n     * @param {CodePathSegment} [options.first] - The first segment to traverse.\n     * @param {CodePathSegment} [options.last] - The last segment to traverse.\n     * @param {function} callback - A callback function.\n     * @returns {void}\n     */\n    traverseSegments: function(options, callback) {\n        if (typeof options === \"function\") {\n            callback = options;\n            options = null;\n        }\n\n        options = options || {};\n        var startSegment = options.first || this.internal.initialSegment;\n        var lastSegment = options.last;\n\n        var item = null;\n        var index = 0;\n        var end = 0;\n        var segment = null;\n        var visited = Object.create(null);\n        var stack = [[startSegment, 0]];\n        var skippedSegment = null;\n        var broken = false;\n        var controller = {\n            skip: function() {\n                if (stack.length <= 1) {\n                    broken = true;\n                } else {\n                    skippedSegment = stack[stack.length - 2][0];\n                }\n            },\n            break: function() {\n                broken = true;\n            }\n        };\n\n        /**\n         * Checks a given previous segment has been visited.\n         * @param {CodePathSegment} prevSegment - A previous segment to check.\n         * @returns {boolean} `true` if the segment has been visited.\n         */\n        function isVisited(prevSegment) {\n            return (\n                visited[prevSegment.id] ||\n                segment.isLoopedPrevSegment(prevSegment)\n            );\n        }\n\n        while (stack.length > 0) {\n            item = stack[stack.length - 1];\n            segment = item[0];\n            index = item[1];\n\n            if (index === 0) {\n\n                // Skip if this segment has been visited already.\n                if (visited[segment.id]) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Skip if all previous segments have not been visited.\n                if (segment !== startSegment &&\n                    segment.prevSegments.length > 0 &&\n                    !segment.prevSegments.every(isVisited)\n                ) {\n                    stack.pop();\n                    continue;\n                }\n\n                // Reset the flag of skipping if all branches have been skipped.\n                if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {\n                    skippedSegment = null;\n                }\n                visited[segment.id] = true;\n\n                // Call the callback when the first time.\n                if (!skippedSegment) {\n                    callback.call(this, segment, controller); // eslint-disable-line callback-return\n                    if (segment === lastSegment) {\n                        controller.skip();\n                    }\n                    if (broken) {\n                        break;\n                    }\n                }\n            }\n\n            // Update the stack.\n            end = segment.nextSegments.length - 1;\n            if (index < end) {\n                item[1] += 1;\n                stack.push([segment.nextSegments[index], 0]);\n            } else if (index === end) {\n                item[0] = segment.nextSegments[index];\n                item[1] = 0;\n            } else {\n                stack.pop();\n            }\n        }\n    }\n};\n\n/**\n * Gets the state of a given code path.\n *\n * @param {CodePath} codePath - A code path to get.\n * @returns {CodePathState} The state of the code path.\n */\nCodePath.getState = function getState(codePath) {\n    return codePath.internal;\n};\n\nmodule.exports = CodePath;\n"]}