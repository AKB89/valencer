{"version":3,"sources":["key-spacing.js"],"names":[],"mappings":"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","file":"key-spacing-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to specify spacing of object literal keys and values\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a string contains a line terminator as defined in\n * http://www.ecma-international.org/ecma-262/5.1/#sec-7.3\n * @param {string} str String to test.\n * @returns {boolean} True if str contains a line terminator.\n */\nfunction containsLineTerminator(str) {\n    return /[\\n\\r\\u2028\\u2029]/.test(str);\n}\n\n/**\n * Gets the last element of an array.\n * @param {Array} arr An array.\n * @returns {any} Last element of arr.\n */\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\n/**\n * Checks whether a property is a member of the property group it follows.\n * @param {ASTNode} lastMember The last Property known to be in the group.\n * @param {ASTNode} candidate The next Property that might be in the group.\n * @returns {boolean} True if the candidate property is part of the group.\n */\nfunction continuesPropertyGroup(lastMember, candidate) {\n    var groupEndLine = lastMember.loc.start.line,\n        candidateStartLine = candidate.loc.start.line,\n        comments, i;\n\n    if (candidateStartLine - groupEndLine <= 1) {\n        return true;\n    }\n\n    // Check that the first comment is adjacent to the end of the group, the\n    // last comment is adjacent to the candidate property, and that successive\n    // comments are adjacent to each other.\n    comments = candidate.leadingComments;\n    if (\n        comments &&\n        comments[0].loc.start.line - groupEndLine <= 1 &&\n        candidateStartLine - last(comments).loc.end.line <= 1\n    ) {\n        for (i = 1; i < comments.length; i++) {\n            if (comments[i].loc.start.line - comments[i - 1].loc.end.line > 1) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Checks whether a node is contained on a single line.\n * @param {ASTNode} node AST Node being evaluated.\n * @returns {boolean} True if the node is a single line.\n */\nfunction isSingleLine(node) {\n    return (node.loc.end.line === node.loc.start.line);\n}\n\n/** Sets option values from the configured options with defaults\n * @param {Object} toOptions Object to be initialized\n * @param {Object} fromOptions Object to be initialized from\n * @returns {Object} The object with correctly initialized options and values\n */\nfunction initOptions(toOptions, fromOptions) {\n    toOptions.mode = fromOptions.mode || \"strict\";\n\n    // Set align if exists -  multiLine case\n    if (typeof fromOptions.align !== \"undefined\") {\n        toOptions.align = fromOptions.align;\n    }\n\n    // Set value of beforeColon\n    if (typeof fromOptions.beforeColon !== \"undefined\") {\n        toOptions.beforeColon = +fromOptions.beforeColon;\n    } else {\n        toOptions.beforeColon = 0;\n    }\n\n    // Set value of afterColon\n    if (typeof fromOptions.afterColon !== \"undefined\") {\n        toOptions.afterColon = +fromOptions.afterColon;\n    } else {\n        toOptions.afterColon = 1;\n    }\n\n    return toOptions;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nvar messages = {\n    key: \"{{error}} space after {{computed}}key '{{key}}'.\",\n    value: \"{{error}} space before value for {{computed}}key '{{key}}'.\"\n};\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing between keys and values in object literal properties\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [{\n            anyOf: [\n                {\n                    type: \"object\",\n                    properties: {\n                        align: {\n                            enum: [\"colon\", \"value\"]\n                        },\n                        mode: {\n                            enum: [\"strict\", \"minimum\"]\n                        },\n                        beforeColon: {\n                            type: \"boolean\"\n                        },\n                        afterColon: {\n                            type: \"boolean\"\n                        }\n                    },\n                    additionalProperties: false\n                },\n                {\n                    type: \"object\",\n                    properties: {\n                        singleLine: {\n                            type: \"object\",\n                            properties: {\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        },\n                        multiLine: {\n                            type: \"object\",\n                            properties: {\n                                align: {\n                                    enum: [\"colon\", \"value\"]\n                                },\n                                mode: {\n                                    enum: [\"strict\", \"minimum\"]\n                                },\n                                beforeColon: {\n                                    type: \"boolean\"\n                                },\n                                afterColon: {\n                                    type: \"boolean\"\n                                }\n                            },\n                            additionalProperties: false\n                        }\n                    },\n                    additionalProperties: false\n                }\n            ]\n        }]\n    },\n\n    create: function(context) {\n\n        /**\n         * OPTIONS\n         * \"key-spacing\": [2, {\n         *     beforeColon: false,\n         *     afterColon: true,\n         *     align: \"colon\" // Optional, or \"value\"\n         * }\n         */\n\n        var options = context.options[0] || {},\n            multiLineOptions = initOptions({}, (options.multiLine || options)),\n            singleLineOptions = initOptions({}, (options.singleLine || options));\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Determines if the given property is key-value property.\n         * @param {ASTNode} property Property node to check.\n         * @returns {Boolean} Whether the property is a key-value property.\n         */\n        function isKeyValueProperty(property) {\n            return !(\n                (property.method ||\n                property.shorthand ||\n                property.kind !== \"init\" || property.type !== \"Property\") // Could be \"ExperimentalSpreadProperty\" or \"SpreadProperty\"\n            );\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the last token before a colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The last token before a colon punctuator.\n         */\n        function getLastTokenBeforeColon(node) {\n            var prevNode;\n\n            while (node && (node.type !== \"Punctuator\" || node.value !== \":\")) {\n                prevNode = node;\n                node = sourceCode.getTokenAfter(node);\n            }\n\n            return prevNode;\n        }\n\n        /**\n         * Starting from the given a node (a property.key node here) looks forward\n         * until it finds the colon punctuator and returns it.\n         * @param {ASTNode} node The node to start looking from.\n         * @returns {ASTNode} The colon punctuator.\n         */\n        function getNextColon(node) {\n\n            while (node && (node.type !== \"Punctuator\" || node.value !== \":\")) {\n                node = sourceCode.getTokenAfter(node);\n            }\n\n            return node;\n        }\n\n        /**\n         * Gets an object literal property's key as the identifier name or string value.\n         * @param {ASTNode} property Property node whose key to retrieve.\n         * @returns {string} The property's key.\n         */\n        function getKey(property) {\n            var key = property.key;\n\n            if (property.computed) {\n                return sourceCode.getText().slice(key.range[0], key.range[1]);\n            }\n\n            return property.key.name || property.key.value;\n        }\n\n        /**\n         * Reports an appropriately-formatted error if spacing is incorrect on one\n         * side of the colon.\n         * @param {ASTNode} property Key-value pair in an object literal.\n         * @param {string} side Side being verified - either \"key\" or \"value\".\n         * @param {string} whitespace Actual whitespace string.\n         * @param {int} expected Expected whitespace length.\n         * @param {string} mode Value of the mode as \"strict\" or \"minimum\"\n         * @returns {void}\n         */\n        function report(property, side, whitespace, expected, mode) {\n            var diff = whitespace.length - expected,\n                nextColon = getNextColon(property.key),\n                tokenBeforeColon = sourceCode.getTokenBefore(nextColon),\n                tokenAfterColon = sourceCode.getTokenAfter(nextColon),\n                isKeySide = side === \"key\",\n                locStart = isKeySide ? tokenBeforeColon.loc.start : tokenAfterColon.loc.start,\n                isExtra = diff > 0,\n                diffAbs = Math.abs(diff),\n                spaces = Array(diffAbs + 1).join(\" \"),\n                fix,\n                range;\n\n            if ((\n                diff && mode === \"strict\" ||\n                diff < 0 && mode === \"minimum\" ||\n                diff > 0 && !expected && mode === \"minimum\") &&\n                !(expected && containsLineTerminator(whitespace))\n            ) {\n                if (isExtra) {\n\n                    // Remove whitespace\n                    if (isKeySide) {\n                        range = [tokenBeforeColon.end, tokenBeforeColon.end + diffAbs];\n                    } else {\n                        range = [tokenAfterColon.start - diffAbs, tokenAfterColon.start];\n                    }\n                    fix = function(fixer) {\n                        return fixer.removeRange(range);\n                    };\n                } else {\n\n                    // Add whitespace\n                    if (isKeySide) {\n                        fix = function(fixer) {\n                            return fixer.insertTextAfter(tokenBeforeColon, spaces);\n                        };\n                    } else {\n                        fix = function(fixer) {\n                            return fixer.insertTextBefore(tokenAfterColon, spaces);\n                        };\n                    }\n                }\n\n                context.report({\n                    node: property[side],\n                    loc: locStart,\n                    message: messages[side],\n                    data: {\n                        error: isExtra ? \"Extra\" : \"Missing\",\n                        computed: property.computed ? \"computed \" : \"\",\n                        key: getKey(property)\n                    },\n                    fix: fix\n                });\n            }\n        }\n\n        /**\n         * Gets the number of characters in a key, including quotes around string\n         * keys and braces around computed property keys.\n         * @param {ASTNode} property Property of on object literal.\n         * @returns {int} Width of the key.\n         */\n        function getKeyWidth(property) {\n            var startToken, endToken;\n\n            startToken = sourceCode.getFirstToken(property);\n            endToken = getLastTokenBeforeColon(property.key);\n\n            return endToken.range[1] - startToken.range[0];\n        }\n\n        /**\n         * Gets the whitespace around the colon in an object literal property.\n         * @param {ASTNode} property Property node from an object literal.\n         * @returns {Object} Whitespace before and after the property's colon.\n         */\n        function getPropertyWhitespace(property) {\n            var whitespace = /(\\s*):(\\s*)/.exec(sourceCode.getText().slice(\n                property.key.range[1], property.value.range[0]\n            ));\n\n            if (whitespace) {\n                return {\n                    beforeColon: whitespace[1],\n                    afterColon: whitespace[2]\n                };\n            }\n            return null;\n        }\n\n        /**\n         * Creates groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {Array.<ASTNode[]>} Groups of property AST node lists.\n         */\n        function createGroups(node) {\n            if (node.properties.length === 1) {\n                return [node.properties];\n            }\n\n            return node.properties.reduce(function(groups, property) {\n                var currentGroup = last(groups),\n                    prev = last(currentGroup);\n\n                if (!prev || continuesPropertyGroup(prev, property)) {\n                    currentGroup.push(property);\n                } else {\n                    groups.push([property]);\n                }\n\n                return groups;\n            }, [\n                []\n            ]);\n        }\n\n        /**\n         * Verifies correct vertical alignment of a group of properties.\n         * @param {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyGroupAlignment(properties) {\n            var length = properties.length,\n                widths = properties.map(getKeyWidth), // Width of keys, including quotes\n                targetWidth = Math.max.apply(null, widths),\n                i, property, whitespace, width,\n                align = multiLineOptions.align,\n                beforeColon = multiLineOptions.beforeColon,\n                afterColon = multiLineOptions.afterColon,\n                mode = multiLineOptions.mode;\n\n            // Conditionally include one space before or after colon\n            targetWidth += (align === \"colon\" ? beforeColon : afterColon);\n\n            for (i = 0; i < length; i++) {\n                property = properties[i];\n                whitespace = getPropertyWhitespace(property);\n                if (whitespace) { // Object literal getters/setters lack a colon\n                    width = widths[i];\n\n                    if (align === \"value\") {\n                        report(property, \"key\", whitespace.beforeColon, beforeColon, mode);\n                        report(property, \"value\", whitespace.afterColon, targetWidth - width, mode);\n                    } else { // align = \"colon\"\n                        report(property, \"key\", whitespace.beforeColon, targetWidth - width, mode);\n                        report(property, \"value\", whitespace.afterColon, afterColon, mode);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Verifies vertical alignment, taking into account groups of properties.\n         * @param  {ASTNode} node ObjectExpression node being evaluated.\n         * @returns {void}\n         */\n        function verifyAlignment(node) {\n            createGroups(node).forEach(function(group) {\n                verifyGroupAlignment(group.filter(isKeyValueProperty));\n            });\n        }\n\n        /**\n         * Verifies spacing of property conforms to specified options.\n         * @param  {ASTNode} node Property node being evaluated.\n         * @param {Object} lineOptions Configured singleLine or multiLine options\n         * @returns {void}\n         */\n        function verifySpacing(node, lineOptions) {\n            var actual = getPropertyWhitespace(node);\n\n            if (actual) { // Object literal getters/setters lack colons\n                report(node, \"key\", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);\n                report(node, \"value\", actual.afterColon, lineOptions.afterColon, lineOptions.mode);\n            }\n        }\n\n        /**\n         * Verifies spacing of each property in a list.\n         * @param  {ASTNode[]} properties List of Property AST nodes.\n         * @returns {void}\n         */\n        function verifyListSpacing(properties) {\n            var length = properties.length;\n\n            for (var i = 0; i < length; i++) {\n                verifySpacing(properties[i], singleLineOptions);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        if (multiLineOptions.align) { // Verify vertical alignment\n\n            return {\n                ObjectExpression: function(node) {\n                    if (isSingleLine(node)) {\n                        verifyListSpacing(node.properties.filter(isKeyValueProperty));\n                    } else {\n                        verifyAlignment(node);\n                    }\n                }\n            };\n\n        } else { // Obey beforeColon and afterColon in each property as configured\n\n            return {\n                Property: function(node) {\n                    verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);\n                }\n            };\n\n        }\n\n    }\n};\n"]}