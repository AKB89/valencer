{"version":3,"sources":["operator-assignment.js"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;;;AAaA,SAAS,kCAAT,CAA4C,QAA5C,EAAsD;AAClD,WAAO,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,OAArB,CAA6B,QAA7B,KAA0C,CAAjD;AACH;;;;;;;;;AASD,SAAS,qCAAT,CAA+C,QAA/C,EAAyD;AACrD,WAAO,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,EAAgB,GAAhB,EAAqB,IAArB,EAA2B,IAA3B,EAAiC,KAAjC,EAAwC,OAAxC,CAAgD,QAAhD,KAA6D,CAApE;AACH;;;;;;;;;;;;;;;;AAgBD,SAAS,IAAT,CAAc,CAAd,EAAiB,CAAjB,EAAoB;AAChB,QAAI,EAAE,IAAF,KAAW,EAAE,IAAjB,EAAuB;AACnB,eAAO,KAAP;AACH;;AAED,YAAQ,EAAE,IAAV;AACI,aAAK,YAAL;AACI,mBAAO,EAAE,IAAF,KAAW,EAAE,IAApB;;AAEJ,aAAK,SAAL;AACI,mBAAO,EAAE,KAAF,KAAY,EAAE,KAArB;;AAEJ,aAAK,kBAAL;;;;;;;AAOI,mBAAO,KAAK,EAAE,MAAP,EAAe,EAAE,MAAjB,KAA4B,KAAK,EAAE,QAAP,EAAiB,EAAE,QAAnB,CAAnC;;AAEJ;AACI,mBAAO,KAAP;AAjBR;AAmBH;;AAED,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,kEADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,CAAC,QAAD,EAAW,OAAX;AADV,SADI;AAPN,KADO;;AAeb,YAAQ,gBAAS,OAAT,EAAkB;;;;;;;AAOtB,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,gBAAI,IAAJ,EAAU,IAAV,EAAgB,QAAhB;;AAEA,gBAAI,KAAK,QAAL,KAAkB,GAAlB,IAAyB,KAAK,KAAL,CAAW,IAAX,KAAoB,kBAAjD,EAAqE;AACjE;AACH;;AAED,mBAAO,KAAK,IAAZ;AACA,mBAAO,KAAK,KAAZ;AACA,uBAAW,KAAK,QAAhB;;AAEA,gBAAI,mCAAmC,QAAnC,CAAJ,EAAkD;AAC9C,oBAAI,KAAK,IAAL,EAAW,KAAK,IAAhB,KAAyB,KAAK,IAAL,EAAW,KAAK,KAAhB,CAA7B,EAAqD;AACjD,4BAAQ,MAAR,CAAe,IAAf,EAAqB,sDAArB;AACH;AACJ,aAJD,MAIO,IAAI,sCAAsC,QAAtC,CAAJ,EAAqD;AACxD,oBAAI,KAAK,IAAL,EAAW,KAAK,IAAhB,CAAJ,EAA2B;AACvB,4BAAQ,MAAR,CAAe,IAAf,EAAqB,sDAArB;AACH;AACJ;AACJ;;;;;;;AAOD,iBAAS,QAAT,CAAkB,IAAlB,EAAwB;AACpB,gBAAI,KAAK,QAAL,KAAkB,GAAtB,EAA2B;AACvB,wBAAQ,MAAR,CAAe,IAAf,EAAqB,2CAArB;AACH;AACJ;;AAED,eAAO;AACH,kCAAsB,QAAQ,OAAR,CAAgB,CAAhB,MAAuB,OAAvB,GAAiC,MAAjC,GAA0C;AAD7D,SAAP;AAIH;AA3DY,CAAjB","file":"operator-assignment-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to replace assignment expressions with operator assignment\n * @author Brandon Mills\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether an operator is commutative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is commutative and has a\n *     shorthand form.\n */\nfunction isCommutativeOperatorWithShorthand(operator) {\n    return [\"*\", \"&\", \"^\", \"|\"].indexOf(operator) >= 0;\n}\n\n/**\n * Checks whether an operator is not commuatative and has an operator assignment\n * shorthand form.\n * @param   {string}  operator Operator to check.\n * @returns {boolean}          True if the operator is not commuatative and has\n *     a shorthand form.\n */\nfunction isNonCommutativeOperatorWithShorthand(operator) {\n    return [\"+\", \"-\", \"/\", \"%\", \"<<\", \">>\", \">>>\"].indexOf(operator) >= 0;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\":\n\n            /*\n             * x[0] = x[0]\n             * x[y] = x[y]\n             * x.y = x.y\n             */\n            return same(a.object, b.object) && same(a.property, b.property);\n\n        default:\n            return false;\n    }\n}\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow assignment operator shorthand where possible\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        /**\n         * Ensures that an assignment uses the shorthand form where possible.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function verify(node) {\n            var expr, left, operator;\n\n            if (node.operator !== \"=\" || node.right.type !== \"BinaryExpression\") {\n                return;\n            }\n\n            left = node.left;\n            expr = node.right;\n            operator = expr.operator;\n\n            if (isCommutativeOperatorWithShorthand(operator)) {\n                if (same(left, expr.left) || same(left, expr.right)) {\n                    context.report(node, \"Assignment can be replaced with operator assignment.\");\n                }\n            } else if (isNonCommutativeOperatorWithShorthand(operator)) {\n                if (same(left, expr.left)) {\n                    context.report(node, \"Assignment can be replaced with operator assignment.\");\n                }\n            }\n        }\n\n        /**\n         * Warns if an assignment expression uses operator assignment shorthand.\n         * @param   {ASTNode} node An AssignmentExpression node.\n         * @returns {void}\n         */\n        function prohibit(node) {\n            if (node.operator !== \"=\") {\n                context.report(node, \"Unexpected operator assignment shorthand.\");\n            }\n        }\n\n        return {\n            AssignmentExpression: context.options[0] !== \"never\" ? verify : prohibit\n        };\n\n    }\n};\n"]}