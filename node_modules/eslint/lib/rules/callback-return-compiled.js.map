{"version":3,"sources":["callback-return.js"],"names":[],"mappings":"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","file":"callback-return-compiled.js","sourcesContent":["/**\n * @fileoverview Enforce return after a callback.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `return` statements after callbacks\",\n            category: \"Node.js and CommonJS\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"array\",\n            items: { type: \"string\" }\n        }]\n    },\n\n    create: function(context) {\n\n        var callbacks = context.options[0] || [\"callback\", \"cb\", \"next\"];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Find the closest parent matching a list of types.\n         * @param {ASTNode} node The node whose parents we are searching\n         * @param {Array} types The node types to match\n         * @returns {ASTNode} The matched node or undefined.\n         */\n        function findClosestParentOfType(node, types) {\n            if (!node.parent) {\n                return null;\n            }\n            if (types.indexOf(node.parent.type) === -1) {\n                return findClosestParentOfType(node.parent, types);\n            }\n            return node.parent;\n        }\n\n        /**\n         * Check to see if a CallExpression is in our callback list.\n         * @param {ASTNode} node The node to check against our callback names list.\n         * @returns {Boolean} Whether or not this function matches our callback name.\n         */\n        function isCallback(node) {\n            return node.callee.type === \"Identifier\" && callbacks.indexOf(node.callee.name) > -1;\n        }\n\n        /**\n         * Determines whether or not the callback is part of a callback expression.\n         * @param {ASTNode} node The callback node\n         * @param {ASTNode} parentNode The expression node\n         * @returns {boolean} Whether or not this is part of a callback expression\n         */\n        function isCallbackExpression(node, parentNode) {\n\n            // ensure the parent node exists and is an expression\n            if (!parentNode || parentNode.type !== \"ExpressionStatement\") {\n                return false;\n            }\n\n            // cb()\n            if (parentNode.expression === node) {\n                return true;\n            }\n\n            // special case for cb && cb() and similar\n            if (parentNode.expression.type === \"BinaryExpression\" || parentNode.expression.type === \"LogicalExpression\") {\n                if (parentNode.expression.right === node) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression: function(node) {\n\n                // if we\"re not a callback we can return\n                if (!isCallback(node)) {\n                    return;\n                }\n\n                // find the closest block, return or loop\n                var closestBlock = findClosestParentOfType(node, [\"BlockStatement\", \"ReturnStatement\", \"ArrowFunctionExpression\"]) || {},\n                    lastItem, parentType;\n\n                // if our parent is a return we know we're ok\n                if (closestBlock.type === \"ReturnStatement\") {\n                    return;\n                }\n\n                // arrow functions don't always have blocks and implicitly return\n                if (closestBlock.type === \"ArrowFunctionExpression\") {\n                    return;\n                }\n\n                // block statements are part of functions and most if statements\n                if (closestBlock.type === \"BlockStatement\") {\n\n                    // find the last item in the block\n                    lastItem = closestBlock.body[closestBlock.body.length - 1];\n\n                    // if the callback is the last thing in a block that might be ok\n                    if (isCallbackExpression(node, lastItem)) {\n\n                        parentType = closestBlock.parent.type;\n\n                        // but only if the block is part of a function\n                        if (parentType === \"FunctionExpression\" ||\n                            parentType === \"FunctionDeclaration\" ||\n                            parentType === \"ArrowFunctionExpression\"\n                        ) {\n                            return;\n                        }\n\n                    }\n\n                    // ending a block with a return is also ok\n                    if (lastItem.type === \"ReturnStatement\") {\n\n                        // but only if the callback is immediately before\n                        if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {\n                            return;\n                        }\n                    }\n\n                }\n\n                // as long as you're the child of a function at this point you should be asked to return\n                if (findClosestParentOfType(node, [\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"])) {\n                    context.report(node, \"Expected return with your callback function.\");\n                }\n\n            }\n\n        };\n    }\n};\n"]}