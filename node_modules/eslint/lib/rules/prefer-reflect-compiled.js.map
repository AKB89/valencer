{"version":3,"sources":["prefer-reflect.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,4CADX;AAEF,sBAAU,cAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,4BAAY;AACR,0BAAM,OADE;AAER,2BAAO;AACH,8BAAM,CACF,OADE,EAEF,MAFE,EAGF,QAHE,EAIF,gBAJE,EAKF,0BALE,EAMF,gBANE,EAOF,gBAPE,EAQF,cARE,EASF,qBATE,EAUF,mBAVE;AADH,qBAFC;AAgBR,iCAAa;AAhBL;AADJ,aAFhB;AAsBI,kCAAsB;AAtB1B,SADI;AAPN,KADO;;AAoCb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,gBAAgB;AAChB,mBAAO,0BADS;AAEhB,kBAAM,yBAFU;AAGhB,4BAAgB,uBAHA;AAIhB,sCAA0B,iCAJV;AAKhB,4BAAgB,uBALA;AAMhB,4BAAgB,uBANA;AAOhB,0BAAc,qBAPE;AAQhB,iCAAqB,4BARL;AAShB,+BAAmB;AATH,SAApB;;AAYA,YAAI,oBAAoB;AACpB,mBAAO,eADa;AAEpB,kBAAM,eAFc;AAGpB,4BAAgB,wBAHI;AAIpB,sCAA0B,kCAJN;AAKpB,4BAAgB,wBALI;AAMpB,4BAAgB,wBANI;AAOpB,0BAAc,sBAPM;AAQpB,iCAAqB,6BARD;AASpB,+BAAmB;AATC,SAAxB;;AAYA,YAAI,aAAa,CAAC,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAAvB,EAA2B,UAA3B,IAAyC,EAA1D;;;;;;;;;AASA,iBAAS,MAAT,CAAgB,IAAhB,EAAsB,QAAtB,EAAgC,UAAhC,EAA4C;AACxC,oBAAQ,MAAR,CAAe,IAAf,EAAqB,sDAArB,EAA6E;AACzE,0BAAU,QAD+D;AAEzE,4BAAY;AAF6D,aAA7E;AAIH;;AAED,eAAO;AACH,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,aAAa,CAAC,KAAK,MAAL,CAAY,QAAZ,IAAwB,EAAzB,EAA6B,IAA9C;AACA,oBAAI,gBAAgB,CAAC,KAAK,MAAL,CAAY,MAAZ,IAAsB,EAAvB,EAA2B,IAA3B,KAAoC,SAAxD;AACA,oBAAI,sBAAsB,kBAAkB,cAAlB,CAAiC,UAAjC,CAA1B;AACA,oBAAI,0BAA0B,WAAW,OAAX,CAAmB,UAAnB,MAAmC,CAAC,CAAlE;;AAEA,oBAAI,uBAAuB,CAAC,aAAxB,IAAyC,CAAC,uBAA9C,EAAuE;AACnE,2BAAO,IAAP,EAAa,cAAc,UAAd,CAAb,EAAwC,kBAAkB,UAAlB,CAAxC;AACH;AACJ,aAVE;AAWH,6BAAiB,UAAS,IAAT,EAAe;AAC5B,oBAAI,mBAAmB,KAAK,QAAL,KAAkB,QAAzC;AACA,oBAAI,oBAAoB,KAAK,QAAL,CAAc,IAAd,KAAuB,YAA/C;AACA,oBAAI,0BAA0B,WAAW,OAAX,CAAmB,QAAnB,MAAiC,CAAC,CAAhE;;AAEA,oBAAI,oBAAoB,CAAC,iBAArB,IAA0C,CAAC,uBAA/C,EAAwE;AACpE,2BAAO,IAAP,EAAa,oBAAb,EAAmC,wBAAnC;AACH;AACJ;AAnBE,SAAP;AAsBH;AAnGY,CAAjB","file":"prefer-reflect-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to suggest using \"Reflect\" api over Function/Object methods\n * @author Keith Cirkel <http://keithcirkel.co.uk>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `Reflect` methods where applicable\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            enum: [\n                                \"apply\",\n                                \"call\",\n                                \"delete\",\n                                \"defineProperty\",\n                                \"getOwnPropertyDescriptor\",\n                                \"getPrototypeOf\",\n                                \"setPrototypeOf\",\n                                \"isExtensible\",\n                                \"getOwnPropertyNames\",\n                                \"preventExtensions\"\n                            ]\n                        },\n                        uniqueItems: true\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var existingNames = {\n            apply: \"Function.prototype.apply\",\n            call: \"Function.prototype.call\",\n            defineProperty: \"Object.defineProperty\",\n            getOwnPropertyDescriptor: \"Object.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Object.getPrototypeOf\",\n            setPrototypeOf: \"Object.setPrototypeOf\",\n            isExtensible: \"Object.isExtensible\",\n            getOwnPropertyNames: \"Object.getOwnPropertyNames\",\n            preventExtensions: \"Object.preventExtensions\"\n        };\n\n        var reflectSubsitutes = {\n            apply: \"Reflect.apply\",\n            call: \"Reflect.apply\",\n            defineProperty: \"Reflect.defineProperty\",\n            getOwnPropertyDescriptor: \"Reflect.getOwnPropertyDescriptor\",\n            getPrototypeOf: \"Reflect.getPrototypeOf\",\n            setPrototypeOf: \"Reflect.setPrototypeOf\",\n            isExtensible: \"Reflect.isExtensible\",\n            getOwnPropertyNames: \"Reflect.getOwnPropertyNames\",\n            preventExtensions: \"Reflect.preventExtensions\"\n        };\n\n        var exceptions = (context.options[0] || {}).exceptions || [];\n\n        /**\n         * Reports the Reflect violation based on the `existing` and `substitute`\n         * @param {Object} node The node that violates the rule.\n         * @param {string} existing The existing method name that has been used.\n         * @param {string} substitute The Reflect substitute that should be used.\n         * @returns {void}\n         */\n        function report(node, existing, substitute) {\n            context.report(node, \"Avoid using {{existing}}, instead use {{substitute}}\", {\n                existing: existing,\n                substitute: substitute\n            });\n        }\n\n        return {\n            CallExpression: function(node) {\n                var methodName = (node.callee.property || {}).name;\n                var isReflectCall = (node.callee.object || {}).name === \"Reflect\";\n                var hasReflectSubsitute = reflectSubsitutes.hasOwnProperty(methodName);\n                var userConfiguredException = exceptions.indexOf(methodName) !== -1;\n\n                if (hasReflectSubsitute && !isReflectCall && !userConfiguredException) {\n                    report(node, existingNames[methodName], reflectSubsitutes[methodName]);\n                }\n            },\n            UnaryExpression: function(node) {\n                var isDeleteOperator = node.operator === \"delete\";\n                var targetsIdentifier = node.argument.type === \"Identifier\";\n                var userConfiguredException = exceptions.indexOf(\"delete\") !== -1;\n\n                if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {\n                    report(node, \"the delete keyword\", \"Reflect.deleteProperty\");\n                }\n            }\n        };\n\n    }\n};\n"]}