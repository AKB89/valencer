{"version":3,"sources":["no-irregular-whitespace.js"],"names":[],"mappings":"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","file":"no-irregular-whitespace-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to disalow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nvar ALL_IRREGULARS = /[\\f\\v\\u0085\\u00A0\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/;\nvar IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\u00A0\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mg;\nvar IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mg;\nvar LINE_BREAK = /\\r\\n|\\r|\\n|\\u2028|\\u2029/g;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow irregular whitespace outside of strings and comments\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipComments: {\n                        type: \"boolean\"\n                    },\n                    skipStrings: {\n                        type: \"boolean\"\n                    },\n                    skipTemplates: {\n                        type: \"boolean\"\n                    },\n                    skipRegExps: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        // Module store of errors that we have found\n        var errors = [];\n\n        // Comment nodes.  We accumulate these as we go, so we can be sure to trigger them after the whole `Program` entity is parsed, even for top-of-file comments.\n        var commentNodes = [];\n\n        // Lookup the `skipComments` option, which defaults to `false`.\n        var options = context.options[0] || {};\n        var skipComments = !!options.skipComments;\n        var skipStrings = options.skipStrings !== false;\n        var skipRegExps = !!options.skipRegExps;\n        var skipTemplates = !!options.skipTemplates;\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Removes errors that occur inside a string node\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeWhitespaceError(node) {\n            var locStart = node.loc.start;\n            var locEnd = node.loc.end;\n\n            errors = errors.filter(function(error) {\n                var errorLoc = error[1];\n\n                if (errorLoc.line >= locStart.line && errorLoc.line <= locEnd.line) {\n                    if (errorLoc.column >= locStart.column && (errorLoc.column <= locEnd.column || errorLoc.line < locEnd.line)) {\n                        return false;\n                    }\n                }\n                return true;\n            });\n        }\n\n        /**\n         * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {\n            var shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n            var shouldCheckRegExps = skipRegExps && (node.value instanceof RegExp);\n\n            if (shouldCheckStrings || shouldCheckRegExps) {\n\n                // If we have irregular characters remove them from the errors list\n                if (ALL_IRREGULARS.test(node.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInTemplateLiteral(node) {\n            if (typeof node.value.raw === \"string\") {\n                if (ALL_IRREGULARS.test(node.value.raw)) {\n                    removeWhitespaceError(node);\n                }\n            }\n        }\n\n        /**\n         * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n         * @param {ASTNode} node to check for matching errors.\n         * @returns {void}\n         * @private\n         */\n        function removeInvalidNodeErrorsInComment(node) {\n            if (ALL_IRREGULARS.test(node.value)) {\n                removeWhitespaceError(node);\n            }\n        }\n\n        /**\n         * Checks the program source for irregular whitespace\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularWhitespace(node) {\n            var sourceLines = sourceCode.lines;\n\n            sourceLines.forEach(function(sourceLine, lineIndex) {\n                var lineNumber = lineIndex + 1,\n                    location,\n                    match;\n\n                while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {\n                    location = {\n                        line: lineNumber,\n                        column: match.index\n                    };\n\n                    errors.push([node, location, \"Irregular whitespace not allowed\"]);\n                }\n            });\n        }\n\n        /**\n         * Checks the program source for irregular line terminators\n         * @param {ASTNode} node The program node\n         * @returns {void}\n         * @private\n         */\n        function checkForIrregularLineTerminators(node) {\n            var source = sourceCode.getText(),\n                sourceLines = sourceCode.lines,\n                linebreaks = source.match(LINE_BREAK),\n                lastLineIndex = -1,\n                lineIndex,\n                location,\n                match;\n\n            while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {\n                lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n\n                location = {\n                    line: lineIndex + 1,\n                    column: sourceLines[lineIndex].length\n                };\n\n                errors.push([node, location, \"Irregular whitespace not allowed\"]);\n                lastLineIndex = lineIndex;\n            }\n        }\n\n        /**\n         * Stores a comment node (`LineComment` or `BlockComment`) for later stripping of errors within; a necessary deferring of processing to deal with top-of-file comments.\n         * @param {ASTNode} node The comment node\n         * @returns {void}\n         * @private\n         */\n        function rememberCommentNode(node) {\n            commentNodes.push(node);\n        }\n\n        /**\n         * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n         * @returns {void}\n         * @private\n         */\n        function noop() {}\n\n        var nodes = {};\n\n        if (ALL_IRREGULARS.test(sourceCode.getText())) {\n            nodes.Program = function(node) {\n\n                /*\n                 * As we can easily fire warnings for all white space issues with\n                 * all the source its simpler to fire them here.\n                 * This means we can check all the application code without having\n                 * to worry about issues caused in the parser tokens.\n                 * When writing this code also evaluating per node was missing out\n                 * connecting tokens in some cases.\n                 * We can later filter the errors when they are found to be not an\n                 * issue in nodes we don't care about.\n                 */\n\n                checkForIrregularWhitespace(node);\n                checkForIrregularLineTerminators(node);\n            };\n\n            nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n            nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n            nodes.LineComment = skipComments ? rememberCommentNode : noop;\n            nodes.BlockComment = skipComments ? rememberCommentNode : noop;\n            nodes[\"Program:exit\"] = function() {\n\n                if (skipComments) {\n\n                    // First strip errors occurring in comment nodes.  We have to do this post-`Program` to deal with top-of-file comments.\n                    commentNodes.forEach(removeInvalidNodeErrorsInComment);\n                }\n\n                // If we have any errors remaining report on them\n                errors.forEach(function(error) {\n                    context.report.apply(context, error);\n                });\n            };\n        } else {\n            nodes.Program = noop;\n        }\n\n        return nodes;\n    }\n};\n"]}