{"version":3,"sources":["newline-after-var.js"],"names":[],"mappings":"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","file":"newline-after-var-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to check empty newline after \"var\" statement\n * @author Gopal Venkatesan\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow an empty line after `var` declarations\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"never\", \"always\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var ALWAYS_MESSAGE = \"Expected blank line after variable declarations.\",\n            NEVER_MESSAGE = \"Unexpected blank line after variable declarations.\";\n\n        var sourceCode = context.getSourceCode();\n\n        // Default `mode` to \"always\".\n        var mode = context.options[0] === \"never\" ? \"never\" : \"always\";\n\n        // Cache starting and ending line numbers of comments for faster lookup\n        var commentEndLine = sourceCode.getAllComments().reduce(function(result, token) {\n            result[token.loc.start.line] = token.loc.end.line;\n            return result;\n        }, {});\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determine if provided keyword is a variable declaration\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a type of var\n         */\n        function isVar(keyword) {\n            return keyword === \"var\" || keyword === \"let\" || keyword === \"const\";\n        }\n\n        /**\n         * Determine if provided keyword is a variant of for specifiers\n         * @private\n         * @param {string} keyword - keyword to test\n         * @returns {boolean} True if `keyword` is a variant of for specifier\n         */\n        function isForTypeSpecifier(keyword) {\n            return keyword === \"ForStatement\" || keyword === \"ForInStatement\" || keyword === \"ForOfStatement\";\n        }\n\n        /**\n         * Determine if provided keyword is an export specifiers\n         * @private\n         * @param {string} nodeType - nodeType to test\n         * @returns {boolean} True if `nodeType` is an export specifier\n         */\n        function isExportSpecifier(nodeType) {\n            return nodeType === \"ExportNamedDeclaration\" || nodeType === \"ExportSpecifier\" ||\n                nodeType === \"ExportDefaultDeclaration\" || nodeType === \"ExportAllDeclaration\";\n        }\n\n        /**\n         * Determine if provided node is the last of their parent block.\n         * @private\n         * @param {ASTNode} node - node to test\n         * @returns {boolean} True if `node` is last of their parent block.\n         */\n        function isLastNode(node) {\n            var token = sourceCode.getTokenAfter(node);\n\n            return !token || (token.type === \"Punctuator\" && token.value === \"}\");\n        }\n\n        /**\n         * Determine if a token starts more than one line after a comment ends\n         * @param  {token}   token            The token being checked\n         * @param {integer}  commentStartLine The line number on which the comment starts\n         * @returns {boolean}                 True if `token` does not start immediately after a comment\n         */\n        function hasBlankLineAfterComment(token, commentStartLine) {\n            var commentEnd = commentEndLine[commentStartLine];\n\n            // If there's another comment, repeat check for blank line\n            if (commentEndLine[commentEnd + 1]) {\n                return hasBlankLineAfterComment(token, commentEnd + 1);\n            }\n\n            return (token.loc.start.line > commentEndLine[commentStartLine] + 1);\n        }\n\n        /**\n         * Checks that a blank line exists after a variable declaration when mode is\n         * set to \"always\", or checks that there is no blank line when mode is set\n         * to \"never\"\n         * @private\n         * @param {ASTNode} node - `VariableDeclaration` node to test\n         * @returns {void}\n         */\n        function checkForBlankLine(node) {\n            var lastToken = sourceCode.getLastToken(node),\n                nextToken = sourceCode.getTokenAfter(node),\n                nextLineNum = lastToken.loc.end.line + 1,\n                noNextLineToken,\n                hasNextLineComment;\n\n            // Ignore if there is no following statement\n            if (!nextToken) {\n                return;\n            }\n\n            // Ignore if parent of node is a for variant\n            if (isForTypeSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Ignore if parent of node is an export specifier\n            if (isExportSpecifier(node.parent.type)) {\n                return;\n            }\n\n            // Some coding styles use multiple `var` statements, so do nothing if\n            // the next token is a `var` statement.\n            if (nextToken.type === \"Keyword\" && isVar(nextToken.value)) {\n                return;\n            }\n\n            // Ignore if it is last statement in a block\n            if (isLastNode(node)) {\n                return;\n            }\n\n            // Next statement is not a `var`...\n            noNextLineToken = nextToken.loc.start.line > nextLineNum;\n            hasNextLineComment = (typeof commentEndLine[nextLineNum] !== \"undefined\");\n\n            if (mode === \"never\" && noNextLineToken && !hasNextLineComment) {\n                context.report(node, NEVER_MESSAGE, { identifier: node.name });\n            }\n\n            // Token on the next line, or comment without blank line\n            if (\n                mode === \"always\" && (\n                    !noNextLineToken ||\n                    hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum)\n                )\n            ) {\n                context.report(node, ALWAYS_MESSAGE, { identifier: node.name });\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            VariableDeclaration: checkForBlankLine\n        };\n\n    }\n};\n"]}