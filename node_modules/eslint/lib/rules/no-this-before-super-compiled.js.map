{"version":3,"sources":["no-this-before-super.js"],"names":[],"mappings":"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","file":"no-this-before-super-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to disallow using `this`/`super` before `super()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `this`/`super` before calling `super()` in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n\n        /*\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether the owner class has a valid\n         *   `extends` part.\n         * - scope:      The scope of the owner class.\n         * - codePath:   The code path of this constructor.\n         */\n        var funcInfo = null;\n\n        /*\n         * Information for each code path segment.\n         * Each key is the id of a code path segment.\n         * Each value is an object:\n         * - superCalled:  The flag which shows `super()` called in all code paths.\n         * - invalidNodes: The array of invalid ThisExpression and Super nodes.\n         */\n        var segInfoMap = Object.create(null);\n\n        /**\n         * Gets whether or not `super()` is called in a given code path segment.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} `true` if `super()` is called.\n         */\n        function isCalled(segment) {\n            return !segment.reachable || segInfoMap[segment.id].superCalled;\n        }\n\n        /**\n         * Checks whether or not this is in a constructor.\n         * @returns {boolean} `true` if this is in a constructor.\n         */\n        function isInConstructorOfDerivedClass() {\n            return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);\n        }\n\n        /**\n         * Checks whether or not this is before `super()` is called.\n         * @returns {boolean} `true` if this is before `super()` is called.\n         */\n        function isBeforeCallOfSuper() {\n            return (\n                isInConstructorOfDerivedClass(funcInfo) &&\n                !funcInfo.codePath.currentSegments.every(isCalled)\n            );\n        }\n\n        /**\n         * Sets a given node as invalid.\n         * @param {ASTNode} node - A node to set as invalid. This is one of\n         *      a ThisExpression and a Super.\n         * @returns {void}\n         */\n        function setInvalid(node) {\n            var segments = funcInfo.codePath.currentSegments;\n\n            for (var i = 0; i < segments.length; ++i) {\n                var segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].invalidNodes.push(node);\n                }\n            }\n        }\n\n        /**\n         * Sets the current segment as `super` was called.\n         * @returns {void}\n         */\n        function setSuperCalled() {\n            var segments = funcInfo.codePath.currentSegments;\n\n            for (var i = 0; i < segments.length; ++i) {\n                var segment = segments[i];\n\n                if (segment.reachable) {\n                    segInfoMap[segment.id].superCalled = true;\n                }\n            }\n        }\n\n        return {\n\n            /**\n             * Adds information of a constructor into the stack.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart: function(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    var classNode = node.parent.parent.parent;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(\n                            classNode.superClass &&\n                            !astUtils.isNullOrUndefined(classNode.superClass)\n                        ),\n                        codePath: codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        codePath: codePath\n                    };\n                }\n            },\n\n            /**\n             * Removes the top of stack item.\n             *\n             * And this treverses all segments of this code path then reports every\n             * invalid node.\n             *\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd: function(codePath) {\n                var isDerivedClass = funcInfo.hasExtends;\n\n                funcInfo = funcInfo.upper;\n                if (!isDerivedClass) {\n                    return;\n                }\n\n                codePath.traverseSegments(function(segment, controller) {\n                    var info = segInfoMap[segment.id];\n\n                    for (var i = 0; i < info.invalidNodes.length; ++i) {\n                        var invalidNode = info.invalidNodes[i];\n\n                        context.report({\n                            message: \"'{{kind}}' is not allowed before 'super()'.\",\n                            node: invalidNode,\n                            data: {\n                                kind: invalidNode.type === \"Super\" ? \"super\" : \"this\"\n                            }\n                        });\n                    }\n\n                    if (info.superCalled) {\n                        controller.skip();\n                    }\n                });\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart: function(segment) {\n                if (!isInConstructorOfDerivedClass(funcInfo)) {\n                    return;\n                }\n\n                // Initialize info.\n                segInfoMap[segment.id] = {\n                    superCalled: (\n                        segment.prevSegments.length > 0 &&\n                        segment.prevSegments.every(isCalled)\n                    ),\n                    invalidNodes: []\n                };\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop: function(fromSegment, toSegment) {\n                if (!isInConstructorOfDerivedClass(funcInfo)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                funcInfo.codePath.traverseSegments(\n                    {first: toSegment, last: fromSegment},\n                    function(segment, controller) {\n                        var info = segInfoMap[segment.id];\n\n                        if (info.superCalled) {\n                            info.invalidNodes = [];\n                            controller.skip();\n                        } else if (\n                            segment.prevSegments.length > 0 &&\n                            segment.prevSegments.every(isCalled)\n                        ) {\n                            info.superCalled = true;\n                            info.invalidNodes = [];\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            ThisExpression: function(node) {\n                if (isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Reports if this is before `super()`.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            Super: function(node) {\n                if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {\n                    setInvalid(node);\n                }\n            },\n\n            /**\n             * Marks `super()` called.\n             * @param {ASTNode} node - A target node.\n             * @returns {void}\n             */\n            \"CallExpression:exit\": function(node) {\n                if (node.callee.type === \"Super\" && isBeforeCallOfSuper()) {\n                    setSuperCalled();\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\": function() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"]}