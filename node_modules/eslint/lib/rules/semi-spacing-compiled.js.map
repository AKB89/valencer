{"version":3,"sources":["semi-spacing.js"],"names":[],"mappings":"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","file":"semi-spacing-compiled.js","sourcesContent":["/**\n * @fileoverview Validates spacing before and after semicolon\n * @author Mathias Schreck\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after semicolons\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {\n                        type: \"boolean\"\n                    },\n                    after: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var config = context.options[0],\n            requireSpaceBefore = false,\n            requireSpaceAfter = true,\n            sourceCode = context.getSourceCode();\n\n        if (typeof config === \"object\") {\n            if (config.hasOwnProperty(\"before\")) {\n                requireSpaceBefore = config.before;\n            }\n            if (config.hasOwnProperty(\"after\")) {\n                requireSpaceAfter = config.after;\n            }\n        }\n\n        /**\n         * Checks if a given token has leading whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has leading space, false if not.\n         */\n        function hasLeadingSpace(token) {\n            var tokenBefore = sourceCode.getTokenBefore(token);\n\n            return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);\n        }\n\n        /**\n         * Checks if a given token has trailing whitespace.\n         * @param {Object} token The token to check.\n         * @returns {boolean} True if the given token has trailing space, false if not.\n         */\n        function hasTrailingSpace(token) {\n            var tokenAfter = sourceCode.getTokenAfter(token);\n\n            return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);\n        }\n\n        /**\n         * Checks if the given token is the last token in its line.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the last in its line.\n         */\n        function isLastTokenInCurrentLine(token) {\n            var tokenAfter = sourceCode.getTokenAfter(token);\n\n            return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));\n        }\n\n        /**\n         * Checks if the given token is the first token in its line\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is the first in its line.\n         */\n        function isFirstTokenInCurrentLine(token) {\n            var tokenBefore = sourceCode.getTokenBefore(token);\n\n            return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));\n        }\n\n        /**\n         * Checks if the next token of a given token is a closing parenthesis.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the next token of a given token is a closing parenthesis.\n         */\n        function isBeforeClosingParen(token) {\n            var nextToken = sourceCode.getTokenAfter(token);\n\n            return (\n                nextToken &&\n                nextToken.type === \"Punctuator\" &&\n                (nextToken.value === \"}\" || nextToken.value === \")\")\n            );\n        }\n\n        /**\n         * Checks if the given token is a semicolon.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the given token is a semicolon.\n         */\n        function isSemicolon(token) {\n            return token.type === \"Punctuator\" && token.value === \";\";\n        }\n\n        /**\n         * Reports if the given token has invalid spacing.\n         * @param {Token} token The semicolon token to check.\n         * @param {ASTNode} node The corresponding node of the token.\n         * @returns {void}\n         */\n        function checkSemicolonSpacing(token, node) {\n            var location;\n\n            if (isSemicolon(token)) {\n                location = token.loc.start;\n\n                if (hasLeadingSpace(token)) {\n                    if (!requireSpaceBefore) {\n                        context.report({\n                            node: node,\n                            loc: location,\n                            message: \"Unexpected whitespace before semicolon.\",\n                            fix: function(fixer) {\n                                var tokenBefore = sourceCode.getTokenBefore(token);\n\n                                return fixer.removeRange([tokenBefore.range[1], token.range[0]]);\n                            }\n                        });\n                    }\n                } else {\n                    if (requireSpaceBefore) {\n                        context.report({\n                            node: node,\n                            loc: location,\n                            message: \"Missing whitespace before semicolon.\",\n                            fix: function(fixer) {\n                                return fixer.insertTextBefore(token, \" \");\n                            }\n                        });\n                    }\n                }\n\n                if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {\n                    if (hasTrailingSpace(token)) {\n                        if (!requireSpaceAfter) {\n                            context.report({\n                                node: node,\n                                loc: location,\n                                message: \"Unexpected whitespace after semicolon.\",\n                                fix: function(fixer) {\n                                    var tokenAfter = sourceCode.getTokenAfter(token);\n\n                                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);\n                                }\n                            });\n                        }\n                    } else {\n                        if (requireSpaceAfter) {\n                            context.report({\n                                node: node,\n                                loc: location,\n                                message: \"Missing whitespace after semicolon.\",\n                                fix: function(fixer) {\n                                    return fixer.insertTextAfter(token, \" \");\n                                }\n                            });\n                        }\n                    }\n                }\n            }\n        }\n\n        /**\n         * Checks the spacing of the semicolon with the assumption that the last token is the semicolon.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNode(node) {\n            var token = sourceCode.getLastToken(node);\n\n            checkSemicolonSpacing(token, node);\n        }\n\n        return {\n            VariableDeclaration: checkNode,\n            ExpressionStatement: checkNode,\n            BreakStatement: checkNode,\n            ContinueStatement: checkNode,\n            DebuggerStatement: checkNode,\n            ReturnStatement: checkNode,\n            ThrowStatement: checkNode,\n            ForStatement: function(node) {\n                if (node.init) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);\n                }\n\n                if (node.test) {\n                    checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);\n                }\n            }\n        };\n    }\n};\n"]}