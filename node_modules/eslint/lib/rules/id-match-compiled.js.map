{"version":3,"sources":["id-match.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,6DADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM;AADV,SADI,EAIJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,4BAAY;AACR,0BAAM;AADE;AADJ;AAFhB,SAJI;AAPN,KADO;;AAuBb,YAAQ,UAAS,OAAT,EAAkB;;;;;;AAMtB,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,MAApC;YACI,SAAS,IAAI,MAAJ,CAAW,OAAX,CADb;;AAGA,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAApC;YACI,aAAa,CAAC,CAAC,QAAQ,UAD3B;YAEI,mBAAmB,CAAC,CAAC,QAAQ,gBAFjC;;;;;;;;AAUA,iBAAS,SAAT,CAAmB,IAAnB,EAAyB;AACrB,mBAAO,CAAC,OAAO,IAAP,CAAY,IAAZ,CAAR;AACH;;;;;;;;;AASD,iBAAS,YAAT,CAAsB,eAAtB,EAAuC,IAAvC,EAA6C;AACzC,mBAAO,gBAAgB,IAAhB,KAAyB,gBAAzB,IACA,gBAAgB,IAAhB,KAAyB,eADzB,IAEH,UAAU,IAAV,CAFJ;AAGH;;;;;;;;AAQD,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,oBAAQ,MAAR,CAAe,IAAf,EAAqB,iEAArB,EAAwF;AACpF,sBAAM,KAAK,IADyE;AAEpF,yBAAS;AAF2E,aAAxF;AAIH;;AAED,eAAO;;AAEH,wBAAY,UAAS,IAAT,EAAe;AACvB,oBAAI,OAAO,KAAK,IAAhB;oBACI,SAAS,KAAK,MADlB;oBAEI,kBAAmB,OAAO,IAAP,KAAgB,kBAAjB,GAAuC,OAAO,MAA9C,GAAuD,MAF7E;;AAIA,oBAAI,OAAO,IAAP,KAAgB,kBAApB,EAAwC;;AAEpC,wBAAI,CAAC,UAAL,EAAiB;AACb;AACH;;;AAGD,wBAAI,OAAO,MAAP,CAAc,IAAd,KAAuB,YAAvB,IACA,OAAO,MAAP,CAAc,IAAd,KAAuB,IAD3B,EACiC;AAC7B,4BAAI,UAAU,IAAV,CAAJ,EAAqB;AACjB,mCAAO,IAAP;AACH;;;AAGJ,qBAPD,MAOO,IAAI,gBAAgB,IAAhB,KAAyB,sBAAzB,KACN,gBAAgB,KAAhB,CAAsB,IAAtB,KAA+B,kBAA/B,IACD,gBAAgB,IAAhB,CAAqB,IAArB,KAA8B,kBAA9B,IACA,gBAAgB,IAAhB,CAAqB,QAArB,CAA8B,IAA9B,KAAuC,IAHhC,CAAJ,EAG2C;AAC9C,gCAAI,UAAU,IAAV,CAAJ,EAAqB;AACjB,uCAAO,IAAP;AACH;AACJ;AAEJ,iBAvBD,MAuBO,IAAI,OAAO,IAAP,KAAgB,UAApB,EAAgC;;AAEnC,wBAAI,CAAC,UAAD,IAAe,OAAO,GAAP,CAAW,IAAX,KAAoB,IAAvC,EAA6C;AACzC;AACH;;AAED,wBAAI,aAAa,eAAb,EAA8B,IAA9B,CAAJ,EAAyC;AACrC,+BAAO,IAAP;AACH;AAEJ,iBAVM,MAUA;AACH,wBAAI,gBAAgB,gBAAgB,IAAhB,KAAyB,qBAAzB,IAAkD,gBAAgB,IAAhB,KAAyB,oBAA/F;;AAEA,wBAAI,oBAAoB,CAAC,aAAzB,EAAwC;AACpC;AACH;;AAED,wBAAI,aAAa,eAAb,EAA8B,IAA9B,CAAJ,EAAyC;AACrC,+BAAO,IAAP;AACH;AACJ;AACJ;;AAnDE,SAAP;AAuDH;AA/HY,CAAjB","file":"id-match-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag non-matching identifiers\n * @author Matthieu Larcher\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require identifiers to match a specified regular expression\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"string\"\n            },\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        type: \"boolean\"\n                    }\n                }\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        var pattern = context.options[0] || \"^.+$\",\n            regexp = new RegExp(pattern);\n\n        var options = context.options[1] || {},\n            properties = !!options.properties,\n            onlyDeclarations = !!options.onlyDeclarations;\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {String} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return !regexp.test(name);\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {String} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\"\n                && effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report(node, \"Identifier '{{name}}' does not match the pattern '{{pattern}}'.\", {\n                name: node.name,\n                pattern: pattern\n            });\n        }\n\n        return {\n\n            Identifier: function(node) {\n                var name = node.name,\n                    parent = node.parent,\n                    effectiveParent = (parent.type === \"MemberExpression\") ? parent.parent : parent;\n\n                if (parent.type === \"MemberExpression\") {\n\n                    if (!properties) {\n                        return;\n                    }\n\n                    // Always check object names\n                    if (parent.object.type === \"Identifier\" &&\n                        parent.object.name === name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                } else if (parent.type === \"Property\") {\n\n                    if (!properties || parent.key.name !== name) {\n                        return;\n                    }\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                } else {\n                    var isDeclaration = effectiveParent.type === \"FunctionDeclaration\" || effectiveParent.type === \"VariableDeclarator\";\n\n                    if (onlyDeclarations && !isDeclaration) {\n                        return;\n                    }\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"]}