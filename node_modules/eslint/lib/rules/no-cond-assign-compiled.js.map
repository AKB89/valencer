{"version":3,"sources":["no-cond-assign.js"],"names":[],"mappings":"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","file":"no-cond-assign-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag assignment in a conditional statement's test expression\n * @author Stephen Murray <spmurrayzzz>\n */\n\"use strict\";\n\nvar NODE_DESCRIPTIONS = {\n    DoWhileStatement: \"a 'do...while' statement\",\n    ForStatement: \"a 'for' statement\",\n    IfStatement: \"an 'if' statement\",\n    WhileStatement: \"a 'while' statement\"\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignment operators in conditional expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var prohibitAssign = (context.options[0] || \"except-parens\");\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Check whether an AST node is the test expression for a conditional statement.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the node is the text expression for a conditional statement; otherwise, `false`.\n         */\n        function isConditionalTestExpression(node) {\n            return node.parent &&\n                node.parent.test &&\n                node === node.parent.test;\n        }\n\n        /**\n         * Given an AST node, perform a bottom-up search for the first ancestor that represents a conditional statement.\n         * @param {!Object} node The node to use at the start of the search.\n         * @returns {?Object} The closest ancestor node that represents a conditional statement.\n         */\n        function findConditionalAncestor(node) {\n            var currentAncestor = node;\n\n            do {\n                if (isConditionalTestExpression(currentAncestor)) {\n                    return currentAncestor.parent;\n                }\n            } while ((currentAncestor = currentAncestor.parent));\n\n            return null;\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in parentheses; otherwise, `false`.\n         */\n        function isParenthesised(node) {\n            var previousToken = sourceCode.getTokenBefore(node),\n                nextToken = sourceCode.getTokenAfter(node);\n\n            return previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n                nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check whether the code represented by an AST node is enclosed in two sets of parentheses.\n         * @param {!Object} node The node to test.\n         * @returns {boolean} `true` if the code is enclosed in two sets of parentheses; otherwise, `false`.\n         */\n        function isParenthesisedTwice(node) {\n            var previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) &&\n                previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n                nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check a conditional statement's test expression for top-level assignments that are not enclosed in parentheses.\n         * @param {!Object} node The node for the conditional statement.\n         * @returns {void}\n         */\n        function testForAssign(node) {\n            if (node.test &&\n                (node.test.type === \"AssignmentExpression\") &&\n                (node.type === \"ForStatement\" ?\n                    !isParenthesised(node.test) :\n                    !isParenthesisedTwice(node.test)\n                )\n            ) {\n\n                // must match JSHint's error message\n                context.report({\n                    node: node,\n                    loc: node.test.loc.start,\n                    message: \"Expected a conditional expression and instead saw an assignment.\"\n                });\n            }\n        }\n\n        /**\n         * Check whether an assignment expression is descended from a conditional statement's test expression.\n         * @param {!Object} node The node for the assignment expression.\n         * @returns {void}\n         */\n        function testForConditionalAncestor(node) {\n            var ancestor = findConditionalAncestor(node);\n\n            if (ancestor) {\n                context.report(ancestor, \"Unexpected assignment within {{type}}.\", {\n                    type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type\n                });\n            }\n        }\n\n        if (prohibitAssign === \"always\") {\n            return {\n                AssignmentExpression: testForConditionalAncestor\n            };\n        }\n\n        return {\n            DoWhileStatement: testForAssign,\n            ForStatement: testForAssign,\n            IfStatement: testForAssign,\n            WhileStatement: testForAssign\n        };\n\n    }\n};\n"]}