{"version":3,"sources":["constructor-super.js"],"names":[],"mappings":"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","file":"constructor-super-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to verify `super()` callings in constructor.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether a given code path segment is reachable or not.\n *\n * @param {CodePathSegment} segment - A code path segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether or not a given node is a constructor.\n * @param {ASTNode} node - A node to check. This node type is one of\n *   `Program`, `FunctionDeclaration`, `FunctionExpression`, and\n *   `ArrowFunctionExpression`.\n * @returns {boolean} `true` if the node is a constructor.\n */\nfunction isConstructorFunction(node) {\n    return (\n        node.type === \"FunctionExpression\" &&\n        node.parent.type === \"MethodDefinition\" &&\n        node.parent.kind === \"constructor\"\n    );\n}\n\n/**\n * Checks whether a given node can be a constructor or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node can be a constructor.\n */\nfunction isPossibleConstructor(node) {\n    if (!node) {\n        return false;\n    }\n\n    switch (node.type) {\n        case \"ClassExpression\":\n        case \"FunctionExpression\":\n        case \"ThisExpression\":\n        case \"MemberExpression\":\n        case \"CallExpression\":\n        case \"NewExpression\":\n        case \"YieldExpression\":\n        case \"TaggedTemplateExpression\":\n        case \"MetaProperty\":\n            return true;\n\n        case \"Identifier\":\n            return node.name !== \"undefined\";\n\n        case \"AssignmentExpression\":\n            return isPossibleConstructor(node.right);\n\n        case \"LogicalExpression\":\n            return (\n                isPossibleConstructor(node.left) ||\n                isPossibleConstructor(node.right)\n            );\n\n        case \"ConditionalExpression\":\n            return (\n                isPossibleConstructor(node.alternate) ||\n                isPossibleConstructor(node.consequent)\n            );\n\n        case \"SequenceExpression\":\n            var lastExpression = node.expressions[node.expressions.length - 1];\n\n            return isPossibleConstructor(lastExpression);\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `super()` calls in constructors\",\n            category: \"ECMAScript 6\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n\n        /*\n         * {{hasExtends: boolean, scope: Scope, codePath: CodePath}[]}\n         * Information for each constructor.\n         * - upper:      Information of the upper constructor.\n         * - hasExtends: A flag which shows whether own class has a valid `extends`\n         *               part.\n         * - scope:      The scope of own class.\n         * - codePath:   The code path object of the constructor.\n         */\n        var funcInfo = null;\n\n        /*\n         * {Map<string, {calledInSomePaths: boolean, calledInEveryPaths: boolean}>}\n         * Information for each code path segment.\n         * - calledInSomePaths:  A flag of be called `super()` in some code paths.\n         * - calledInEveryPaths: A flag of be called `super()` in all code paths.\n         * - validNodes:\n         */\n        var segInfoMap = Object.create(null);\n\n        /**\n         * Gets the flag which shows `super()` is called in some paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in some paths\n         */\n        function isCalledInSomePath(segment) {\n            return segment.reachable && segInfoMap[segment.id].calledInSomePaths;\n        }\n\n        /**\n         * Gets the flag which shows `super()` is called in all paths.\n         * @param {CodePathSegment} segment - A code path segment to get.\n         * @returns {boolean} The flag which shows `super()` is called in all paths.\n         */\n        function isCalledInEveryPath(segment) {\n\n            /*\n             * If specific segment is the looped segment of the current segment,\n             * skip the segment.\n             * If not skipped, this never becomes true after a loop.\n             */\n            if (segment.nextSegments.length === 1 &&\n                segment.nextSegments[0].isLoopedPrevSegment(segment)\n            ) {\n                return true;\n            }\n            return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;\n        }\n\n        return {\n\n            /**\n             * Stacks a constructor information.\n             * @param {CodePath} codePath - A code path which was started.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathStart: function(codePath, node) {\n                if (isConstructorFunction(node)) {\n\n                    // Class > ClassBody > MethodDefinition > FunctionExpression\n                    var classNode = node.parent.parent.parent;\n                    var superClass = classNode.superClass;\n\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: true,\n                        hasExtends: Boolean(superClass),\n                        superIsConstructor: isPossibleConstructor(superClass),\n                        codePath: codePath\n                    };\n                } else {\n                    funcInfo = {\n                        upper: funcInfo,\n                        isConstructor: false,\n                        hasExtends: false,\n                        superIsConstructor: false,\n                        codePath: codePath\n                    };\n                }\n            },\n\n            /**\n             * Pops a constructor information.\n             * And reports if `super()` lacked.\n             * @param {CodePath} codePath - A code path which was ended.\n             * @param {ASTNode} node - The current node.\n             * @returns {void}\n             */\n            onCodePathEnd: function(codePath, node) {\n                var hasExtends = funcInfo.hasExtends;\n\n                // Pop.\n                funcInfo = funcInfo.upper;\n\n                if (!hasExtends) {\n                    return;\n                }\n\n                // Reports if `super()` lacked.\n                var segments = codePath.returnedSegments;\n                var calledInEveryPaths = segments.every(isCalledInEveryPath);\n                var calledInSomePaths = segments.some(isCalledInSomePath);\n\n                if (!calledInEveryPaths) {\n                    context.report({\n                        message: calledInSomePaths ?\n                            \"Lacked a call of 'super()' in some code paths.\" :\n                            \"Expected to call 'super()'.\",\n                        node: node.parent\n                    });\n                }\n            },\n\n            /**\n             * Initialize information of a given code path segment.\n             * @param {CodePathSegment} segment - A code path segment to initialize.\n             * @returns {void}\n             */\n            onCodePathSegmentStart: function(segment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Initialize info.\n                var info = segInfoMap[segment.id] = {\n                    calledInSomePaths: false,\n                    calledInEveryPaths: false,\n                    validNodes: []\n                };\n\n                // When there are previous segments, aggregates these.\n                var prevSegments = segment.prevSegments;\n\n                if (prevSegments.length > 0) {\n                    info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                    info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n                }\n            },\n\n            /**\n             * Update information of the code path segment when a code path was\n             * looped.\n             * @param {CodePathSegment} fromSegment - The code path segment of the\n             *      end of a loop.\n             * @param {CodePathSegment} toSegment - A code path segment of the head\n             *      of a loop.\n             * @returns {void}\n             */\n            onCodePathSegmentLoop: function(fromSegment, toSegment) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Update information inside of the loop.\n                var isRealLoop = toSegment.prevSegments.length >= 2;\n\n                funcInfo.codePath.traverseSegments(\n                    {first: toSegment, last: fromSegment},\n                    function(segment) {\n                        var info = segInfoMap[segment.id];\n                        var prevSegments = segment.prevSegments;\n\n                        // Updates flags.\n                        info.calledInSomePaths = prevSegments.some(isCalledInSomePath);\n                        info.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);\n\n                        // If flags become true anew, reports the valid nodes.\n                        if (info.calledInSomePaths || isRealLoop) {\n                            var nodes = info.validNodes;\n\n                            info.validNodes = [];\n\n                            for (var i = 0; i < nodes.length; ++i) {\n                                var node = nodes[i];\n\n                                context.report({\n                                    message: \"Unexpected duplicate 'super()'.\",\n                                    node: node\n                                });\n                            }\n                        }\n                    }\n                );\n            },\n\n            /**\n             * Checks for a call of `super()`.\n             * @param {ASTNode} node - A CallExpression node to check.\n             * @returns {void}\n             */\n            \"CallExpression:exit\": function(node) {\n                if (!(funcInfo && funcInfo.isConstructor)) {\n                    return;\n                }\n\n                // Skips except `super()`.\n                if (node.callee.type !== \"Super\") {\n                    return;\n                }\n\n                // Reports if needed.\n                if (funcInfo.hasExtends) {\n                    var segments = funcInfo.codePath.currentSegments;\n                    var reachable = false;\n                    var duplicate = false;\n\n                    for (var i = 0; i < segments.length; ++i) {\n                        var segment = segments[i];\n\n                        if (segment.reachable) {\n                            var info = segInfoMap[segment.id];\n\n                            reachable = true;\n                            duplicate = duplicate || info.calledInSomePaths;\n                            info.calledInSomePaths = info.calledInEveryPaths = true;\n                        }\n                    }\n\n                    if (reachable) {\n                        if (duplicate) {\n                            context.report({\n                                message: \"Unexpected duplicate 'super()'.\",\n                                node: node\n                            });\n                        } else if (!funcInfo.superIsConstructor) {\n                            context.report({\n                                message: \"Unexpected 'super()' because 'super' is not a constructor.\",\n                                node: node\n                            });\n                        } else {\n                            info.validNodes.push(node);\n                        }\n                    }\n                } else if (funcInfo.codePath.currentSegments.some(isReachable)) {\n                    context.report({\n                        message: \"Unexpected 'super()'.\",\n                        node: node\n                    });\n                }\n            },\n\n            /**\n             * Set the mark to the returned path as `super()` was called.\n             * @param {ASTNode} node - A ReturnStatement node to check.\n             * @returns {void}\n             */\n            ReturnStatement: function(node) {\n                if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {\n                    return;\n                }\n\n                // Skips if no argument.\n                if (!node.argument) {\n                    return;\n                }\n\n                // Returning argument is a substitute of 'super()'.\n                var segments = funcInfo.codePath.currentSegments;\n\n                for (var i = 0; i < segments.length; ++i) {\n                    var segment = segments[i];\n\n                    if (segment.reachable) {\n                        var info = segInfoMap[segment.id];\n\n                        info.calledInSomePaths = info.calledInEveryPaths = true;\n                    }\n                }\n            },\n\n            /**\n             * Resets state.\n             * @returns {void}\n             */\n            \"Program:exit\": function() {\n                segInfoMap = Object.create(null);\n            }\n        };\n    }\n};\n"]}