{"version":3,"sources":["block-scoped-var.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,gEADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,QAAQ,EAAZ;;;;;;;AAOA,iBAAS,UAAT,CAAoB,IAApB,EAA0B;AACtB,kBAAM,IAAN,CAAW,KAAK,KAAhB;AACH;;;;;;AAMD,iBAAS,SAAT,GAAqB;AACjB,kBAAM,GAAN;AACH;;;;;;;AAOD,iBAAS,MAAT,CAAgB,SAAhB,EAA2B;AACvB,gBAAI,aAAa,UAAU,UAA3B;;AAEA,oBAAQ,MAAR,CACI,UADJ,EAEI,6CAFJ,EAGI,EAAC,MAAM,WAAW,IAAlB,EAHJ;AAIH;;;;;;;AAOD,iBAAS,iBAAT,CAA2B,IAA3B,EAAiC;AAC7B,gBAAI,KAAK,IAAL,KAAc,KAAlB,EAAyB;AACrB;AACH;;;AAGD,gBAAI,aAAa,MAAM,MAAM,MAAN,GAAe,CAArB,CAAjB;;;;;;;;AAQA,qBAAS,gBAAT,CAA0B,SAA1B,EAAqC;AACjC,oBAAI,UAAU,UAAU,UAAV,CAAqB,KAAnC;;AAEA,uBAAO,QAAQ,CAAR,IAAa,WAAW,CAAX,CAAb,IAA8B,QAAQ,CAAR,IAAa,WAAW,CAAX,CAAlD;AACH;;;AAGD,gBAAI,YAAY,QAAQ,oBAAR,CAA6B,IAA7B,CAAhB;;AAEA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,UAAU,MAA9B,EAAsC,EAAE,CAAxC,EAA2C;;;AAGvC,0BAAU,CAAV,EACK,UADL,CAEK,MAFL,CAEY,gBAFZ,EAGK,OAHL,CAGa,MAHb;AAIH;AACJ;;AAED,eAAO;AACH,qBAAS,UAAS,IAAT,EAAe;AACpB,wBAAQ,CAAC,KAAK,KAAN,CAAR;AACH,aAHE;;;AAMH,4BAAgB,UANb;AAOH,mCAAuB,SAPpB;AAQH,0BAAc,UARX;AASH,iCAAqB,SATlB;AAUH,4BAAgB,UAVb;AAWH,mCAAuB,SAXpB;AAYH,4BAAgB,UAZb;AAaH,mCAAuB,SAbpB;AAcH,6BAAiB,UAdd;AAeH,oCAAwB,SAfrB;AAgBH,yBAAa,UAhBV;AAiBH,gCAAoB,SAjBjB;;;AAoBH,iCAAqB;AApBlB,SAAP;AAuBH;AA1GY,CAAjB","file":"block-scoped-var-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to check for \"block scoped\" variables by binding context\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the use of variables within the scope they are defined\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var stack = [];\n\n        /**\n         * Makes a block scope.\n         * @param {ASTNode} node - A node of a scope.\n         * @returns {void}\n         */\n        function enterScope(node) {\n            stack.push(node.range);\n        }\n\n        /**\n         * Pops the last block scope.\n         * @returns {void}\n         */\n        function exitScope() {\n            stack.pop();\n        }\n\n        /**\n         * Reports a given reference.\n         * @param {escope.Reference} reference - A reference to report.\n         * @returns {void}\n         */\n        function report(reference) {\n            var identifier = reference.identifier;\n\n            context.report(\n                identifier,\n                \"'{{name}}' used outside of binding context.\",\n                {name: identifier.name});\n        }\n\n        /**\n         * Finds and reports references which are outside of valid scopes.\n         * @param {ASTNode} node - A node to get variables.\n         * @returns {void}\n         */\n        function checkForVariables(node) {\n            if (node.kind !== \"var\") {\n                return;\n            }\n\n            // Defines a predicate to check whether or not a given reference is outside of valid scope.\n            var scopeRange = stack[stack.length - 1];\n\n            /**\n             * Check if a reference is out of scope\n             * @param {ASTNode} reference node to examine\n             * @returns {boolean} True is its outside the scope\n             * @private\n             */\n            function isOutsideOfScope(reference) {\n                var idRange = reference.identifier.range;\n\n                return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];\n            }\n\n            // Gets declared variables, and checks its references.\n            var variables = context.getDeclaredVariables(node);\n\n            for (var i = 0; i < variables.length; ++i) {\n\n                // Reports.\n                variables[i]\n                    .references\n                    .filter(isOutsideOfScope)\n                    .forEach(report);\n            }\n        }\n\n        return {\n            Program: function(node) {\n                stack = [node.range];\n            },\n\n            // Manages scopes.\n            BlockStatement: enterScope,\n            \"BlockStatement:exit\": exitScope,\n            ForStatement: enterScope,\n            \"ForStatement:exit\": exitScope,\n            ForInStatement: enterScope,\n            \"ForInStatement:exit\": exitScope,\n            ForOfStatement: enterScope,\n            \"ForOfStatement:exit\": exitScope,\n            SwitchStatement: enterScope,\n            \"SwitchStatement:exit\": exitScope,\n            CatchClause: enterScope,\n            \"CatchClause:exit\": exitScope,\n\n            // Finds and reports references which are outside of valid scope.\n            VariableDeclaration: checkForVariables\n        };\n\n    }\n};\n"]}