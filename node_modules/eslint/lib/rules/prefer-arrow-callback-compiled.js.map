{"version":3,"sources":["prefer-arrow-callback.js"],"names":[],"mappings":"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","file":"prefer-arrow-callback-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to suggest using arrow functions as callbacks.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given variable is a function name.\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function name.\n */\nfunction isFunctionName(variable) {\n    return variable && variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given MetaProperty node equals to a given value.\n * @param {ASTNode} node - A MetaProperty node to check.\n * @param {string} metaName - The name of `MetaProperty.meta`.\n * @param {string} propertyName - The name of `MetaProperty.property`.\n * @returns {boolean} `true` if the node is the specific value.\n */\nfunction checkMetaProperty(node, metaName, propertyName) {\n    return node.meta.name === metaName && node.property.name === propertyName;\n}\n\n/**\n * Gets the variable object of `arguments` which is defined implicitly.\n * @param {escope.Scope} scope - A scope to get.\n * @returns {escope.Variable} The found variable object.\n */\nfunction getVariableOfArguments(scope) {\n    var variables = scope.variables;\n\n    for (var i = 0; i < variables.length; ++i) {\n        var variable = variables[i];\n\n        if (variable.name === \"arguments\") {\n\n            /*\n             * If there was a parameter which is named \"arguments\", the\n             * implicit \"arguments\" is not defined.\n             * So does fast return with null.\n             */\n            return (variable.identifiers.length === 0) ? variable : null;\n        }\n    }\n\n    /* istanbul ignore next */\n    return null;\n}\n\n/**\n * Checkes whether or not a given node is a callback.\n * @param {ASTNode} node - A node to check.\n * @returns {object}\n *   {boolean} retv.isCallback - `true` if the node is a callback.\n *   {boolean} retv.isLexicalThis - `true` if the node is with `.bind(this)`.\n */\nfunction getCallbackInfo(node) {\n    var retv = {isCallback: false, isLexicalThis: false};\n    var parent = node.parent;\n\n    while (node) {\n        switch (parent.type) {\n\n            // Checks parents recursively.\n\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                break;\n\n            // Checks whether the parent node is `.bind(this)` call.\n            case \"MemberExpression\":\n                if (parent.object === node &&\n                    !parent.property.computed &&\n                    parent.property.type === \"Identifier\" &&\n                    parent.property.name === \"bind\" &&\n                    parent.parent.type === \"CallExpression\" &&\n                    parent.parent.callee === parent\n                ) {\n                    retv.isLexicalThis = (\n                        parent.parent.arguments.length === 1 &&\n                        parent.parent.arguments[0].type === \"ThisExpression\"\n                    );\n                    node = parent;\n                    parent = parent.parent;\n                } else {\n                    return retv;\n                }\n                break;\n\n            // Checks whether the node is a callback.\n            case \"CallExpression\":\n            case \"NewExpression\":\n                if (parent.callee !== node) {\n                    retv.isCallback = true;\n                }\n                return retv;\n\n            default:\n                return retv;\n        }\n\n        node = parent;\n        parent = parent.parent;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\"unreachable\");\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require arrow functions as callbacks\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowNamedFunctions: {\n                        type: \"boolean\"\n                    },\n                    allowUnboundThis: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = context.options[0] || {};\n\n        var allowUnboundThis = options.allowUnboundThis !== false;  // default to true\n        var allowNamedFunctions = options.allowNamedFunctions;\n\n        /*\n         * {Array<{this: boolean, super: boolean, meta: boolean}>}\n         * - this - A flag which shows there are one or more ThisExpression.\n         * - super - A flag which shows there are one or more Super.\n         * - meta - A flag which shows there are one or more MethProperty.\n         */\n        var stack = [];\n\n        /**\n         * Pushes new function scope with all `false` flags.\n         * @returns {void}\n         */\n        function enterScope() {\n            stack.push({this: false, super: false, meta: false});\n        }\n\n        /**\n         * Pops a function scope from the stack.\n         * @returns {{this: boolean, super: boolean, meta: boolean}} The information of the last scope.\n         */\n        function exitScope() {\n            return stack.pop();\n        }\n\n        return {\n\n            // Reset internal state.\n            Program: function() {\n                stack = [];\n            },\n\n            // If there are below, it cannot replace with arrow functions merely.\n            ThisExpression: function() {\n                var info = stack[stack.length - 1];\n\n                if (info) {\n                    info.this = true;\n                }\n            },\n\n            Super: function() {\n                var info = stack[stack.length - 1];\n\n                if (info) {\n                    info.super = true;\n                }\n            },\n\n            MetaProperty: function(node) {\n                var info = stack[stack.length - 1];\n\n                if (info && checkMetaProperty(node, \"new\", \"target\")) {\n                    info.meta = true;\n                }\n            },\n\n            // To skip nested scopes.\n            FunctionDeclaration: enterScope,\n            \"FunctionDeclaration:exit\": exitScope,\n\n            // Main.\n            FunctionExpression: enterScope,\n            \"FunctionExpression:exit\": function(node) {\n                var scopeInfo = exitScope();\n\n                // Skip named function expressions\n                if (allowNamedFunctions && node.id && node.id.name) {\n                    return;\n                }\n\n                // Skip generators.\n                if (node.generator) {\n                    return;\n                }\n\n                // Skip recursive functions.\n                var nameVar = context.getDeclaredVariables(node)[0];\n\n                if (isFunctionName(nameVar) && nameVar.references.length > 0) {\n                    return;\n                }\n\n                // Skip if it's using arguments.\n                var variable = getVariableOfArguments(context.getScope());\n\n                if (variable && variable.references.length > 0) {\n                    return;\n                }\n\n                // Reports if it's a callback which can replace with arrows.\n                var callbackInfo = getCallbackInfo(node);\n\n                if (callbackInfo.isCallback &&\n                    (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) &&\n                    !scopeInfo.super &&\n                    !scopeInfo.meta\n                ) {\n                    context.report(node, \"Unexpected function expression.\");\n                }\n            }\n        };\n    }\n};\n"]}