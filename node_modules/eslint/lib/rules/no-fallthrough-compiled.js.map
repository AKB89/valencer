{"version":3,"sources":["no-fallthrough.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,IAAI,SAAS,QAAQ,QAAR,CAAb;;;;;;AAMA,IAAI,8BAA8B,mBAAlC;;;;;;;;;AASA,SAAS,qBAAT,CAA+B,IAA/B,EAAqC,OAArC,EAA8C,yBAA9C,EAAyE;AACrE,QAAI,aAAa,QAAQ,aAAR,EAAjB;AACA,QAAI,UAAU,OAAO,IAAP,CAAY,WAAW,WAAX,CAAuB,IAAvB,EAA6B,OAAzC,CAAd;;AAEA,WAAO,QAAQ,WAAW,0BAA0B,IAA1B,CAA+B,QAAQ,KAAvC,CAAnB,CAAP;AACH;;;;;;;AAOD,SAAS,WAAT,CAAqB,OAArB,EAA8B;AAC1B,WAAO,QAAQ,SAAf;AACH;;;;;;;;AAQD,SAAS,oBAAT,CAA8B,IAA9B,EAAoC,KAApC,EAA2C;AACvC,WAAO,MAAM,GAAN,CAAU,KAAV,CAAgB,IAAhB,GAAuB,KAAK,GAAL,CAAS,GAAT,CAAa,IAAb,GAAoB,CAAlD;AACH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,2CADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,gCAAgB;AACZ,0BAAM;AADM;AADR,aAFhB;AAOI,kCAAsB;AAP1B,SADI;AAPN,KADO;;AAqBb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAApC;AACA,YAAI,kBAAkB,IAAtB;AACA,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;;AAMA,YAAI,kBAAkB,IAAtB;AACA,YAAI,4BAA4B,IAAhC;;AAEA,YAAI,QAAQ,cAAZ,EAA4B;AACxB,wCAA4B,IAAI,MAAJ,CAAW,QAAQ,cAAnB,CAA5B;AACH,SAFD,MAEO;AACH,wCAA4B,2BAA5B;AACH;;AAED,eAAO;AACH,6BAAiB,UAAS,QAAT,EAAmB;AAChC,kCAAkB,QAAlB;AACH,aAHE;AAIH,2BAAe,YAAW;AACtB,kCAAkB,gBAAgB,KAAlC;AACH,aANE;;AAQH,wBAAY,UAAS,IAAT,EAAe;;;;;;AAMvB,oBAAI,mBAAmB,CAAC,sBAAsB,IAAtB,EAA4B,OAA5B,EAAqC,yBAArC,CAAxB,EAAyF;AACrF,4BAAQ,MAAR,CAAe;AACX,iCAAS,iDADE;AAEX,8BAAM,EAAC,MAAM,KAAK,IAAL,GAAY,MAAZ,GAAqB,SAA5B,EAFK;AAGX,8BAAM;AAHK,qBAAf;AAKH;AACD,kCAAkB,IAAlB;AACH,aAtBE;;AAwBH,+BAAmB,UAAS,IAAT,EAAe;AAC9B,oBAAI,YAAY,WAAW,aAAX,CAAyB,IAAzB,CAAhB;;;;;;;AAOA,oBAAI,gBAAgB,eAAhB,CAAgC,IAAhC,CAAqC,WAArC,MACC,KAAK,UAAL,CAAgB,MAAhB,GAAyB,CAAzB,IAA8B,qBAAqB,IAArB,EAA2B,SAA3B,CAD/B,KAEA,OAAO,IAAP,CAAY,KAAK,MAAL,CAAY,KAAxB,MAAmC,IAFvC,EAE6C;AACzC,sCAAkB,IAAlB;AACH;AACJ;AArCE,SAAP;AAuCH;AA9EY,CAAjB","file":"no-fallthrough-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag fall-through cases in switch statements.\n * @author Matt DuVall <http://mattduvall.com/>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar DEFAULT_FALLTHROUGH_COMMENT = /falls?\\s?through/i;\n\n/**\n * Checks whether or not a given node has a fallthrough comment.\n * @param {ASTNode} node - A SwitchCase node to get comments.\n * @param {RuleContext} context - A rule context which stores comments.\n * @param {RegExp} fallthroughCommentPattern - A pattern to match comment to.\n * @returns {boolean} `true` if the node has a valid fallthrough comment.\n */\nfunction hasFallthroughComment(node, context, fallthroughCommentPattern) {\n    var sourceCode = context.getSourceCode();\n    var comment = lodash.last(sourceCode.getComments(node).leading);\n\n    return Boolean(comment && fallthroughCommentPattern.test(comment.value));\n}\n\n/**\n * Checks whether or not a given code path segment is reachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Checks whether a node and a token are separated by blank lines\n * @param {ASTNode} node - The node to check\n * @param {Token} token - The token to compare against\n * @returns {boolean} `true` if there are blank lines between node and token\n */\nfunction hasBlankLinesBetween(node, token) {\n    return token.loc.start.line > node.loc.end.line + 1;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow fallthrough of `case` statements\",\n            category: \"Best Practices\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    commentPattern: {\n                        type: \"string\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = context.options[0] || {};\n        var currentCodePath = null;\n        var sourceCode = context.getSourceCode();\n\n        /*\n         * We need to use leading comments of the next SwitchCase node because\n         * trailing comments is wrong if semicolons are omitted.\n         */\n        var fallthroughCase = null;\n        var fallthroughCommentPattern = null;\n\n        if (options.commentPattern) {\n            fallthroughCommentPattern = new RegExp(options.commentPattern);\n        } else {\n            fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;\n        }\n\n        return {\n            onCodePathStart: function(codePath) {\n                currentCodePath = codePath;\n            },\n            onCodePathEnd: function() {\n                currentCodePath = currentCodePath.upper;\n            },\n\n            SwitchCase: function(node) {\n\n                /*\n                 * Checks whether or not there is a fallthrough comment.\n                 * And reports the previous fallthrough node if that does not exist.\n                 */\n                if (fallthroughCase && !hasFallthroughComment(node, context, fallthroughCommentPattern)) {\n                    context.report({\n                        message: \"Expected a 'break' statement before '{{type}}'.\",\n                        data: {type: node.test ? \"case\" : \"default\"},\n                        node: node\n                    });\n                }\n                fallthroughCase = null;\n            },\n\n            \"SwitchCase:exit\": function(node) {\n                var nextToken = sourceCode.getTokenAfter(node);\n\n                /*\n                 * `reachable` meant fall through because statements preceded by\n                 * `break`, `return`, or `throw` are unreachable.\n                 * And allows empty cases and the last case.\n                 */\n                if (currentCodePath.currentSegments.some(isReachable) &&\n                    (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) &&\n                    lodash.last(node.parent.cases) !== node) {\n                    fallthroughCase = node;\n                }\n            }\n        };\n    }\n};\n"]}