{"version":3,"sources":["no-unused-expressions.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,6BADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,mCAAmB;AACf,0BAAM;AADS,iBADX;AAIR,8BAAc;AACV,0BAAM;AADI;AAJN,aAFhB;AAUI,kCAAsB;AAV1B,SADI;AAPN,KADO;;AAwBb,YAAQ,gBAAS,OAAT,EAAkB;AACtB,YAAI,SAAS,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAAnC;YACI,oBAAoB,OAAO,iBAAP,IAA4B,KADpD;YAEI,eAAe,OAAO,YAAP,IAAuB,KAF1C;;;;;;AAQA,iBAAS,kBAAT,CAA4B,IAA5B,EAAkC;AAC9B,mBAAO,KAAK,IAAL,KAAc,qBAAd,IACH,KAAK,UAAL,CAAgB,IAAhB,KAAyB,SADtB,IACmC,OAAO,KAAK,UAAL,CAAgB,KAAvB,KAAiC,QAD3E;AAEH;;;;;;;AAOD,iBAAS,SAAT,CAAmB,SAAnB,EAA8B,IAA9B,EAAoC;AAChC,iBAAK,IAAI,IAAI,CAAR,EAAW,IAAI,KAAK,MAAzB,EAAiC,IAAI,CAArC,EAAwC,EAAE,CAA1C,EAA6C;AACzC,oBAAI,CAAC,UAAU,KAAK,CAAL,CAAV,CAAL,EAAyB;AACrB;AACH;AACJ;AACD,mBAAO,GAAG,KAAH,CAAS,IAAT,CAAc,IAAd,EAAoB,CAApB,EAAuB,CAAvB,CAAP;AACH;;;;;;AAMD,iBAAS,UAAT,CAAoB,IAApB,EAA0B;AACtB,mBAAO,UAAU,kBAAV,EAA8B,KAAK,IAAnC,CAAP;AACH;;;;;;;AAOD,iBAAS,WAAT,CAAqB,IAArB,EAA2B,SAA3B,EAAsC;AAClC,gBAAI,SAAS,UAAU,UAAU,MAAV,GAAmB,CAA7B,CAAb;gBACI,cAAc,UAAU,UAAU,MAAV,GAAmB,CAA7B,CADlB;;AAGA,mBAAO,CAAC,OAAO,IAAP,KAAgB,SAAhB,IAA6B,OAAO,IAAP,KAAgB,gBAAhB,IAC5B,WAAW,IAAX,CAAgB,YAAY,IAA5B,CADF,KAEC,WAAW,MAAX,EAAmB,OAAnB,CAA2B,IAA3B,KAAoC,CAF5C;AAGH;;;;;;;AAOD,iBAAS,iBAAT,CAA2B,IAA3B,EAAiC;AAC7B,gBAAI,YAAJ,EAAkB;;;AAGd,oBAAI,KAAK,IAAL,KAAc,uBAAlB,EAA2C;AACvC,2BAAO,kBAAkB,KAAK,UAAvB,KAAsC,kBAAkB,KAAK,SAAvB,CAA7C;AACH;AACJ;AACD,gBAAI,iBAAJ,EAAuB;AACnB,oBAAI,KAAK,IAAL,KAAc,mBAAlB,EAAuC;AACnC,2BAAO,kBAAkB,KAAK,KAAvB,CAAP;AACH;AACJ;;AAED,mBAAO,oDAAmD,IAAnD,CAAwD,KAAK,IAA7D,KACF,KAAK,IAAL,KAAc,iBAAd,IAAmC,CAAC,QAAD,EAAW,MAAX,EAAmB,OAAnB,CAA2B,KAAK,QAAhC,KAA6C;AADrF;AAEH;;AAED,eAAO;AACH,iCAAqB,6BAAS,IAAT,EAAe;AAChC,oBAAI,CAAC,kBAAkB,KAAK,UAAvB,CAAD,IAAuC,CAAC,YAAY,IAAZ,EAAkB,QAAQ,YAAR,EAAlB,CAA5C,EAAuF;AACnF,4BAAQ,MAAR,CAAe,IAAf,EAAqB,wEAArB;AACH;AACJ;AALE,SAAP;AAQH;AAzGY,CAAjB","file":"no-unused-expressions-compiled.js","sourcesContent":["/**\n * @fileoverview Flag expressions in statement position that do not side effect\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unused expressions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowShortCircuit: {\n                        type: \"boolean\"\n                    },\n                    allowTernary: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var config = context.options[0] || {},\n            allowShortCircuit = config.allowShortCircuit || false,\n            allowTernary = config.allowTernary || false;\n\n        /**\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node structurally represents a directive\n         */\n        function looksLikeDirective(node) {\n            return node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" && typeof node.expression.value === \"string\";\n        }\n\n        /**\n         * @param {Function} predicate - ([a] -> Boolean) the function used to make the determination\n         * @param {a[]} list - the input list\n         * @returns {a[]} the leading sequence of members in the given list that pass the given predicate\n         */\n        function takeWhile(predicate, list) {\n            for (var i = 0, l = list.length; i < l; ++i) {\n                if (!predicate(list[i])) {\n                    break;\n                }\n            }\n            return [].slice.call(list, 0, i);\n        }\n\n        /**\n         * @param {ASTNode} node - a Program or BlockStatement node\n         * @returns {ASTNode[]} the leading sequence of directive nodes in the given node's body\n         */\n        function directives(node) {\n            return takeWhile(looksLikeDirective, node.body);\n        }\n\n        /**\n         * @param {ASTNode} node - any node\n         * @param {ASTNode[]} ancestors - the given node's ancestors\n         * @returns {boolean} whether the given node is considered a directive in its current position\n         */\n        function isDirective(node, ancestors) {\n            var parent = ancestors[ancestors.length - 1],\n                grandparent = ancestors[ancestors.length - 2];\n\n            return (parent.type === \"Program\" || parent.type === \"BlockStatement\" &&\n                    (/Function/.test(grandparent.type))) &&\n                    directives(parent).indexOf(node) >= 0;\n        }\n\n        /**\n         * Determines whether or not a given node is a valid expression. Recurses on short circuit eval and ternary nodes if enabled by flags.\n         * @param {ASTNode} node - any node\n         * @returns {boolean} whether the given node is a valid expression\n         */\n        function isValidExpression(node) {\n            if (allowTernary) {\n\n                // Recursive check for ternary and logical expressions\n                if (node.type === \"ConditionalExpression\") {\n                    return isValidExpression(node.consequent) && isValidExpression(node.alternate);\n                }\n            }\n            if (allowShortCircuit) {\n                if (node.type === \"LogicalExpression\") {\n                    return isValidExpression(node.right);\n                }\n            }\n\n            return /^(?:Assignment|Call|New|Update|Yield)Expression$/.test(node.type) ||\n                (node.type === \"UnaryExpression\" && [\"delete\", \"void\"].indexOf(node.operator) >= 0);\n        }\n\n        return {\n            ExpressionStatement: function(node) {\n                if (!isValidExpression(node.expression) && !isDirective(node, context.getAncestors())) {\n                    context.report(node, \"Expected an assignment or function call and instead saw an expression.\");\n                }\n            }\n        };\n\n    }\n};\n"]}