{"version":3,"sources":["camelcase.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,qCADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,4BAAY;AACR,0BAAM,CAAC,QAAD,EAAW,OAAX;AADE;AADJ,aAFhB;AAOI,kCAAsB;AAP1B,SADI;AAPN,KADO;;AAqBb,YAAQ,UAAS,OAAT,EAAkB;;;;;;;AAOtB,YAAI,WAAW,EAAf;;;;;;;;AAQA,iBAAS,aAAT,CAAuB,IAAvB,EAA6B;;;AAGzB,mBAAO,KAAK,OAAL,CAAa,GAAb,IAAoB,CAAC,CAArB,IAA0B,SAAS,KAAK,WAAL,EAA1C;AACH;;;;;;;;AAQD,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,gBAAI,SAAS,OAAT,CAAiB,IAAjB,IAAyB,CAA7B,EAAgC;AAC5B,yBAAS,IAAT,CAAc,IAAd;AACA,wBAAQ,MAAR,CAAe,IAAf,EAAqB,6CAArB,EAAoE,EAAE,MAAM,KAAK,IAAb,EAApE;AACH;AACJ;;AAED,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAApC;YACI,aAAa,QAAQ,UAAR,IAAsB,EADvC;;AAGA,YAAI,eAAe,QAAf,IAA2B,eAAe,OAA9C,EAAuD;AACnD,yBAAa,QAAb;AACH;;AAED,eAAO;;AAEH,wBAAY,UAAS,IAAT,EAAe;;;;;;AAMvB,oBAAI,OAAO,KAAK,IAAL,CAAU,OAAV,CAAkB,UAAlB,EAA8B,EAA9B,CAAX;oBACI,kBAAmB,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAAtB,GAA4C,KAAK,MAAL,CAAY,MAAxD,GAAiE,KAAK,MAD5F;;;AAIA,oBAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAAzB,EAA6C;;;AAGzC,wBAAI,eAAe,OAAnB,EAA4B;AACxB;AACH;;;AAGD,wBAAI,KAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB,KAA4B,YAA5B,IACI,KAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB,KAA4B,KAAK,IADrC,IAEI,cAAc,IAAd,CAFR,EAE6B;AACzB,+BAAO,IAAP;;;AAGH,qBAND,MAMO,IAAI,gBAAgB,IAAhB,KAAyB,sBAAzB,IACH,cAAc,IAAd,CADG,KAEF,gBAAgB,KAAhB,CAAsB,IAAtB,KAA+B,kBAA/B,IACD,gBAAgB,IAAhB,CAAqB,IAArB,KAA8B,kBAA9B,IACA,gBAAgB,IAAhB,CAAqB,QAArB,CAA8B,IAA9B,KAAuC,KAAK,IAJzC,CAAJ,EAIoD;AACvD,mCAAO,IAAP;AACH;;;AAGJ,iBAvBD,MAuBO,IAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,UAAzB,EAAqC;;;AAGxC,4BAAI,eAAe,OAAnB,EAA4B;AACxB;AACH;;AAED,4BAAI,KAAK,MAAL,CAAY,MAAZ,IAAsB,KAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB,KAA4B,eAAlD,IACI,KAAK,MAAL,CAAY,GAAZ,KAAoB,IADxB,IACgC,KAAK,MAAL,CAAY,KAAZ,KAAsB,IAD1D,EACgE;AAC5D;AACH;;AAED,4BAAI,cAAc,IAAd,KAAuB,gBAAgB,IAAhB,KAAyB,gBAApD,EAAsE;AAClE,mCAAO,IAAP;AACH;;;AAGJ,qBAjBM,MAiBA,IAAI,cAAc,IAAd,KAAuB,gBAAgB,IAAhB,KAAyB,gBAApD,EAAsE;AACzE,mCAAO,IAAP;AACH;AACJ;;AAvDE,SAAP;AA2DH;AAzHY,CAAjB","file":"camelcase-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag non-camelcased identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce camelcase naming convention\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    properties: {\n                        enum: [\"always\", \"never\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // contains reported nodes to avoid reporting twice on destructuring with shorthand notation\n        var reported = [];\n\n        /**\n         * Checks if a string contains an underscore and isn't all upper-case\n         * @param {String} name The string to check.\n         * @returns {boolean} if the string is underscored\n         * @private\n         */\n        function isUnderscored(name) {\n\n            // if there's an underscore, it might be A_CONSTANT, which is okay\n            return name.indexOf(\"_\") > -1 && name !== name.toUpperCase();\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            if (reported.indexOf(node) < 0) {\n                reported.push(node);\n                context.report(node, \"Identifier '{{name}}' is not in camel case.\", { name: node.name });\n            }\n        }\n\n        var options = context.options[0] || {},\n            properties = options.properties || \"\";\n\n        if (properties !== \"always\" && properties !== \"never\") {\n            properties = \"always\";\n        }\n\n        return {\n\n            Identifier: function(node) {\n\n                /*\n                 * Leading and trailing underscores are commonly used to flag\n                 * private/protected identifiers, strip them\n                 */\n                var name = node.name.replace(/^_+|_+$/g, \"\"),\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    // Always report underscored object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                            node.parent.object.name === node.name &&\n                            isUnderscored(name)) {\n                        report(node);\n\n                    // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                            isUnderscored(name) &&\n                            (effectiveParent.right.type !== \"MemberExpression\" ||\n                            effectiveParent.left.type === \"MemberExpression\" &&\n                            effectiveParent.left.property.name === node.name)) {\n                        report(node);\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    // \"never\" check properties\n                    if (properties === \"never\") {\n                        return;\n                    }\n\n                    if (node.parent.parent && node.parent.parent.type === \"ObjectPattern\" &&\n                            node.parent.key === node && node.parent.value !== node) {\n                        return;\n                    }\n\n                    if (isUnderscored(name) && effectiveParent.type !== \"CallExpression\") {\n                        report(node);\n                    }\n\n                // Report anything that is underscored that isn't a CallExpression\n                } else if (isUnderscored(name) && effectiveParent.type !== \"CallExpression\") {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"]}