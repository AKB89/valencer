{"version":3,"sources":["no-sequences.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,0BADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;AAKA,YAAI,gBAAgB;AAChB,8BAAkB,MADF;AAEhB,yBAAa,MAFG;AAGhB,6BAAiB,cAHD;AAIhB,4BAAgB,MAJA;AAKhB,2BAAe,QALC;AAMhB,qCAAyB;;;;;;AANT,SAApB;;;;;;;;AAoBA,iBAAS,mBAAT,CAA6B,IAA7B,EAAmC;AAC/B,mBAAO,KAAK,MAAL,IAAe,cAAc,KAAK,MAAL,CAAY,IAA1B,CAAf,IACC,SAAS,KAAK,MAAL,CAAY,cAAc,KAAK,MAAL,CAAY,IAA1B,CAAZ,CADjB;AAEH;;;;;;;AAOD,iBAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3B,gBAAI,gBAAgB,WAAW,cAAX,CAA0B,IAA1B,CAApB;gBACI,YAAY,WAAW,aAAX,CAAyB,IAAzB,CADhB;;AAGA,mBAAO,iBAAiB,SAAjB,IACH,cAAc,KAAd,KAAwB,GADrB,IAC4B,cAAc,KAAd,CAAoB,CAApB,KAA0B,KAAK,KAAL,CAAW,CAAX,CADtD,IAEH,UAAU,KAAV,KAAoB,GAFjB,IAEwB,UAAU,KAAV,CAAgB,CAAhB,KAAsB,KAAK,KAAL,CAAW,CAAX,CAFrD;AAGH;;;;;;;AAOD,iBAAS,oBAAT,CAA8B,IAA9B,EAAoC;AAChC,gBAAI,gBAAgB,WAAW,cAAX,CAA0B,IAA1B,EAAgC,CAAhC,CAApB;gBACI,YAAY,WAAW,aAAX,CAAyB,IAAzB,EAA+B,CAA/B,CADhB;;AAGA,mBAAO,gBAAgB,IAAhB,KAAyB,aAAzB,IAA0C,SAA1C,IACH,cAAc,KAAd,KAAwB,GADrB,IAC4B,cAAc,KAAd,CAAoB,CAApB,KAA0B,KAAK,KAAL,CAAW,CAAX,CADtD,IAEH,UAAU,KAAV,KAAoB,GAFjB,IAEwB,UAAU,KAAV,CAAgB,CAAhB,KAAsB,KAAK,KAAL,CAAW,CAAX,CAFrD;AAGH;;AAED,eAAO;AACH,gCAAoB,UAAS,IAAT,EAAe;;;AAG/B,oBAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,cAArB,KACK,SAAS,KAAK,MAAL,CAAY,IAArB,IAA6B,SAAS,KAAK,MAAL,CAAY,MADvD,CAAJ,EACoE;AAChE;AACH;;;AAGD,oBAAI,oBAAoB,IAApB,CAAJ,EAA+B;AAC3B,wBAAI,qBAAqB,IAArB,CAAJ,EAAgC;AAC5B;AACH;AACJ,iBAJD,MAIO;AACH,wBAAI,gBAAgB,IAAhB,CAAJ,EAA2B;AACvB;AACH;AACJ;;AAED,oBAAI,QAAQ,WAAW,aAAX,CAAyB,KAAK,WAAL,CAAiB,CAAjB,CAAzB,CAAZ;;AAEA,wBAAQ,MAAR,CAAe,IAAf,EAAqB,MAAM,GAAN,CAAU,KAA/B,EAAsC,mCAAtC;AACH;AAvBE,SAAP;AA0BH;AAhGY,CAAjB","file":"no-sequences-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of comma operator\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow comma operators\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Parts of the grammar that are required to have parens.\n         */\n        var parenthesized = {\n            DoWhileStatement: \"test\",\n            IfStatement: \"test\",\n            SwitchStatement: \"discriminant\",\n            WhileStatement: \"test\",\n            WithStatement: \"object\",\n            ArrowFunctionExpression: \"body\"\n\n            // Omitting CallExpression - commas are parsed as argument separators\n            // Omitting NewExpression - commas are parsed as argument separators\n            // Omitting ForInStatement - parts aren't individually parenthesised\n            // Omitting ForStatement - parts aren't individually parenthesised\n        };\n\n        /**\n         * Determines whether a node is required by the grammar to be wrapped in\n         * parens, e.g. the test of an if statement.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if parens around node belong to parent node.\n         */\n        function requiresExtraParens(node) {\n            return node.parent && parenthesized[node.parent.type] &&\n                    node === node.parent[parenthesized[node.parent.type]];\n        }\n\n        /**\n         * Check if a node is wrapped in parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if the node has a paren on each side.\n         */\n        function isParenthesised(node) {\n            var previousToken = sourceCode.getTokenBefore(node),\n                nextToken = sourceCode.getTokenAfter(node);\n\n            return previousToken && nextToken &&\n                previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n                nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Check if a node is wrapped in two levels of parens.\n         * @param {ASTNode} node - The AST node\n         * @returns {boolean} True if two parens surround the node on each side.\n         */\n        function isParenthesisedTwice(node) {\n            var previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n                nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n        }\n\n        return {\n            SequenceExpression: function(node) {\n\n                // Always allow sequences in for statement update\n                if (node.parent.type === \"ForStatement\" &&\n                        (node === node.parent.init || node === node.parent.update)) {\n                    return;\n                }\n\n                // Wrapping a sequence in extra parens indicates intent\n                if (requiresExtraParens(node)) {\n                    if (isParenthesisedTwice(node)) {\n                        return;\n                    }\n                } else {\n                    if (isParenthesised(node)) {\n                        return;\n                    }\n                }\n\n                var child = sourceCode.getTokenAfter(node.expressions[0]);\n\n                context.report(node, child.loc.start, \"Unexpected use of comma operator.\");\n            }\n        };\n\n    }\n};\n"]}