{"version":3,"sources":["no-inner-declarations.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,4DADX;AAEF,sBAAU,iBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,CAAC,WAAD,EAAc,MAAd;AADV,SADI;AAPN,KADO;;AAeb,YAAQ,gBAAS,OAAT,EAAkB;;;;;;AAMtB,iBAAS,WAAT,GAAuB;AACnB,gBAAI,YAAY,QAAQ,YAAR,EAAhB;gBACI,WAAW,UAAU,GAAV,EADf;gBAEI,aAAa,CAFjB;;AAIA,mBAAO,YAAY,CAAC,SAAD,EAAY,qBAAZ,EACX,oBADW,EACW,yBADX,EAET,OAFS,CAED,SAAS,IAFR,IAEgB,CAFnC,EAEsC;AAClC,8BAAc,CAAd;AACA,2BAAW,UAAU,GAAV,EAAX;AACH;;AAED,mBAAO;;;AAGH,sBAAM,SAAS,IAHZ;;;AAMH,0BAAU;AANP,aAAP;AAQH;;;;;;;AAOD,iBAAS,KAAT,CAAe,IAAf,EAAqB;AACjB,gBAAI,OAAO,YAAY,IAAZ,CAAX;gBACI,QAAU,KAAK,IAAL,KAAc,SAAd,IAA2B,KAAK,QAAL,KAAkB,CAA9C,IACL,KAAK,QAAL,KAAkB,CAF1B;;AAIA,gBAAI,CAAC,KAAL,EAAY;AACR,wBAAQ,MAAR,CAAe,IAAf,EAAqB,6CAArB,EACI;AACI,0BAAO,KAAK,IAAL,KAAc,qBAAd,GACH,UADG,GACU,UAFrB;AAGI,0BAAO,KAAK,IAAL,KAAc,SAAd,GACH,SADG,GACS;AAJpB,iBADJ;AAQH;AACJ;;AAED,eAAO;;AAEH,iCAAqB,KAFlB;AAGH,iCAAqB,6BAAS,IAAT,EAAe;AAChC,oBAAI,QAAQ,OAAR,CAAgB,CAAhB,MAAuB,MAAvB,IAAiC,KAAK,IAAL,KAAc,KAAnD,EAA0D;AACtD,0BAAM,IAAN;AACH;AACJ;;AAPE,SAAP;AAWH;AA5EY,CAAjB","file":"no-inner-declarations-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to enforce declarations in program or function body root.\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `function` or `var` declarations in nested blocks\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: [\n            {\n                enum: [\"functions\", \"both\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        /**\n         * Find the nearest Program or Function ancestor node.\n         * @returns {Object} Ancestor's type and distance from node.\n         */\n        function nearestBody() {\n            var ancestors = context.getAncestors(),\n                ancestor = ancestors.pop(),\n                generation = 1;\n\n            while (ancestor && [\"Program\", \"FunctionDeclaration\",\n                    \"FunctionExpression\", \"ArrowFunctionExpression\"\n                    ].indexOf(ancestor.type) < 0) {\n                generation += 1;\n                ancestor = ancestors.pop();\n            }\n\n            return {\n\n                // Type of containing ancestor\n                type: ancestor.type,\n\n                // Separation between ancestor and node\n                distance: generation\n            };\n        }\n\n        /**\n         * Ensure that a given node is at a program or function body's root.\n         * @param {ASTNode} node Declaration node to check.\n         * @returns {void}\n         */\n        function check(node) {\n            var body = nearestBody(node),\n                valid = ((body.type === \"Program\" && body.distance === 1) ||\n                    body.distance === 2);\n\n            if (!valid) {\n                context.report(node, \"Move {{type}} declaration to {{body}} root.\",\n                    {\n                        type: (node.type === \"FunctionDeclaration\" ?\n                            \"function\" : \"variable\"),\n                        body: (body.type === \"Program\" ?\n                            \"program\" : \"function body\")\n                    }\n                );\n            }\n        }\n\n        return {\n\n            FunctionDeclaration: check,\n            VariableDeclaration: function(node) {\n                if (context.options[0] === \"both\" && node.kind === \"var\") {\n                    check(node);\n                }\n            }\n\n        };\n\n    }\n};\n"]}