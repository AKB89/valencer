{"version":3,"sources":["no-whitespace-before-property.js"],"names":[],"mappings":";;;;AAIA;;AAEA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,uCADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,iBAAS,YAPP;AAQF,gBAAQ;AARN,KADO;;AAYb,YAAQ,gBAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;;;;;;;;AAYA,iBAAS,kBAAT,CAA4B,IAA5B,EAAkC;AAC9B,gBAAI,QAAQ,WAAW,cAAX,CAA0B,KAAK,QAA/B,CAAZ;;AAEA,mBAAO,MAAM,KAAN,KAAgB,GAAvB,EAA4B;AACxB,wBAAQ,WAAW,cAAX,CAA0B,KAA1B,CAAR;AACH;AACD,mBAAO,KAAP;AACH;;;;;;;;;;AAUD,iBAAS,WAAT,CAAqB,IAArB,EAA2B,SAA3B,EAAsC,UAAtC,EAAkD;AAC9C,gBAAI,kBAAkB,KAAK,QAAL,GAAgB,EAAhB,GAAqB,GAA3C;;AAEA,oBAAQ,MAAR,CAAe;AACX,sBAAM,IADK;AAEX,yBAAS,qDAFE;AAGX,sBAAM;AACF,8BAAU,WAAW,OAAX,CAAmB,KAAK,QAAxB;AADR,iBAHK;AAMX,qBAAK,aAAS,KAAT,EAAgB;AACjB,2BAAO,MAAM,gBAAN,CAAuB,CAAC,UAAU,KAAV,CAAgB,CAAhB,CAAD,EAAqB,WAAW,KAAX,CAAiB,CAAjB,CAArB,CAAvB,EAAkE,eAAlE,CAAP;AACH;AARU,aAAf;AAUH;;;;;;AAMD,eAAO;AACH,8BAAkB,0BAAS,IAAT,EAAe;AAC7B,oBAAI,UAAJ;AACA,oBAAI,SAAJ;;AAEA,oBAAI,CAAC,SAAS,iBAAT,CAA2B,KAAK,MAAhC,EAAwC,KAAK,QAA7C,CAAL,EAA6D;AACzD;AACH;;AAED,oBAAI,KAAK,QAAT,EAAmB;AACf,iCAAa,mBAAmB,IAAnB,CAAb;AACA,gCAAY,WAAW,cAAX,CAA0B,UAA1B,CAAZ;AACH,iBAHD,MAGO;AACH,iCAAa,WAAW,aAAX,CAAyB,KAAK,QAA9B,CAAb;AACA,gCAAY,WAAW,cAAX,CAA0B,UAA1B,EAAsC,CAAtC,CAAZ;AACH;;AAED,oBAAI,WAAW,oBAAX,CAAgC,SAAhC,EAA2C,UAA3C,CAAJ,EAA4D;AACxD,gCAAY,IAAZ,EAAkB,SAAlB,EAA6B,UAA7B;AACH;AACJ;AApBE,SAAP;AAsBH;AAnFY,CAAjB","file":"no-whitespace-before-property-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to disallow whitespace before properties\n * @author Kai Cataldo\n */\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow whitespace before properties\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n        schema: []\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Finds opening bracket token of node's computed property\n         * @param {ASTNode} node - the node to check\n         * @returns {Token} opening bracket token of node's computed property\n         * @private\n         */\n        function findOpeningBracket(node) {\n            var token = sourceCode.getTokenBefore(node.property);\n\n            while (token.value !== \"[\") {\n                token = sourceCode.getTokenBefore(token);\n            }\n            return token;\n        }\n\n        /**\n         * Reports whitespace before property token\n         * @param {ASTNode} node - the node to report in the event of an error\n         * @param {Token} leftToken - the left token\n         * @param {Token} rightToken - the right token\n         * @returns {void}\n         * @private\n         */\n        function reportError(node, leftToken, rightToken) {\n            var replacementText = node.computed ? \"\" : \".\";\n\n            context.report({\n                node: node,\n                message: \"Unexpected whitespace before property {{propName}}.\",\n                data: {\n                    propName: sourceCode.getText(node.property)\n                },\n                fix: function(fixer) {\n                    return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);\n                }\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            MemberExpression: function(node) {\n                var rightToken;\n                var leftToken;\n\n                if (!astUtils.isTokenOnSameLine(node.object, node.property)) {\n                    return;\n                }\n\n                if (node.computed) {\n                    rightToken = findOpeningBracket(node);\n                    leftToken = sourceCode.getTokenBefore(rightToken);\n                } else {\n                    rightToken = sourceCode.getFirstToken(node.property);\n                    leftToken = sourceCode.getTokenBefore(rightToken, 1);\n                }\n\n                if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {\n                    reportError(node, leftToken, rightToken);\n                }\n            }\n        };\n    }\n};\n"]}