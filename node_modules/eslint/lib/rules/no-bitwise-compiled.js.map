{"version":3,"sources":["no-bitwise.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAKA,IAAI,oBAAoB,CACpB,GADoB,EACf,GADe,EACV,GADU,EACL,IADK,EACC,IADD,EACO,KADP,EAEpB,IAFoB,EAEd,IAFc,EAER,IAFQ,EAEF,KAFE,EAEK,KAFL,EAEY,MAFZ,EAGpB,GAHoB,CAAxB;;;;;;AAUA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,4BADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,uBAAO;AACH,0BAAM,OADH;AAEH,2BAAO;AACH,8BAAM;AADH,qBAFJ;AAKH,iCAAa;AALV,iBADC;AAQR,2BAAW;AACP,0BAAM;AADC;AARH,aAFhB;AAcI,kCAAsB;AAd1B,SADI;AAPN,KADO;;AA4Bb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAApC;AACA,YAAI,UAAU,QAAQ,KAAR,IAAiB,EAA/B;AACA,YAAI,YAAY,QAAQ,SAAR,KAAsB,IAAtC;;;;;;;AAOA,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,oBAAQ,MAAR,CAAe,IAAf,EAAqB,mCAArB,EAA0D,EAAE,UAAU,KAAK,QAAjB,EAA1D;AACH;;;;;;;AAOD,iBAAS,kBAAT,CAA4B,IAA5B,EAAkC;AAC9B,mBAAO,kBAAkB,OAAlB,CAA0B,KAAK,QAA/B,MAA6C,CAAC,CAArD;AACH;;;;;;;AAOD,iBAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3B,mBAAO,QAAQ,OAAR,CAAgB,KAAK,QAArB,MAAmC,CAAC,CAA3C;AACH;;;;;;;AAOD,iBAAS,WAAT,CAAqB,IAArB,EAA2B;AACvB,mBAAO,aAAa,KAAK,QAAL,KAAkB,GAA/B,IAAsC,KAAK,KAA3C,IACL,KAAK,KAAL,CAAW,IAAX,KAAoB,SADf,IAC4B,KAAK,KAAL,CAAW,KAAX,KAAqB,CADxD;AAEH;;;;;;;AAOD,iBAAS,2BAAT,CAAqC,IAArC,EAA2C;AACvC,gBAAI,mBAAmB,IAAnB,KAA4B,CAAC,gBAAgB,IAAhB,CAA7B,IAAsD,CAAC,YAAY,IAAZ,CAA3D,EAA8E;AAC1E,uBAAO,IAAP;AACH;AACJ;;AAED,eAAO;AACH,kCAAsB,2BADnB;AAEH,8BAAkB,2BAFf;AAGH,6BAAiB;AAHd,SAAP;AAMH;AAvFY,CAAjB","file":"no-bitwise-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag bitwise identifiers\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//\n// Set of bitwise operators.\n//\nvar BITWISE_OPERATORS = [\n    \"^\", \"|\", \"&\", \"<<\", \">>\", \">>>\",\n    \"^=\", \"|=\", \"&=\", \"<<=\", \">>=\", \">>>=\",\n    \"~\"\n];\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow bitwise operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allow: {\n                        type: \"array\",\n                        items: {\n                            enum: BITWISE_OPERATORS\n                        },\n                        uniqueItems: true\n                    },\n                    int32Hint: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = context.options[0] || {};\n        var allowed = options.allow || [];\n        var int32Hint = options.int32Hint === true;\n\n        /**\n         * Reports an unexpected use of a bitwise operator.\n         * @param   {ASTNode} node Node which contains the bitwise operator.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report(node, \"Unexpected use of '{{operator}}'.\", { operator: node.operator });\n        }\n\n        /**\n         * Checks if the given node has a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function hasBitwiseOperator(node) {\n            return BITWISE_OPERATORS.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if exceptions were provided, e.g. `{ allow: ['~', '|'] }`.\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} Whether or not the node has a bitwise operator.\n         */\n        function allowedOperator(node) {\n            return allowed.indexOf(node.operator) !== -1;\n        }\n\n        /**\n         * Checks if the given bitwise operator is used for integer typecasting, i.e. \"|0\"\n         * @param   {ASTNode} node The node to check.\n         * @returns {boolean} whether the node is used in integer typecasting.\n         */\n        function isInt32Hint(node) {\n            return int32Hint && node.operator === \"|\" && node.right &&\n              node.right.type === \"Literal\" && node.right.value === 0;\n        }\n\n        /**\n         * Report if the given node contains a bitwise operator.\n         * @param   {ASTNode} node The node to check.\n         * @returns {void}\n         */\n        function checkNodeForBitwiseOperator(node) {\n            if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {\n                report(node);\n            }\n        }\n\n        return {\n            AssignmentExpression: checkNodeForBitwiseOperator,\n            BinaryExpression: checkNodeForBitwiseOperator,\n            UnaryExpression: checkNodeForBitwiseOperator\n        };\n\n    }\n};\n"]}