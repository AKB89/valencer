{"version":3,"sources":["no-lone-blocks.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,oCADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;;;AAGtB,YAAI,aAAa,EAAjB;YACI,OADJ;;;;;;;AAQA,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,gBAAI,SAAS,QAAQ,YAAR,GAAuB,GAAvB,EAAb;;AAEA,oBAAQ,MAAR,CAAe,IAAf,EAAqB,OAAO,IAAP,KAAgB,SAAhB,GACjB,qBADiB,GAEjB,4BAFJ;AAIH;;;;;;AAMD,iBAAS,WAAT,GAAuB;AACnB,gBAAI,SAAS,QAAQ,YAAR,GAAuB,GAAvB,EAAb;;AAEA,mBAAO,OAAO,IAAP,KAAgB,gBAAhB,IAAoC,OAAO,IAAP,KAAgB,SAA3D;AACH;;;;;;;AAOD,iBAAS,aAAT,GAAyB;AACrB,gBAAI,WAAW,MAAX,KAAsB,CAA1B,EAA6B;AACzB;AACH;;AAED,gBAAI,QAAQ,QAAQ,YAAR,GAAuB,GAAvB,EAAZ;;AAEA,gBAAI,WAAW,WAAW,MAAX,GAAoB,CAA/B,MAAsC,KAA1C,EAAiD;AAC7C,2BAAW,GAAX;AACH;AACJ;;;AAGD,kBAAU;AACN,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,YAAY,IAAZ,CAAJ,EAAuB;AACnB,2BAAO,IAAP;AACH;AACJ;AALK,SAAV;;;AASA,YAAI,QAAQ,aAAR,CAAsB,WAAtB,IAAqC,CAAzC,EAA4C;AACxC,sBAAU;AACN,gCAAgB,UAAS,IAAT,EAAe;AAC3B,wBAAI,YAAY,IAAZ,CAAJ,EAAuB;AACnB,mCAAW,IAAX,CAAgB,IAAhB;AACH;AACJ,iBALK;AAMN,uCAAuB,UAAS,IAAT,EAAe;AAClC,wBAAI,WAAW,MAAX,GAAoB,CAApB,IAAyB,WAAW,WAAW,MAAX,GAAoB,CAA/B,MAAsC,IAAnE,EAAyE;AACrE,mCAAW,GAAX;AACA,+BAAO,IAAP;AACH;AACJ;AAXK,aAAV;;AAcA,oBAAQ,mBAAR,GAA8B,UAAS,IAAT,EAAe;AACzC,oBAAI,KAAK,IAAL,KAAc,KAAd,IAAuB,KAAK,IAAL,KAAc,OAAzC,EAAkD;AAC9C,kCAAc,IAAd;AACH;AACJ,aAJD;;AAMA,oBAAQ,mBAAR,GAA8B,UAAS,IAAT,EAAe;AACzC,oBAAI,QAAQ,QAAR,GAAmB,QAAvB,EAAiC;AAC7B,kCAAc,IAAd;AACH;AACJ,aAJD;;AAMA,oBAAQ,gBAAR,GAA2B,aAA3B;AACH;;AAED,eAAO,OAAP;AACH;AAnGY,CAAjB","file":"no-lone-blocks-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag blocks with no reason to exist\n * @author Brandon Mills\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary nested blocks\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n\n        // A stack of lone blocks to be checked for block-level bindings\n        var loneBlocks = [],\n            ruleDef;\n\n        /**\n         * Reports a node as invalid.\n         * @param {ASTNode} node - The node to be reported.\n         * @returns {void}\n        */\n        function report(node) {\n            var parent = context.getAncestors().pop();\n\n            context.report(node, parent.type === \"Program\" ?\n                \"Block is redundant.\" :\n                \"Nested block is redundant.\"\n            );\n        }\n\n        /**\n         * Checks for any ocurrence of BlockStatement > BlockStatement or Program > BlockStatement\n         * @returns {boolean} True if the current node is a lone block.\n        */\n        function isLoneBlock() {\n            var parent = context.getAncestors().pop();\n\n            return parent.type === \"BlockStatement\" || parent.type === \"Program\";\n        }\n\n        /**\n         * Checks the enclosing block of the current node for block-level bindings,\n         * and \"marks it\" as valid if any.\n         * @returns {void}\n        */\n        function markLoneBlock() {\n            if (loneBlocks.length === 0) {\n                return;\n            }\n\n            var block = context.getAncestors().pop();\n\n            if (loneBlocks[loneBlocks.length - 1] === block) {\n                loneBlocks.pop();\n            }\n        }\n\n        // Default rule definition: report all lone blocks\n        ruleDef = {\n            BlockStatement: function(node) {\n                if (isLoneBlock(node)) {\n                    report(node);\n                }\n            }\n        };\n\n        // ES6: report blocks without block-level bindings\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDef = {\n                BlockStatement: function(node) {\n                    if (isLoneBlock(node)) {\n                        loneBlocks.push(node);\n                    }\n                },\n                \"BlockStatement:exit\": function(node) {\n                    if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {\n                        loneBlocks.pop();\n                        report(node);\n                    }\n                }\n            };\n\n            ruleDef.VariableDeclaration = function(node) {\n                if (node.kind === \"let\" || node.kind === \"const\") {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.FunctionDeclaration = function(node) {\n                if (context.getScope().isStrict) {\n                    markLoneBlock(node);\n                }\n            };\n\n            ruleDef.ClassDeclaration = markLoneBlock;\n        }\n\n        return ruleDef;\n    }\n};\n"]}