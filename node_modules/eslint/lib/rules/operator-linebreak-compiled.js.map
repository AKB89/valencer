{"version":3,"sources":["operator-linebreak.js"],"names":[],"mappings":"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","file":"operator-linebreak-compiled.js","sourcesContent":["/**\n * @fileoverview Operator linebreak - enforces operator linebreak style of two types: after and before\n * @author Beno√Æt Zugmeyer\n */\n\n\"use strict\";\n\nvar lodash = require(\"lodash\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent linebreak style for operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"after\", \"before\", \"none\", null]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    overrides: {\n                        type: \"object\",\n                        properties: {\n                            anyOf: {\n                                type: \"string\",\n                                enum: [\"after\", \"before\", \"none\", \"ignore\"]\n                            }\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var usedDefaultGlobal = !context.options[0];\n        var globalStyle = context.options[0] || \"after\";\n        var options = context.options[1] || {};\n        var styleOverrides = options.overrides ? lodash.assign({}, options.overrides) : {};\n\n        if (usedDefaultGlobal && !styleOverrides[\"?\"]) {\n            styleOverrides[\"?\"] = \"before\";\n        }\n\n        if (usedDefaultGlobal && !styleOverrides[\":\"]) {\n            styleOverrides[\":\"] = \"before\";\n        }\n\n        var sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Checks the operator placement\n         * @param {ASTNode} node The node to check\n         * @param {ASTNode} leftSide The node that comes before the operator in `node`\n         * @private\n         * @returns {void}\n         */\n        function validateNode(node, leftSide) {\n            var leftToken = sourceCode.getLastToken(leftSide);\n            var operatorToken = sourceCode.getTokenAfter(leftToken);\n\n            // When the left part of a binary expression is a single expression wrapped in\n            // parentheses (ex: `(a) + b`), leftToken will be the last token of the expression\n            // and operatorToken will be the closing parenthesis.\n            // The leftToken should be the last closing parenthesis, and the operatorToken\n            // should be the token right after that.\n            while (operatorToken.value === \")\") {\n                leftToken = operatorToken;\n                operatorToken = sourceCode.getTokenAfter(operatorToken);\n            }\n\n            var rightToken = sourceCode.getTokenAfter(operatorToken);\n            var operator = operatorToken.value;\n            var operatorStyleOverride = styleOverrides[operator];\n            var style = operatorStyleOverride || globalStyle;\n\n            // if single line\n            if (astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                return;\n\n            } else if (operatorStyleOverride !== \"ignore\" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) &&\n                    !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                // lone operator\n                context.report(node, {\n                    line: operatorToken.loc.end.line,\n                    column: operatorToken.loc.end.column\n                }, \"Bad line breaking before and after '\" + operator + \"'.\");\n\n            } else if (style === \"before\" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {\n\n                context.report(node, {\n                    line: operatorToken.loc.end.line,\n                    column: operatorToken.loc.end.column\n                }, \"'\" + operator + \"' should be placed at the beginning of the line.\");\n\n            } else if (style === \"after\" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {\n\n                context.report(node, {\n                    line: operatorToken.loc.end.line,\n                    column: operatorToken.loc.end.column\n                }, \"'\" + operator + \"' should be placed at the end of the line.\");\n\n            } else if (style === \"none\") {\n\n                context.report(node, {\n                    line: operatorToken.loc.end.line,\n                    column: operatorToken.loc.end.column\n                }, \"There should be no line break before or after '\" + operator + \"'\");\n\n            }\n        }\n\n        /**\n         * Validates a binary expression using `validateNode`\n         * @param {BinaryExpression|LogicalExpression|AssignmentExpression} node node to be validated\n         * @returns {void}\n         */\n        function validateBinaryExpression(node) {\n            validateNode(node, node.left);\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: validateBinaryExpression,\n            LogicalExpression: validateBinaryExpression,\n            AssignmentExpression: validateBinaryExpression,\n            VariableDeclarator: function(node) {\n                if (node.init) {\n                    validateNode(node, node.id);\n                }\n            },\n            ConditionalExpression: function(node) {\n                validateNode(node, node.test);\n                validateNode(node, node.consequent);\n            }\n        };\n    }\n};\n"]}