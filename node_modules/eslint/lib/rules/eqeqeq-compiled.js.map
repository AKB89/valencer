{"version":3,"sources":["eqeqeq.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,oCADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,CAAC,OAAD,EAAU,YAAV;AADV,SADI;AAPN,KADO;;AAeb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;;;AAOA,iBAAS,QAAT,CAAkB,IAAlB,EAAwB;AACpB,mBAAO,KAAK,IAAL,KAAc,iBAAd,IAAmC,KAAK,QAAL,KAAkB,QAA5D;AACH;;;;;;;;AAQD,iBAAS,cAAT,CAAwB,IAAxB,EAA8B;AAC1B,mBAAO,SAAS,KAAK,IAAd,KAAuB,SAAS,KAAK,KAAd,CAA9B;AACH;;;;;;;;AAQD,iBAAS,sBAAT,CAAgC,IAAhC,EAAsC;AAClC,mBAAO,KAAK,IAAL,CAAU,IAAV,KAAmB,SAAnB,IAAgC,KAAK,KAAL,CAAW,IAAX,KAAoB,SAApD,IACC,OAAO,KAAK,IAAL,CAAU,KAAjB,KAA2B,OAAO,KAAK,KAAL,CAAW,KADrD;AAEH;;;;;;;;AAQD,iBAAS,WAAT,CAAqB,IAArB,EAA2B;AACvB,mBAAQ,KAAK,KAAL,CAAW,IAAX,KAAoB,SAApB,IAAiC,KAAK,KAAL,CAAW,KAAX,KAAqB,IAAvD,IACE,KAAK,IAAL,CAAU,IAAV,KAAmB,SAAnB,IAAgC,KAAK,IAAL,CAAU,KAAV,KAAoB,IAD7D;AAEH;;;;;;;;;AASD,iBAAS,mBAAT,CAA6B,IAA7B,EAAmC;AAC/B,gBAAI,UAAU,WAAW,aAAX,CAAyB,KAAK,IAA9B,CAAd;;AAEA,mBAAO,EAAC,MAAM,QAAQ,GAAR,CAAY,KAAZ,CAAkB,IAAzB,EAA+B,QAAQ,QAAQ,GAAR,CAAY,KAAZ,CAAkB,MAAzD,EAAP;AACH;;AAED,eAAO;AACH,8BAAkB,UAAS,IAAT,EAAe;AAC7B,oBAAI,KAAK,QAAL,KAAkB,IAAlB,IAA0B,KAAK,QAAL,KAAkB,IAAhD,EAAsD;AAClD;AACH;;AAED,oBAAI,QAAQ,OAAR,CAAgB,CAAhB,MAAuB,OAAvB,KAAmC,eAAe,IAAf,KAC/B,uBAAuB,IAAvB,CAD+B,IACC,YAAY,IAAZ,CADpC,CAAJ,EAC4D;AACxD;AACH;;AAED,oBAAI,QAAQ,OAAR,CAAgB,CAAhB,MAAuB,YAAvB,IAAuC,YAAY,IAAZ,CAA3C,EAA8D;AAC1D;AACH;;AAED,wBAAQ,MAAR,CAAe;AACX,0BAAM,IADK;AAEX,yBAAK,oBAAoB,IAApB,CAFM;AAGX,6BAAS,8CAHE;AAIX,0BAAM,EAAE,IAAI,KAAK,QAAX;AAJK,iBAAf;AAOH;AAtBE,SAAP;AAyBH;AAjGY,CAAjB","file":"eqeqeq-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag statements that use != and == instead of !== and ===\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require the use of `===` and `!==`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"smart\", \"allow-null\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Checks if an expression is a typeof expression\n         * @param  {ASTNode} node The node to check\n         * @returns {boolean} if the node is a typeof expression\n         */\n        function isTypeOf(node) {\n            return node.type === \"UnaryExpression\" && node.operator === \"typeof\";\n        }\n\n        /**\n         * Checks if either operand of a binary expression is a typeof operation\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if one of the operands is typeof\n         * @private\n         */\n        function isTypeOfBinary(node) {\n            return isTypeOf(node.left) || isTypeOf(node.right);\n        }\n\n        /**\n         * Checks if operands are literals of the same type (via typeof)\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are of same type\n         * @private\n         */\n        function areLiteralsAndSameType(node) {\n            return node.left.type === \"Literal\" && node.right.type === \"Literal\" &&\n                    typeof node.left.value === typeof node.right.value;\n        }\n\n        /**\n         * Checks if one of the operands is a literal null\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} if operands are null\n         * @private\n         */\n        function isNullCheck(node) {\n            return (node.right.type === \"Literal\" && node.right.value === null) ||\n                    (node.left.type === \"Literal\" && node.left.value === null);\n        }\n\n        /**\n         * Gets the location (line and column) of the binary expression's operator\n         * @param {ASTNode} node The binary expression node to check\n         * @param {String} operator The operator to find\n         * @returns {Object} { line, column } location of operator\n         * @private\n         */\n        function getOperatorLocation(node) {\n            var opToken = sourceCode.getTokenAfter(node.left);\n\n            return {line: opToken.loc.start.line, column: opToken.loc.start.column};\n        }\n\n        return {\n            BinaryExpression: function(node) {\n                if (node.operator !== \"==\" && node.operator !== \"!=\") {\n                    return;\n                }\n\n                if (context.options[0] === \"smart\" && (isTypeOfBinary(node) ||\n                        areLiteralsAndSameType(node) || isNullCheck(node))) {\n                    return;\n                }\n\n                if (context.options[0] === \"allow-null\" && isNullCheck(node)) {\n                    return;\n                }\n\n                context.report({\n                    node: node,\n                    loc: getOperatorLocation(node),\n                    message: \"Expected '{{op}}=' and instead saw '{{op}}'.\",\n                    data: { op: node.operator }\n                });\n\n            }\n        };\n\n    }\n};\n"]}