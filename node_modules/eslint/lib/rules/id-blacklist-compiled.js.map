{"version":3,"sources":["id-blacklist.js"],"names":[],"mappings":";;;;;;AAMA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,gCADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AACJ,kBAAM,OADF;AAEJ,mBAAO;AACH,sBAAM;AADH,aAFH;AAKJ,yBAAa;AALT;AAPN,KADO;;AAiBb,YAAQ,UAAS,OAAT,EAAkB;;;;;;AAOtB,YAAI,YAAY,QAAQ,OAAxB;;;;;;;;AASA,iBAAS,SAAT,CAAmB,IAAnB,EAAyB;AACrB,mBAAO,UAAU,OAAV,CAAkB,IAAlB,MAA4B,CAAC,CAApC;AACH;;;;;;;;;AASD,iBAAS,YAAT,CAAsB,eAAtB,EAAuC,IAAvC,EAA6C;AACzC,mBAAO,gBAAgB,IAAhB,KAAyB,gBAAzB,IACA,gBAAgB,IAAhB,KAAyB,eADzB,IAEH,UAAU,IAAV,CAFJ;AAGH;;;;;;;;AAQD,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,oBAAQ,MAAR,CAAe,IAAf,EAAqB,sCAArB,EAA6D;AACzD,sBAAM,KAAK;AAD8C,aAA7D;AAGH;;AAED,eAAO;;AAEH,wBAAY,UAAS,IAAT,EAAe;AACvB,oBAAI,OAAO,KAAK,IAAhB;oBACI,kBAAmB,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAAtB,GAA4C,KAAK,MAAL,CAAY,MAAxD,GAAiE,KAAK,MAD5F;;;AAIA,oBAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAAzB,EAA6C;;;AAGzC,wBAAI,KAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB,KAA4B,YAA5B,IACA,KAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB,KAA4B,KAAK,IADrC,EAC2C;AACvC,4BAAI,UAAU,IAAV,CAAJ,EAAqB;AACjB,mCAAO,IAAP;AACH;;;AAGJ,qBAPD,MAOO,IAAI,gBAAgB,IAAhB,KAAyB,sBAAzB,KACN,gBAAgB,KAAhB,CAAsB,IAAtB,KAA+B,kBAA/B,IACD,gBAAgB,IAAhB,CAAqB,IAArB,KAA8B,kBAA9B,IACA,gBAAgB,IAAhB,CAAqB,QAArB,CAA8B,IAA9B,KAAuC,KAAK,IAHrC,CAAJ,EAGgD;AACnD,gCAAI,UAAU,IAAV,CAAJ,EAAqB;AACjB,uCAAO,IAAP;AACH;AACJ;;;AAGJ,iBApBD,MAoBO,IAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,UAAzB,EAAqC;;AAExC,4BAAI,aAAa,eAAb,EAA8B,IAA9B,CAAJ,EAAyC;AACrC,mCAAO,IAAP;AACH;;;AAGJ,qBAPM,MAOA,IAAI,aAAa,eAAb,EAA8B,IAA9B,CAAJ,EAAyC;AAC5C,mCAAO,IAAP;AACH;AACJ;;AArCE,SAAP;AAyCH;AAvGY,CAAjB","file":"id-blacklist-compiled.js","sourcesContent":["/**\n * @fileoverview Rule that warns when identifier names that are\n * blacklisted in the configuration are used.\n * @author Keith Cirkel (http://keithcirkel.co.uk)\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified identifiers\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: {\n            type: \"array\",\n            items: {\n                type: \"string\"\n            },\n            uniqueItems: true\n        }\n    },\n\n    create: function(context) {\n\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        var blacklist = context.options;\n\n\n        /**\n         * Checks if a string matches the provided pattern\n         * @param {String} name The string to check.\n         * @returns {boolean} if the string is a match\n         * @private\n         */\n        function isInvalid(name) {\n            return blacklist.indexOf(name) !== -1;\n        }\n\n        /**\n         * Verifies if we should report an error or not based on the effective\n         * parent node and the identifier name.\n         * @param {ASTNode} effectiveParent The effective parent node of the node to be reported\n         * @param {String} name The identifier name of the identifier node\n         * @returns {boolean} whether an error should be reported or not\n         */\n        function shouldReport(effectiveParent, name) {\n            return effectiveParent.type !== \"CallExpression\"\n                && effectiveParent.type !== \"NewExpression\" &&\n                isInvalid(name);\n        }\n\n        /**\n         * Reports an AST node as a rule violation.\n         * @param {ASTNode} node The node to report.\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            context.report(node, \"Identifier '{{name}}' is blacklisted\", {\n                name: node.name\n            });\n        }\n\n        return {\n\n            Identifier: function(node) {\n                var name = node.name,\n                    effectiveParent = (node.parent.type === \"MemberExpression\") ? node.parent.parent : node.parent;\n\n                // MemberExpressions get special rules\n                if (node.parent.type === \"MemberExpression\") {\n\n                    // Always check object names\n                    if (node.parent.object.type === \"Identifier\" &&\n                        node.parent.object.name === node.name) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n\n                        // Report AssignmentExpressions only if they are the left side of the assignment\n                    } else if (effectiveParent.type === \"AssignmentExpression\" &&\n                        (effectiveParent.right.type !== \"MemberExpression\" ||\n                        effectiveParent.left.type === \"MemberExpression\" &&\n                        effectiveParent.left.property.name === node.name)) {\n                        if (isInvalid(name)) {\n                            report(node);\n                        }\n                    }\n\n                // Properties have their own rules\n                } else if (node.parent.type === \"Property\") {\n\n                    if (shouldReport(effectiveParent, name)) {\n                        report(node);\n                    }\n\n                // Report anything that is a match and not a CallExpression\n                } else if (shouldReport(effectiveParent, name)) {\n                    report(node);\n                }\n            }\n\n        };\n\n    }\n};\n"]}