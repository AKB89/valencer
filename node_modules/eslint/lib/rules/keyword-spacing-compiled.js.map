{"version":3,"sources":["keyword-spacing.js"],"names":[],"mappings":"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","file":"keyword-spacing-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to enforce spacing before and after keywords.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\"),\n    keywords = require(\"../util/keywords\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nvar PREV_TOKEN = /^[\\)\\]\\}>]$/;\nvar NEXT_TOKEN = /^(?:[\\(\\[\\{<~!]|\\+\\+?|--?)$/;\nvar PREV_TOKEN_M = /^[\\)\\]\\}>*]$/;\nvar NEXT_TOKEN_M = /^[\\{*]$/;\nvar TEMPLATE_OPEN_PAREN = /\\$\\{$/;\nvar TEMPLATE_CLOSE_PAREN = /^\\}/;\nvar CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/;\nvar KEYS = keywords.concat([\"as\", \"await\", \"from\", \"get\", \"let\", \"of\", \"set\", \"yield\"]);\n\n// check duplications.\n(function() {\n    KEYS.sort();\n    for (var i = 1; i < KEYS.length; ++i) {\n        if (KEYS[i] === KEYS[i - 1]) {\n            throw new Error(\"Duplication was found in the keyword list: \" + KEYS[i]);\n        }\n    }\n}());\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given token is a \"Template\" token ends with \"${\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token ends with \"${\".\n */\nfunction isOpenParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_OPEN_PAREN.test(token.value);\n}\n\n/**\n * Checks whether or not a given token is a \"Template\" token starts with \"}\".\n *\n * @param {Token} token - A token to check.\n * @returns {boolean} `true` if the token is a \"Template\" token starts with \"}\".\n */\nfunction isCloseParenOfTemplate(token) {\n    return token.type === \"Template\" && TEMPLATE_CLOSE_PAREN.test(token.value);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before and after keywords\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    before: {type: \"boolean\"},\n                    after: {type: \"boolean\"},\n                    overrides: {\n                        type: \"object\",\n                        properties: KEYS.reduce(function(retv, key) {\n                            retv[key] = {\n                                type: \"object\",\n                                properties: {\n                                    before: {type: \"boolean\"},\n                                    after: {type: \"boolean\"}\n                                },\n                                additionalProperties: false\n                            };\n                            return retv;\n                        }, {}),\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Reports a given token if there are not space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function expectSpaceBefore(token, pattern) {\n            pattern = pattern || PREV_TOKEN;\n\n            var prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                !sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Expected space(s) before \\\"{{value}}\\\".\",\n                    data: token,\n                    fix: function(fixer) {\n                        return fixer.insertTextBefore(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) before the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceBefore(token, pattern) {\n            pattern = pattern || PREV_TOKEN;\n\n            var prevToken = sourceCode.getTokenBefore(token);\n\n            if (prevToken &&\n                (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) &&\n                !isOpenParenOfTemplate(prevToken) &&\n                astUtils.isTokenOnSameLine(prevToken, token) &&\n                sourceCode.isSpaceBetweenTokens(prevToken, token)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Unexpected space(s) before \\\"{{value}}\\\".\",\n                    data: token,\n                    fix: function(fixer) {\n                        return fixer.removeRange([prevToken.range[1], token.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are not space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function expectSpaceAfter(token, pattern) {\n            pattern = pattern || NEXT_TOKEN;\n\n            var nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                !sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Expected space(s) after \\\"{{value}}\\\".\",\n                    data: token,\n                    fix: function(fixer) {\n                        return fixer.insertTextAfter(token, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports a given token if there are space(s) after the token.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function unexpectSpaceAfter(token, pattern) {\n            pattern = pattern || NEXT_TOKEN;\n\n            var nextToken = sourceCode.getTokenAfter(token);\n\n            if (nextToken &&\n                (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) &&\n                !isCloseParenOfTemplate(nextToken) &&\n                astUtils.isTokenOnSameLine(token, nextToken) &&\n                sourceCode.isSpaceBetweenTokens(token, nextToken)\n            ) {\n                context.report({\n                    loc: token.loc.start,\n                    message: \"Unexpected space(s) after \\\"{{value}}\\\".\",\n                    data: token,\n                    fix: function(fixer) {\n                        return fixer.removeRange([token.range[1], nextToken.range[0]]);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Parses the option object and determines check methods for each keyword.\n         *\n         * @param {object|undefined} options - The option object to parse.\n         * @returns {object} - Normalized option object.\n         *      Keys are keywords (there are for every keyword).\n         *      Values are instances of `{\"before\": function, \"after\": function}`.\n         */\n        function parseOptions(options) {\n            var before = !options || options.before !== false;\n            var after = !options || options.after !== false;\n            var defaultValue = {\n                before: before ? expectSpaceBefore : unexpectSpaceBefore,\n                after: after ? expectSpaceAfter : unexpectSpaceAfter\n            };\n            var overrides = (options && options.overrides) || {};\n            var retv = Object.create(null);\n\n            for (var i = 0; i < KEYS.length; ++i) {\n                var key = KEYS[i];\n                var override = overrides[key];\n\n                if (override) {\n                    var thisBefore = (\"before\" in override) ? override.before : before;\n                    var thisAfter = (\"after\" in override) ? override.after : after;\n\n                    retv[key] = {\n                        before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,\n                        after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter\n                    };\n                } else {\n                    retv[key] = defaultValue;\n                }\n            }\n\n            return retv;\n        }\n\n        var checkMethodMap = parseOptions(context.options[0]);\n\n        /**\n         * Reports a given token if usage of spacing followed by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the previous\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingBefore(token, pattern) {\n            checkMethodMap[token.value].before(token, pattern);\n        }\n\n        /**\n         * Reports a given token if usage of spacing preceded by the token is\n         * invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @param {RegExp|undefined} pattern - Optional. A pattern of the next\n         *      token to check.\n         * @returns {void}\n         */\n        function checkSpacingAfter(token, pattern) {\n            checkMethodMap[token.value].after(token, pattern);\n        }\n\n        /**\n         * Reports a given token if usage of spacing around the token is invalid.\n         *\n         * @param {Token} token - A token to report.\n         * @returns {void}\n         */\n        function checkSpacingAround(token) {\n            checkSpacingBefore(token);\n            checkSpacingAfter(token);\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundFirstToken(node) {\n            var firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingAround(firstToken);\n            }\n        }\n\n        /**\n         * Reports the first token of a given node if the first token is a keyword\n         * and usage of spacing followed by the token is invalid.\n         *\n         * This is used for unary operators (e.g. `typeof`), `function`, and `super`.\n         * Other rules are handling usage of spacing preceded by those keywords.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingBeforeFirstToken(node) {\n            var firstToken = node && sourceCode.getFirstToken(node);\n\n            if (firstToken && firstToken.type === \"Keyword\") {\n                checkSpacingBefore(firstToken);\n            }\n        }\n\n        /**\n         * Reports the previous token of a given node if the token is a keyword and\n         * usage of spacing around the token is invalid.\n         *\n         * @param {ASTNode|null} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingAroundTokenBefore(node) {\n            if (node) {\n                var token = sourceCode.getTokenBefore(node);\n\n                while (token.type !== \"Keyword\") {\n                    token = sourceCode.getTokenBefore(token);\n                }\n\n                checkSpacingAround(token);\n            }\n        }\n\n        /**\n         * Reports `class` and `extends` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForClass(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.superClass);\n        }\n\n        /**\n         * Reports `if` and `else` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForIfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.alternate);\n        }\n\n        /**\n         * Reports `try`, `catch`, and `finally` keywords of a given node if usage\n         * of spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForTryStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundFirstToken(node.handler);\n            checkSpacingAroundTokenBefore(node.finalizer);\n        }\n\n        /**\n         * Reports `do` and `while` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForDoWhileStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.test);\n        }\n\n        /**\n         * Reports `for` and `in` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForInStatement(node) {\n            checkSpacingAroundFirstToken(node);\n            checkSpacingAroundTokenBefore(node.right);\n        }\n\n        /**\n         * Reports `for` and `of` keywords of a given node if usage of spacing\n         * around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForForOfStatement(node) {\n            checkSpacingAroundFirstToken(node);\n\n            // `of` is not a keyword token.\n            var token = sourceCode.getTokenBefore(node.right);\n\n            while (token.value !== \"of\") {\n                token = sourceCode.getTokenBefore(token);\n            }\n            checkSpacingAround(token);\n        }\n\n        /**\n         * Reports `import`, `export`, `as`, and `from` keywords of a given node if\n         * usage of spacing around those keywords is invalid.\n         *\n         * This rule handles the `*` token in module declarations.\n         *\n         *     import*as A from \"./a\"; /*error Expected space(s) after \"import\".\n         *                               error Expected space(s) before \"as\".\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForModuleDeclaration(node) {\n            var firstToken = sourceCode.getFirstToken(node);\n\n            checkSpacingBefore(firstToken, PREV_TOKEN_M);\n            checkSpacingAfter(firstToken, NEXT_TOKEN_M);\n\n            if (node.source) {\n                var fromToken = sourceCode.getTokenBefore(node.source);\n\n                checkSpacingBefore(fromToken, PREV_TOKEN_M);\n                checkSpacingAfter(fromToken, NEXT_TOKEN_M);\n            }\n        }\n\n        /**\n         * Reports `as` keyword of a given node if usage of spacing around this\n         * keyword is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForImportNamespaceSpecifier(node) {\n            var asToken = sourceCode.getFirstToken(node, 1);\n\n            checkSpacingBefore(asToken, PREV_TOKEN_M);\n        }\n\n        /**\n         * Reports `static`, `get`, and `set` keywords of a given node if usage of\n         * spacing around those keywords is invalid.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function checkSpacingForProperty(node) {\n            if (node.static) {\n                checkSpacingAroundFirstToken(node);\n            }\n            if (node.kind === \"get\" || node.kind === \"set\") {\n                var token = sourceCode.getFirstToken(\n                    node,\n                    node.static ? 1 : 0\n                );\n\n                checkSpacingAround(token);\n            }\n        }\n\n        return {\n\n            // Statements\n            DebuggerStatement: checkSpacingAroundFirstToken,\n            WithStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Control flow\n            BreakStatement: checkSpacingAroundFirstToken,\n            ContinueStatement: checkSpacingAroundFirstToken,\n            ReturnStatement: checkSpacingAroundFirstToken,\n            ThrowStatement: checkSpacingAroundFirstToken,\n            TryStatement: checkSpacingForTryStatement,\n\n            // Statements - Choice\n            IfStatement: checkSpacingForIfStatement,\n            SwitchStatement: checkSpacingAroundFirstToken,\n            SwitchCase: checkSpacingAroundFirstToken,\n\n            // Statements - Loops\n            DoWhileStatement: checkSpacingForDoWhileStatement,\n            ForInStatement: checkSpacingForForInStatement,\n            ForOfStatement: checkSpacingForForOfStatement,\n            ForStatement: checkSpacingAroundFirstToken,\n            WhileStatement: checkSpacingAroundFirstToken,\n\n            // Statements - Declarations\n            ClassDeclaration: checkSpacingForClass,\n            ExportNamedDeclaration: checkSpacingForModuleDeclaration,\n            ExportDefaultDeclaration: checkSpacingAroundFirstToken,\n            ExportAllDeclaration: checkSpacingForModuleDeclaration,\n            FunctionDeclaration: checkSpacingBeforeFirstToken,\n            ImportDeclaration: checkSpacingForModuleDeclaration,\n            VariableDeclaration: checkSpacingAroundFirstToken,\n\n            // Expressions\n            ClassExpression: checkSpacingForClass,\n            FunctionExpression: checkSpacingBeforeFirstToken,\n            NewExpression: checkSpacingBeforeFirstToken,\n            Super: checkSpacingBeforeFirstToken,\n            ThisExpression: checkSpacingBeforeFirstToken,\n            UnaryExpression: checkSpacingBeforeFirstToken,\n            YieldExpression: checkSpacingBeforeFirstToken,\n\n            // Others\n            ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,\n            MethodDefinition: checkSpacingForProperty,\n            Property: checkSpacingForProperty\n        };\n    }\n};\n"]}