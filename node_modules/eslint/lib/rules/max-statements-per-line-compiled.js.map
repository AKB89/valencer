{"version":3,"sources":["max-statements-per-line.js"],"names":[],"mappings":"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","file":"max-statements-per-line-compiled.js","sourcesContent":["/**\n * @fileoverview Specify the maximum number of statements allowed per line.\n * @author Kenneth Williams\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum number of statements allowed per line\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var sourceCode = context.getSourceCode(),\n            options = context.options[0] || {},\n            lastStatementLine = 0,\n            numberOfStatementsOnThisLine = 0,\n            maxStatementsPerLine = typeof options.max !== \"undefined\" ? options.max : 1,\n            message = \"This line has too many statements. Maximum allowed is \" + maxStatementsPerLine + \".\";\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        var SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/;\n\n        /**\n         * Gets the actual last token of a given node.\n         *\n         * @param {ASTNode} node - A node to get. This is a node except EmptyStatement.\n         * @returns {Token} The actual last token.\n         */\n        function getActualLastToken(node) {\n            var lastToken = sourceCode.getLastToken(node);\n\n            if (lastToken.value === \";\") {\n                lastToken = sourceCode.getTokenBefore(lastToken);\n            }\n            return lastToken;\n        }\n\n        /**\n         * Addresses a given node.\n         * It updates the state of this rule, then reports the node if the node violated this rule.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function enterStatement(node) {\n            var line = node.loc.start.line;\n\n            // Skip to allow non-block statements if this is direct child of control statements.\n            // `if (a) foo();` is counted as 1.\n            // But `if (a) foo(); else foo();` should be counted as 2.\n            if (SINGLE_CHILD_ALLOWED.test(node.parent.type) &&\n                node.parent.alternate !== node\n            ) {\n                return;\n            }\n\n            // Update state.\n            if (line === lastStatementLine) {\n                numberOfStatementsOnThisLine += 1;\n            } else {\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n\n            // Reports if the node violated this rule.\n            if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {\n                context.report({node: node, message: message});\n            }\n        }\n\n        /**\n         * Updates the state of this rule with the end line of leaving node to check with the next statement.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function leaveStatement(node) {\n            var line = getActualLastToken(node).loc.end.line;\n\n            // Update state.\n            if (line !== lastStatementLine) {\n                numberOfStatementsOnThisLine = 1;\n                lastStatementLine = line;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            BreakStatement: enterStatement,\n            ClassDeclaration: enterStatement,\n            ContinueStatement: enterStatement,\n            DebuggerStatement: enterStatement,\n            DoWhileStatement: enterStatement,\n            ExpressionStatement: enterStatement,\n            ForInStatement: enterStatement,\n            ForOfStatement: enterStatement,\n            ForStatement: enterStatement,\n            FunctionDeclaration: enterStatement,\n            IfStatement: enterStatement,\n            ImportDeclaration: enterStatement,\n            LabeledStatement: enterStatement,\n            ReturnStatement: enterStatement,\n            SwitchStatement: enterStatement,\n            ThrowStatement: enterStatement,\n            TryStatement: enterStatement,\n            VariableDeclaration: enterStatement,\n            WhileStatement: enterStatement,\n            WithStatement: enterStatement,\n            ExportNamedDeclaration: enterStatement,\n            ExportDefaultDeclaration: enterStatement,\n            ExportAllDeclaration: enterStatement,\n\n            \"BreakStatement:exit\": leaveStatement,\n            \"ClassDeclaration:exit\": leaveStatement,\n            \"ContinueStatement:exit\": leaveStatement,\n            \"DebuggerStatement:exit\": leaveStatement,\n            \"DoWhileStatement:exit\": leaveStatement,\n            \"ExpressionStatement:exit\": leaveStatement,\n            \"ForInStatement:exit\": leaveStatement,\n            \"ForOfStatement:exit\": leaveStatement,\n            \"ForStatement:exit\": leaveStatement,\n            \"FunctionDeclaration:exit\": leaveStatement,\n            \"IfStatement:exit\": leaveStatement,\n            \"ImportDeclaration:exit\": leaveStatement,\n            \"LabeledStatement:exit\": leaveStatement,\n            \"ReturnStatement:exit\": leaveStatement,\n            \"SwitchStatement:exit\": leaveStatement,\n            \"ThrowStatement:exit\": leaveStatement,\n            \"TryStatement:exit\": leaveStatement,\n            \"VariableDeclaration:exit\": leaveStatement,\n            \"WhileStatement:exit\": leaveStatement,\n            \"WithStatement:exit\": leaveStatement,\n            \"ExportNamedDeclaration:exit\": leaveStatement,\n            \"ExportDefaultDeclaration:exit\": leaveStatement,\n            \"ExportAllDeclaration:exit\": leaveStatement,\n\n            // For backward compatibility.\n            // Empty blocks should be warned if `{max: 0}` was given.\n            BlockStatement: function reportIfZero(node) {\n                if (maxStatementsPerLine === 0 && node.body.length === 0) {\n                    context.report({node: node, message: message});\n                }\n            }\n        };\n    }\n};\n"]}