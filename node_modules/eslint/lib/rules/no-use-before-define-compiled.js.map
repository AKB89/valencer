{"version":3,"sources":["no-use-before-define.js"],"names":[],"mappings":"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","file":"no-use-before-define-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of variables before they are defined\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/;\n\n/**\n * Parses a given value as options.\n *\n * @param {any} options - A value to parse.\n * @returns {object} The parsed options.\n */\nfunction parseOptions(options) {\n    var functions = true;\n    var classes = true;\n\n    if (typeof options === \"string\") {\n        functions = (options !== \"nofunc\");\n    } else if (typeof options === \"object\" && options !== null) {\n        functions = options.functions !== false;\n        classes = options.classes !== false;\n    }\n\n    return {functions: functions, classes: classes};\n}\n\n/**\n * @returns {boolean} `false`.\n */\nfunction alwaysFalse() {\n    return false;\n}\n\n/**\n * Checks whether or not a given variable is a function declaration.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @returns {boolean} `true` if the variable is a function declaration.\n */\nfunction isFunction(variable) {\n    return variable.defs[0].type === \"FunctionName\";\n}\n\n/**\n * Checks whether or not a given variable is a class declaration in an upper function scope.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the variable is a class declaration.\n */\nfunction isOuterClass(variable, reference) {\n    return (\n        variable.defs[0].type === \"ClassName\" &&\n        variable.scope.variableScope !== reference.from.variableScope\n    );\n}\n\n/**\n * Checks whether or not a given variable is a function declaration or a class declaration in an upper function scope.\n *\n * @param {escope.Variable} variable - A variable to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the variable is a function declaration or a class declaration.\n */\nfunction isFunctionOrOuterClass(variable, reference) {\n    return isFunction(variable, reference) || isOuterClass(variable, reference);\n}\n\n/**\n * Checks whether or not a given location is inside of the range of a given node.\n *\n * @param {ASTNode} node - An node to check.\n * @param {number} location - A location to check.\n * @returns {boolean} `true` if the location is inside of the range of the node.\n */\nfunction isInRange(node, location) {\n    return node && node.range[0] <= location && location <= node.range[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of the initializers of a given variable.\n *\n * @param {Variable} variable - A variable to check.\n * @param {Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the initializers.\n */\nfunction isInInitializer(variable, reference) {\n    if (variable.scope !== reference.from) {\n        return false;\n    }\n\n    var node = variable.identifiers[0].parent;\n    var location = reference.identifier.range[1];\n\n    while (node) {\n        if (node.type === \"VariableDeclarator\") {\n            if (isInRange(node.init, location)) {\n                return true;\n            }\n            break;\n        } else if (node.type === \"AssignmentPattern\") {\n            if (isInRange(node.right, location)) {\n                return true;\n            }\n        } else if (SENTINEL_TYPE.test(node.type)) {\n            break;\n        }\n\n        node = node.parent;\n    }\n\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of variables before they are defined\",\n            category: \"Variables\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"nofunc\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            functions: {type: \"boolean\"},\n                            classes: {type: \"boolean\"}\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = parseOptions(context.options[0]);\n\n        // Defines a function which checks whether or not a reference is allowed according to the option.\n        var isAllowed;\n\n        if (options.functions && options.classes) {\n            isAllowed = alwaysFalse;\n        } else if (options.functions) {\n            isAllowed = isOuterClass;\n        } else if (options.classes) {\n            isAllowed = isFunction;\n        } else {\n            isAllowed = isFunctionOrOuterClass;\n        }\n\n        /**\n         * Finds and validates all variables in a given scope.\n         * @param {Scope} scope The scope object.\n         * @returns {void}\n         * @private\n         */\n        function findVariablesInScope(scope) {\n            scope.references.forEach(function(reference) {\n                var variable = reference.resolved;\n\n                // Skips when the reference is:\n                // - initialization's.\n                // - referring to an undefined variable.\n                // - referring to a global environment variable (there're no identifiers).\n                // - located preceded by the variable (except in initializers).\n                // - allowed by options.\n                if (reference.init ||\n                    !variable ||\n                    variable.identifiers.length === 0 ||\n                    (variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference)) ||\n                    isAllowed(variable, reference)\n                ) {\n                    return;\n                }\n\n                // Reports.\n                context.report({\n                    node: reference.identifier,\n                    message: \"'{{name}}' was used before it was defined\",\n                    data: reference.identifier\n                });\n            });\n        }\n\n        /**\n         * Validates variables inside of a node's scope.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function findVariables() {\n            var scope = context.getScope();\n\n            findVariablesInScope(scope);\n        }\n\n        var ruleDefinition = {\n            \"Program:exit\": function(node) {\n                var scope = context.getScope(),\n                    ecmaFeatures = context.parserOptions.ecmaFeatures || {};\n\n                findVariablesInScope(scope);\n\n                // both Node.js and Modules have an extra scope\n                if (ecmaFeatures.globalReturn || node.sourceType === \"module\") {\n                    findVariablesInScope(scope.childScopes[0]);\n                }\n            }\n        };\n\n        if (context.parserOptions.ecmaVersion >= 6) {\n            ruleDefinition[\"BlockStatement:exit\"] =\n                ruleDefinition[\"SwitchStatement:exit\"] = findVariables;\n\n            ruleDefinition[\"ArrowFunctionExpression:exit\"] = function(node) {\n                if (node.body.type !== \"BlockStatement\") {\n                    findVariables(node);\n                }\n            };\n        } else {\n            ruleDefinition[\"FunctionExpression:exit\"] =\n                ruleDefinition[\"FunctionDeclaration:exit\"] =\n                ruleDefinition[\"ArrowFunctionExpression:exit\"] = findVariables;\n        }\n\n        return ruleDefinition;\n    }\n};\n"]}