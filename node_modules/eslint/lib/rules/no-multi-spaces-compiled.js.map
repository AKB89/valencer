{"version":3,"sources":["no-multi-spaces.js"],"names":[],"mappings":"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","file":"no-multi-spaces-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow use of multiple spaces.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple spaces\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"object\",\n                        patternProperties: {\n                            \"^([A-Z][a-z]*)+$\": {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        // the index of the last comment that was checked\n        var exceptions = { Property: true },\n            hasExceptions = true,\n            options = context.options[0],\n            lastCommentIndex = 0;\n\n        if (options && options.exceptions) {\n            Object.keys(options.exceptions).forEach(function(key) {\n                if (options.exceptions[key]) {\n                    exceptions[key] = true;\n                } else {\n                    delete exceptions[key];\n                }\n            });\n            hasExceptions = Object.keys(exceptions).length > 0;\n        }\n\n        /**\n         * Determines if a given source index is in a comment or not by checking\n         * the index against the comment range. Since the check goes straight\n         * through the file, once an index is passed a certain comment, we can\n         * go to the next comment to check that.\n         * @param {int} index The source index to check.\n         * @param {ASTNode[]} comments An array of comment nodes.\n         * @returns {boolean} True if the index is within a comment, false if not.\n         * @private\n         */\n        function isIndexInComment(index, comments) {\n\n            var comment;\n\n            while (lastCommentIndex < comments.length) {\n\n                comment = comments[lastCommentIndex];\n\n                if (comment.range[0] <= index && index < comment.range[1]) {\n                    return true;\n                } else if (index > comment.range[1]) {\n                    lastCommentIndex++;\n                } else {\n                    break;\n                }\n\n            }\n\n            return false;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: function() {\n\n                var sourceCode = context.getSourceCode(),\n                    source = sourceCode.getText(),\n                    allComments = sourceCode.getAllComments(),\n                    pattern = /[^\\n\\r\\u2028\\u2029\\t ].? {2,}/g,  // note: repeating space\n                    token,\n                    previousToken,\n                    parent;\n\n\n                /**\n                 * Creates a fix function that removes the multiple spaces between the two tokens\n                 * @param {RuleFixer} leftToken left token\n                 * @param {RuleFixer} rightToken right token\n                 * @returns {function} fix function\n                 * @private\n                 */\n                function createFix(leftToken, rightToken) {\n                    return function(fixer) {\n                        return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], \" \");\n                    };\n                }\n\n                while (pattern.test(source)) {\n\n                    // do not flag anything inside of comments\n                    if (!isIndexInComment(pattern.lastIndex, allComments)) {\n\n                        token = sourceCode.getTokenByRangeStart(pattern.lastIndex);\n                        if (token) {\n                            previousToken = sourceCode.getTokenBefore(token);\n\n                            if (hasExceptions) {\n                                parent = sourceCode.getNodeByRangeIndex(pattern.lastIndex - 1);\n                            }\n\n                            if (!parent || !exceptions[parent.type]) {\n                                context.report({\n                                    node: token,\n                                    loc: token.loc.start,\n                                    message: \"Multiple spaces found before '{{value}}'.\",\n                                    data: { value: token.value },\n                                    fix: createFix(previousToken, token)\n                                });\n                            }\n                        }\n\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]}