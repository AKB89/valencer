{"version":3,"sources":["valid-typeof.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,8DADX;AAEF,sBAAU,iBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;;AAEtB,YAAI,cAAc,CAAC,QAAD,EAAW,WAAX,EAAwB,QAAxB,EAAkC,SAAlC,EAA6C,QAA7C,EAAuD,QAAvD,EAAiE,UAAjE,CAAlB;YACI,YAAY,CAAC,IAAD,EAAO,KAAP,EAAc,IAAd,EAAoB,KAApB,CADhB;;;;;;AAOA,eAAO;;AAEH,6BAAiB,UAAS,IAAT,EAAe;AAC5B,oBAAI,MAAJ,EAAY,OAAZ;;AAEA,oBAAI,KAAK,QAAL,KAAkB,QAAtB,EAAgC;AAC5B,6BAAS,QAAQ,YAAR,GAAuB,GAAvB,EAAT;;AAEA,wBAAI,OAAO,IAAP,KAAgB,kBAAhB,IAAsC,UAAU,OAAV,CAAkB,OAAO,QAAzB,MAAuC,CAAC,CAAlF,EAAqF;AACjF,kCAAU,OAAO,IAAP,KAAgB,IAAhB,GAAuB,OAAO,KAA9B,GAAsC,OAAO,IAAvD;;AAEA,4BAAI,QAAQ,IAAR,KAAiB,SAAjB,IAA8B,YAAY,OAAZ,CAAoB,QAAQ,KAA5B,MAAuC,CAAC,CAA1E,EAA6E;AACzE,oCAAQ,MAAR,CAAe,OAAf,EAAwB,iCAAxB;AACH;AACJ;AACJ;AACJ;;AAhBE,SAAP;AAoBH;AAxCY,CAAjB","file":"valid-typeof-compiled.js","sourcesContent":["/**\n * @fileoverview Ensures that the results of typeof are compared against a valid string\n * @author Ian Christian Myers\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce comparing `typeof` expressions against valid strings\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n\n        var VALID_TYPES = [\"symbol\", \"undefined\", \"object\", \"boolean\", \"number\", \"string\", \"function\"],\n            OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            UnaryExpression: function(node) {\n                var parent, sibling;\n\n                if (node.operator === \"typeof\") {\n                    parent = context.getAncestors().pop();\n\n                    if (parent.type === \"BinaryExpression\" && OPERATORS.indexOf(parent.operator) !== -1) {\n                        sibling = parent.left === node ? parent.right : parent.left;\n\n                        if (sibling.type === \"Literal\" && VALID_TYPES.indexOf(sibling.value) === -1) {\n                            context.report(sibling, \"Invalid typeof comparison value\");\n                        }\n                    }\n                }\n            }\n\n        };\n\n    }\n};\n"]}