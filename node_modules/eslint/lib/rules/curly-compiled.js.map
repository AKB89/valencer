{"version":3,"sources":["curly.js"],"names":[],"mappings":"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","file":"curly-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag statements without curly braces\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent brace style for all control statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"multi\", \"multi-line\", \"multi-or-nest\"]\n                        },\n                        {\n                            enum: [\"consistent\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create: function(context) {\n\n        var multiOnly = (context.options[0] === \"multi\");\n        var multiLine = (context.options[0] === \"multi-line\");\n        var multiOrNest = (context.options[0] === \"multi-or-nest\");\n        var consistent = (context.options[1] === \"consistent\");\n\n        var sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Determines if a given node is a one-liner that's on the same line as it's preceding code.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner that's on the same line as it's preceding code.\n         * @private\n         */\n        function isCollapsedOneLiner(node) {\n            var before = sourceCode.getTokenBefore(node),\n                last = sourceCode.getLastToken(node);\n\n            return before.loc.start.line === last.loc.end.line;\n        }\n\n        /**\n         * Determines if a given node is a one-liner.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a one-liner.\n         * @private\n         */\n        function isOneLiner(node) {\n            var first = sourceCode.getFirstToken(node),\n                last = sourceCode.getLastToken(node);\n\n            return first.loc.start.line === last.loc.end.line;\n        }\n\n        /**\n         * Gets the `else` keyword token of a given `IfStatement` node.\n         * @param {ASTNode} node - A `IfStatement` node to get.\n         * @returns {Token} The `else` keyword token.\n         */\n        function getElseKeyword(node) {\n            var token = sourceCode.getTokenAfter(node.consequent);\n\n            while (token.type !== \"Keyword\" || token.value !== \"else\") {\n                token = sourceCode.getTokenAfter(token);\n            }\n\n            return token;\n        }\n\n        /**\n         * Checks a given IfStatement node requires braces of the consequent chunk.\n         * This returns `true` when below:\n         *\n         * 1. The given node has the `alternate` node.\n         * 2. There is a `IfStatement` which doesn't have `alternate` node in the\n         *    trailing statement chain of the `consequent` node.\n         *\n         * @param {ASTNode} node - A IfStatement node to check.\n         * @returns {boolean} `true` if the node requires braces of the consequent chunk.\n         */\n        function requiresBraceOfConsequent(node) {\n            if (node.alternate && node.consequent.type === \"BlockStatement\") {\n                if (node.consequent.body.length >= 2) {\n                    return true;\n                }\n\n                node = node.consequent.body[0];\n                while (node) {\n                    if (node.type === \"IfStatement\" && !node.alternate) {\n                        return true;\n                    }\n                    node = astUtils.getTrailingStatement(node);\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports \"Expected { after ...\" error\n         * @param {ASTNode} node The node to report.\n         * @param {string} name The name to report.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {void}\n         * @private\n         */\n        function reportExpectedBraceError(node, name, suffix) {\n            context.report({\n                node: node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                message: \"Expected { after '{{name}}'{{suffix}}.\",\n                data: {\n                    name: name,\n                    suffix: (suffix ? \" \" + suffix : \"\")\n                }\n            });\n        }\n\n        /**\n         * Reports \"Unnecessary { after ...\" error\n         * @param {ASTNode} node The node to report.\n         * @param {string} name The name to report.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {void}\n         * @private\n         */\n        function reportUnnecessaryBraceError(node, name, suffix) {\n            context.report({\n                node: node,\n                loc: (name !== \"else\" ? node : getElseKeyword(node)).loc.start,\n                message: \"Unnecessary { after '{{name}}'{{suffix}}.\",\n                data: {\n                    name: name,\n                    suffix: (suffix ? \" \" + suffix : \"\")\n                }\n            });\n        }\n\n        /**\n         * Prepares to check the body of a node to see if it's a block statement.\n         * @param {ASTNode} node The node to report if there's a problem.\n         * @param {ASTNode} body The body node to check for blocks.\n         * @param {string} name The name to report if there's a problem.\n         * @param {string} suffix Additional string to add to the end of a report.\n         * @returns {object} a prepared check object, with \"actual\", \"expected\", \"check\" properties.\n         *   \"actual\" will be `true` or `false` whether the body is already a block statement.\n         *   \"expected\" will be `true` or `false` if the body should be a block statement or not, or\n         *   `null` if it doesn't matter, depending on the rule options. It can be modified to change\n         *   the final behavior of \"check\".\n         *   \"check\" will be a function reporting appropriate problems depending on the other\n         *   properties.\n         */\n        function prepareCheck(node, body, name, suffix) {\n            var hasBlock = (body.type === \"BlockStatement\");\n            var expected = null;\n\n            if (node.type === \"IfStatement\" && node.consequent === body && requiresBraceOfConsequent(node)) {\n                expected = true;\n            } else if (multiOnly) {\n                if (hasBlock && body.body.length === 1) {\n                    expected = false;\n                }\n            } else if (multiLine) {\n                if (!isCollapsedOneLiner(body)) {\n                    expected = true;\n                }\n            } else if (multiOrNest) {\n                if (hasBlock && body.body.length === 1 && isOneLiner(body.body[0])) {\n                    expected = false;\n                } else if (!isOneLiner(body)) {\n                    expected = true;\n                }\n            } else {\n                expected = true;\n            }\n\n            return {\n                actual: hasBlock,\n                expected: expected,\n                check: function() {\n                    if (this.expected !== null && this.expected !== this.actual) {\n                        if (this.expected) {\n                            reportExpectedBraceError(node, name, suffix);\n                        } else {\n                            reportUnnecessaryBraceError(node, name, suffix);\n                        }\n                    }\n                }\n            };\n        }\n\n        /**\n         * Prepares to check the bodies of a \"if\", \"else if\" and \"else\" chain.\n         * @param {ASTNode} node The first IfStatement node of the chain.\n         * @returns {object[]} prepared checks for each body of the chain. See `prepareCheck` for more\n         *   information.\n         */\n        function prepareIfChecks(node) {\n            var preparedChecks = [];\n\n            do {\n                preparedChecks.push(prepareCheck(node, node.consequent, \"if\", \"condition\"));\n                if (node.alternate && node.alternate.type !== \"IfStatement\") {\n                    preparedChecks.push(prepareCheck(node, node.alternate, \"else\"));\n                    break;\n                }\n                node = node.alternate;\n            } while (node);\n\n            if (consistent) {\n\n                /*\n                 * If any node should have or already have braces, make sure they\n                 * all have braces.\n                 * If all nodes shouldn't have braces, make sure they don't.\n                 */\n                var expected = preparedChecks.some(function(preparedCheck) {\n                    if (preparedCheck.expected !== null) {\n                        return preparedCheck.expected;\n                    }\n                    return preparedCheck.actual;\n                });\n\n                preparedChecks.forEach(function(preparedCheck) {\n                    preparedCheck.expected = expected;\n                });\n            }\n\n            return preparedChecks;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            IfStatement: function(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    prepareIfChecks(node).forEach(function(preparedCheck) {\n                        preparedCheck.check();\n                    });\n                }\n            },\n\n            WhileStatement: function(node) {\n                prepareCheck(node, node.body, \"while\", \"condition\").check();\n            },\n\n            DoWhileStatement: function(node) {\n                prepareCheck(node, node.body, \"do\").check();\n            },\n\n            ForStatement: function(node) {\n                prepareCheck(node, node.body, \"for\", \"condition\").check();\n            },\n\n            ForInStatement: function(node) {\n                prepareCheck(node, node.body, \"for-in\").check();\n            },\n\n            ForOfStatement: function(node) {\n                prepareCheck(node, node.body, \"for-of\").check();\n            }\n        };\n    }\n};\n"]}