{"version":3,"sources":["no-else-return.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,qEADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;;;;;;;;;;;;AAYtB,iBAAS,aAAT,CAAuB,IAAvB,EAA6B;AACzB,oBAAQ,MAAR,CAAe,IAAf,EAAqB,mCAArB;AACH;;;;;;;;AAQD,iBAAS,cAAT,CAAwB,IAAxB,EAA8B;AAC1B,mBAAO,KAAK,IAAL,KAAc,iBAArB;AACH;;;;;;;;;;AAUD,iBAAS,cAAT,CAAwB,IAAxB,EAA8B;AAC1B,gBAAI,KAAK,IAAL,KAAc,gBAAlB,EAAoC;AAChC,oBAAI,OAAO,KAAK,IAAhB;oBACI,gBAAgB,KAAK,KAAK,MAAL,GAAc,CAAnB,CADpB;;AAGA,uBAAO,iBAAiB,eAAe,aAAf,CAAxB;AACH;AACD,mBAAO,eAAe,IAAf,CAAP;AACH;;;;;;;;;AASD,iBAAS,OAAT,CAAiB,IAAjB,EAAuB;AACnB,mBAAO,KAAK,SAAL,IAAkB,KAAK,UAAvB,IAAqC,KAAK,SAAL,CAAe,IAAf,KAAwB,aAApE;AACH;;;;;;;;;;AAUD,iBAAS,UAAT,CAAoB,IAApB,EAA0B;AACtB,mBAAO,KAAK,IAAL,KAAc,aAAd,IAA+B,QAAQ,IAAR,CAA/B,IACH,eAAe,KAAK,SAApB,CADG,IAC+B,eAAe,KAAK,UAApB,CADtC;AAEH;;;;;;;;;;;AAWD,iBAAS,kBAAT,CAA4B,IAA5B,EAAkC;AAC9B,mBAAO,eAAe,IAAf,KAAwB,WAAW,IAAX,CAA/B;AACH;;;;;;;AAQD,iBAAS,aAAT,CAAuB,IAAvB,EAA6B;AACzB,gBAAI,KAAK,IAAL,KAAc,gBAAlB,EAAoC;;;AAGhC,uBAAO,KAAK,IAAL,CAAU,IAAV,CAAe,kBAAf,CAAP;AACH,aAJD,MAIO;;;;;;AAMH,uBAAO,mBAAmB,IAAnB,CAAP;AACH;AACJ;;;;;;AAMD,eAAO;;AAEH,yBAAa,UAAS,IAAT,EAAe;AACxB,oBAAI,SAAS,QAAQ,YAAR,GAAuB,GAAvB,EAAb;oBACI,WADJ;oBAEI,SAFJ;;;;AAMA,oBAAI,OAAO,IAAP,KAAgB,aAAhB,IAAiC,OAAO,SAAP,KAAqB,IAA1D,EAAgE;AAC5D;AACH;;AAED,qBAAK,cAAc,EAAnB,EAAuB,KAAK,IAAL,KAAc,aAArC,EAAoD,OAAO,KAAK,SAAhE,EAA2E;AACvE,wBAAI,CAAC,KAAK,SAAV,EAAqB;AACjB;AACH;AACD,gCAAY,IAAZ,CAAiB,KAAK,UAAtB;AACA,gCAAY,KAAK,SAAjB;AACH;;AAED,oBAAI,YAAY,KAAZ,CAAkB,aAAlB,CAAJ,EAAsC;AAClC,kCAAc,SAAd;AACH;AACJ;;AAxBE,SAAP;AA4BH;AAjJY,CAAjB","file":"no-else-return-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag `else` after a `return` in `if`\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow `else` blocks after `return` statements in `if` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Display the context report if rule is violated\n         *\n         * @param {Node} node The 'else' node\n         * @returns {void}\n         */\n        function displayReport(node) {\n            context.report(node, \"Unexpected 'else' after 'return'.\");\n        }\n\n        /**\n         * Check to see if the node is a ReturnStatement\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if node is a return\n         */\n        function checkForReturn(node) {\n            return node.type === \"ReturnStatement\";\n        }\n\n        /**\n         * Naive return checking, does not iterate through the whole\n         * BlockStatement because we make the assumption that the ReturnStatement\n         * will be the last node in the body of the BlockStatement.\n         *\n         * @param {Node} node The consequent/alternate node\n         * @returns {boolean} True if it has a return\n         */\n        function naiveHasReturn(node) {\n            if (node.type === \"BlockStatement\") {\n                var body = node.body,\n                    lastChildNode = body[body.length - 1];\n\n                return lastChildNode && checkForReturn(lastChildNode);\n            }\n            return checkForReturn(node);\n        }\n\n        /**\n         * Check to see if the node is valid for evaluation,\n         * meaning it has an else and not an else-if\n         *\n         * @param {Node} node The node being evaluated\n         * @returns {boolean} True if the node is valid\n         */\n        function hasElse(node) {\n            return node.alternate && node.consequent && node.alternate.type !== \"IfStatement\";\n        }\n\n        /**\n         * If the consequent is an IfStatement, check to see if it has an else\n         * and both its consequent and alternate path return, meaning this is\n         * a nested case of rule violation.  If-Else not considered currently.\n         *\n         * @param {Node} node The consequent node\n         * @returns {boolean} True if this is a nested rule violation\n         */\n        function checkForIf(node) {\n            return node.type === \"IfStatement\" && hasElse(node) &&\n                naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);\n        }\n\n        /**\n         * Check the consequent/body node to make sure it is not\n         * a ReturnStatement or an IfStatement that returns on both\n         * code paths.\n         *\n         * @param {Node} node The consequent or body node\n         * @param {Node} alternate The alternate node\n         * @returns {boolean} `true` if it is a Return/If node that always returns.\n         */\n        function checkForReturnOrIf(node) {\n            return checkForReturn(node) || checkForIf(node);\n        }\n\n\n        /**\n         * Check whether a node returns in every codepath.\n         * @param {Node} node The node to be checked\n         * @returns {boolean} `true` if it returns on every codepath.\n         */\n        function alwaysReturns(node) {\n            if (node.type === \"BlockStatement\") {\n\n                // If we have a BlockStatement, check each consequent body node.\n                return node.body.some(checkForReturnOrIf);\n            } else {\n\n                /*\n                 * If not a block statement, make sure the consequent isn't a\n                 * ReturnStatement or an IfStatement with returns on both paths.\n                 */\n                return checkForReturnOrIf(node);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n\n            IfStatement: function(node) {\n                var parent = context.getAncestors().pop(),\n                    consequents,\n                    alternate;\n\n                // Only \"top-level\" if statements are checked, meaning the first `if`\n                // in a `if-else-if-...` chain.\n                if (parent.type === \"IfStatement\" && parent.alternate === node) {\n                    return;\n                }\n\n                for (consequents = []; node.type === \"IfStatement\"; node = node.alternate) {\n                    if (!node.alternate) {\n                        return;\n                    }\n                    consequents.push(node.consequent);\n                    alternate = node.alternate;\n                }\n\n                if (consequents.every(alwaysReturns)) {\n                    displayReport(alternate);\n                }\n            }\n\n        };\n\n    }\n};\n"]}