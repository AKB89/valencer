{"version":3,"sources":["no-useless-call.js"],"names":[],"mappings":";;;;;AAKA;;AAEA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;;;;;;AAWA,SAAS,wBAAT,CAAkC,IAAlC,EAAwC;AACpC,WACI,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAArB,IACA,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,KAA8B,YAD9B,IAEA,KAAK,MAAL,CAAY,QAAZ,KAAyB,KAFzB,KAIK,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,KAA8B,MAA9B,IAAwC,KAAK,SAAL,CAAe,MAAf,IAAyB,CAAlE,IACC,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,KAA8B,OAA9B,IAAyC,KAAK,SAAL,CAAe,MAAf,KAA0B,CAAnE,IAAwE,KAAK,SAAL,CAAe,CAAf,EAAkB,IAAlB,KAA2B,iBALxG,CADJ;AASH;;;;;;;;;AASD,SAAS,WAAT,CAAqB,IAArB,EAA2B,KAA3B,EAAkC,UAAlC,EAA8C;AAC1C,QAAI,UAAU,WAAW,SAAX,CAAqB,IAArB,CAAd;AACA,QAAI,UAAU,WAAW,SAAX,CAAqB,KAArB,CAAd;;AAEA,QAAI,QAAQ,MAAR,KAAmB,QAAQ,MAA/B,EAAuC;AACnC,eAAO,KAAP;AACH;AACD,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,MAA5B,EAAoC,EAAE,CAAtC,EAAyC;AACrC,YAAI,QAAQ,CAAR,EAAW,IAAX,KAAoB,QAAQ,CAAR,EAAW,IAA/B,IACA,QAAQ,CAAR,EAAW,KAAX,KAAqB,QAAQ,CAAR,EAAW,KADpC,EAEE;AACE,mBAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;;;;;;;;AASD,SAAS,cAAT,CAAwB,YAAxB,EAAsC,OAAtC,EAA+C,UAA/C,EAA2D;AACvD,QAAI,CAAC,YAAL,EAAmB;AACf,eAAO,SAAS,iBAAT,CAA2B,OAA3B,CAAP;AACH;AACD,WAAO,YAAY,YAAZ,EAA0B,OAA1B,EAAmC,UAAnC,CAAP;AACH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,wDADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;AAEA,eAAO;AACH,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,CAAC,yBAAyB,IAAzB,CAAL,EAAqC;AACjC;AACH;;AAED,oBAAI,UAAU,KAAK,MAAL,CAAY,MAA1B;AACA,oBAAI,eAAgB,QAAQ,IAAR,KAAiB,kBAAlB,GAAwC,QAAQ,MAAhD,GAAyD,IAA5E;AACA,oBAAI,UAAU,KAAK,SAAL,CAAe,CAAf,CAAd;;AAEA,oBAAI,eAAe,YAAf,EAA6B,OAA7B,EAAsC,UAAtC,CAAJ,EAAuD;AACnD,4BAAQ,MAAR,CACI,IADJ,EAEI,4BAFJ,EAGI,EAAC,MAAM,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAA5B,EAHJ;AAIH;AACJ;AAhBE,SAAP;AAkBH;AAhCY,CAAjB","file":"no-useless-call-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to disallow unnecessary `.call()` and `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.call()`/`.apply()`.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.call()`/`.apply()`.\n */\nfunction isCallOrNonVariadicApply(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.computed === false &&\n        (\n            (node.callee.property.name === \"call\" && node.arguments.length >= 1) ||\n            (node.callee.property.name === \"apply\" && node.arguments.length === 2 && node.arguments[1].type === \"ArrayExpression\")\n        )\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    var tokensL = sourceCode.getTokens(left);\n    var tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (var i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.call()`/`.apply()`.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.call()`/`.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, sourceCode) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, sourceCode);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary calls to `.call()` and `.apply()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression: function(node) {\n                if (!isCallOrNonVariadicApply(node)) {\n                    return;\n                }\n\n                var applied = node.callee.object;\n                var expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                var thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report(\n                        node,\n                        \"unnecessary '.{{name}}()'.\",\n                        {name: node.callee.property.name});\n                }\n            }\n        };\n    }\n};\n"]}