{"version":3,"sources":["one-var.js"],"names":[],"mappings":"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","file":"one-var-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to control the use of single variable declarations.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce variables to be declared either together or separately in functions\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            var: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            let: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            const: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            initialized: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            uninitialized: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var MODE_ALWAYS = \"always\",\n            MODE_NEVER = \"never\";\n\n        var mode = context.options[0] || MODE_ALWAYS;\n\n        var options = {\n        };\n\n        if (typeof mode === \"string\") { // simple options configuration with just a string\n            options.var = { uninitialized: mode, initialized: mode};\n            options.let = { uninitialized: mode, initialized: mode};\n            options.const = { uninitialized: mode, initialized: mode};\n        } else if (typeof mode === \"object\") { // options configuration is an object\n            if (mode.hasOwnProperty(\"var\") && typeof mode.var === \"string\") {\n                options.var = { uninitialized: mode.var, initialized: mode.var};\n            }\n            if (mode.hasOwnProperty(\"let\") && typeof mode.let === \"string\") {\n                options.let = { uninitialized: mode.let, initialized: mode.let};\n            }\n            if (mode.hasOwnProperty(\"const\") && typeof mode.const === \"string\") {\n                options.const = { uninitialized: mode.const, initialized: mode.const};\n            }\n            if (mode.hasOwnProperty(\"uninitialized\")) {\n                if (!options.var) {\n                    options.var = {};\n                }\n                if (!options.let) {\n                    options.let = {};\n                }\n                if (!options.const) {\n                    options.const = {};\n                }\n                options.var.uninitialized = mode.uninitialized;\n                options.let.uninitialized = mode.uninitialized;\n                options.const.uninitialized = mode.uninitialized;\n            }\n            if (mode.hasOwnProperty(\"initialized\")) {\n                if (!options.var) {\n                    options.var = {};\n                }\n                if (!options.let) {\n                    options.let = {};\n                }\n                if (!options.const) {\n                    options.const = {};\n                }\n                options.var.initialized = mode.initialized;\n                options.let.initialized = mode.initialized;\n                options.const.initialized = mode.initialized;\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        var functionStack = [];\n        var blockStack = [];\n\n        /**\n         * Increments the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startBlock() {\n            blockStack.push({\n                let: {initialized: false, uninitialized: false},\n                const: {initialized: false, uninitialized: false}\n            });\n        }\n\n        /**\n         * Increments the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push({initialized: false, uninitialized: false});\n            startBlock();\n        }\n\n        /**\n         * Decrements the blockStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endBlock() {\n            blockStack.pop();\n        }\n\n        /**\n         * Decrements the functionStack counter.\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n            endBlock();\n        }\n\n        /**\n         * Records whether initialized or uninitialized variables are defined in current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @param {Object} currentScope The scope being investigated\n         * @returns {void}\n         * @private\n         */\n        function recordTypes(statementType, declarations, currentScope) {\n            for (var i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {\n                        currentScope.uninitialized = true;\n                    }\n                } else {\n                    if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {\n                        currentScope.initialized = true;\n                    }\n                }\n            }\n        }\n\n        /**\n         * Determines the current scope (function or block)\n         * @param  {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @returns {Object} The scope associated with statementType\n         */\n        function getCurrentScope(statementType) {\n            var currentScope;\n\n            if (statementType === \"var\") {\n                currentScope = functionStack[functionStack.length - 1];\n            } else if (statementType === \"let\") {\n                currentScope = blockStack[blockStack.length - 1].let;\n            } else if (statementType === \"const\") {\n                currentScope = blockStack[blockStack.length - 1].const;\n            }\n            return currentScope;\n        }\n\n        /**\n         * Counts the number of initialized and uninitialized declarations in a list of declarations\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {Object} Counts of 'uninitialized' and 'initialized' declarations\n         * @private\n         */\n        function countDeclarations(declarations) {\n            var counts = { uninitialized: 0, initialized: 0 };\n\n            for (var i = 0; i < declarations.length; i++) {\n                if (declarations[i].init === null) {\n                    counts.uninitialized++;\n                } else {\n                    counts.initialized++;\n                }\n            }\n            return counts;\n        }\n\n        /**\n         * Determines if there is more than one var statement in the current scope.\n         * @param {string} statementType node.kind, one of: \"var\", \"let\", or \"const\"\n         * @param {ASTNode[]} declarations List of declarations\n         * @returns {boolean} Returns true if it is the first var declaration, false if not.\n         * @private\n         */\n        function hasOnlyOneStatement(statementType, declarations) {\n\n            var declarationCounts = countDeclarations(declarations);\n            var currentOptions = options[statementType] || {};\n            var currentScope = getCurrentScope(statementType);\n\n            if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {\n                if (currentScope.uninitialized || currentScope.initialized) {\n                    return false;\n                }\n            }\n\n            if (declarationCounts.uninitialized > 0) {\n                if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {\n                    return false;\n                }\n            }\n            if (declarationCounts.initialized > 0) {\n                if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {\n                    return false;\n                }\n            }\n            recordTypes(statementType, declarations, currentScope);\n            return true;\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n            BlockStatement: startBlock,\n            ForStatement: startBlock,\n            ForInStatement: startBlock,\n            ForOfStatement: startBlock,\n            SwitchStatement: startBlock,\n\n            VariableDeclaration: function(node) {\n                var parent = node.parent,\n                    type, declarations, declarationCounts;\n\n                type = node.kind;\n                if (!options[type]) {\n                    return;\n                }\n\n                declarations = node.declarations;\n                declarationCounts = countDeclarations(declarations);\n\n                // always\n                if (!hasOnlyOneStatement(type, declarations)) {\n                    if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {\n                        context.report(node, \"Combine this with the previous '\" + type + \"' statement.\");\n                    } else {\n                        if (options[type].initialized === MODE_ALWAYS) {\n                            context.report(node, \"Combine this with the previous '\" + type + \"' statement with initialized variables.\");\n                        }\n                        if (options[type].uninitialized === MODE_ALWAYS) {\n                            context.report(node, \"Combine this with the previous '\" + type + \"' statement with uninitialized variables.\");\n                        }\n                    }\n                }\n\n                // never\n                if (parent.type !== \"ForStatement\" || parent.init !== node) {\n                    var totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;\n\n                    if (totalDeclarations > 1) {\n\n                        if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {\n\n                            // both initialized and uninitialized\n                            context.report(node, \"Split '\" + type + \"' declarations into multiple statements.\");\n                        } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {\n\n                            // initialized\n                            context.report(node, \"Split initialized '\" + type + \"' declarations into multiple statements.\");\n                        } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {\n\n                            // uninitialized\n                            context.report(node, \"Split uninitialized '\" + type + \"' declarations into multiple statements.\");\n                        }\n                    }\n                }\n            },\n\n            \"ForStatement:exit\": endBlock,\n            \"ForOfStatement:exit\": endBlock,\n            \"ForInStatement:exit\": endBlock,\n            \"SwitchStatement:exit\": endBlock,\n            \"BlockStatement:exit\": endBlock,\n            \"Program:exit\": endFunction,\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction\n        };\n\n    }\n};\n"]}