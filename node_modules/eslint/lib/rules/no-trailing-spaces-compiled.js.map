{"version":3,"sources":["no-trailing-spaces.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,kDADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,iBAAS,YAPP;;AASF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,gCAAgB;AACZ,0BAAM;AADM;AADR,aAFhB;AAOI,kCAAsB;AAP1B,SADI;AATN,KADO;;AAuBb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;AAEA,YAAI,cAAc,4CAAlB;YACI,aAAa,MAAM,WAAN,GAAoB,IADrC;YAEI,WAAW,cAAc,IAF7B;;AAIA,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAApC;YACI,iBAAiB,QAAQ,cAAR,IAA0B,KAD/C;;;;;;;;;AAUA,iBAAS,MAAT,CAAgB,IAAhB,EAAsB,QAAtB,EAAgC,QAAhC,EAA0C;;;;;;;;AAQtC,oBAAQ,MAAR,CAAe;AACX,sBAAM,IADK;AAEX,qBAAK,QAFM;AAGX,yBAAS,8BAHE;AAIX,qBAAK,UAAS,KAAT,EAAgB;AACjB,2BAAO,MAAM,WAAN,CAAkB,QAAlB,CAAP;AACH;AANU,aAAf;AAQH;;;;;;AAOD,eAAO;;AAEH,qBAAS,SAAS,mBAAT,CAA6B,IAA7B,EAAmC;;;;;AAKxC,oBAAI,KAAK,IAAI,MAAJ,CAAW,QAAX,CAAT;oBACI,YAAY,IAAI,MAAJ,CAAW,UAAX,CADhB;oBAEI,OAFJ;oBAGI,QAAQ,WAAW,KAHvB;oBAII,aAAa,WAAW,OAAX,GAAqB,KAArB,CAA2B,2BAA3B,CAJjB;oBAKI,QALJ;oBAMI,cAAc,CANlB;oBAOI,UAPJ;oBAQI,QARJ;oBASI,WAAW,EATf;oBAUI,cAVJ;;AAYA,qBAAK,IAAI,IAAI,CAAR,EAAW,KAAK,MAAM,MAA3B,EAAmC,IAAI,EAAvC,EAA2C,GAA3C,EAAgD;AAC5C,8BAAU,GAAG,IAAH,CAAQ,MAAM,CAAN,CAAR,CAAV;;;;;AAKA,wBAAI,kBAAkB,cAAc,WAAW,CAAX,CAAd,GAA8B,WAAW,CAAX,EAAc,MAA5C,GAAqD,CAA3E;AACA,wBAAI,aAAa,MAAM,CAAN,EAAS,MAAT,GAAkB,eAAnC;;AAEA,wBAAI,OAAJ,EAAa;AACT,mCAAW;AACP,kCAAM,IAAI,CADH;AAEP,oCAAQ,QAAQ;AAFT,yBAAX;;AAKA,qCAAa,cAAc,SAAS,MAApC;AACA,mCAAW,cAAc,UAAd,GAA2B,eAAtC;AACA,yCAAiB,WAAW,mBAAX,CAA+B,UAA/B,CAAjB;;AAEA,4BAAI,kBAAkB,eAAe,IAAf,KAAwB,iBAA1C,IACF,aAAa,eAAe,MAAf,CAAsB,KAAtB,CAA4B,CAA5B,CADX,IAEF,WAAW,eAAe,MAAf,CAAsB,KAAtB,CAA4B,CAA5B,CAFb,EAE6C;AACzC,2CAAe,UAAf;AACA;AACH;;;;AAID,4BAAI,kBAAkB,UAAU,IAAV,CAAe,MAAM,CAAN,CAAf,CAAtB,EAAgD;AAC5C;AACH;;AAED,mCAAW,CAAC,UAAD,EAAa,QAAb,CAAX;AACA,+BAAO,IAAP,EAAa,QAAb,EAAuB,QAAvB;AACH;;AAED,mCAAe,UAAf;AACH;AACJ;;AAzDE,SAAP;AA4DH;AA3HY,CAAjB","file":"no-trailing-spaces-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow trailing spaces at the end of lines.\n * @author Nodeca Team <https://github.com/nodeca>\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow trailing whitespace at the end of lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    skipBlankLines: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        var BLANK_CLASS = \"[ \\t\\u00a0\\u2000-\\u200b\\u2028\\u2029\\u3000]\",\n            SKIP_BLANK = \"^\" + BLANK_CLASS + \"*$\",\n            NONBLANK = BLANK_CLASS + \"+$\";\n\n        var options = context.options[0] || {},\n            skipBlankLines = options.skipBlankLines || false;\n\n        /**\n         * Report the error message\n         * @param {ASTNode} node node to report\n         * @param {int[]} location range information\n         * @param {int[]} fixRange Range based on the whole program\n         * @returns {void}\n         */\n        function report(node, location, fixRange) {\n\n            /*\n             * Passing node is a bit dirty, because message data will contain big\n             * text in `source`. But... who cares :) ?\n             * One more kludge will not make worse the bloody wizardry of this\n             * plugin.\n             */\n            context.report({\n                node: node,\n                loc: location,\n                message: \"Trailing spaces not allowed.\",\n                fix: function(fixer) {\n                    return fixer.removeRange(fixRange);\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            Program: function checkTrailingSpaces(node) {\n\n                // Let's hack. Since Espree does not return whitespace nodes,\n                // fetch the source code and do matching via regexps.\n\n                var re = new RegExp(NONBLANK),\n                    skipMatch = new RegExp(SKIP_BLANK),\n                    matches,\n                    lines = sourceCode.lines,\n                    linebreaks = sourceCode.getText().match(/\\r\\n|\\r|\\n|\\u2028|\\u2029/g),\n                    location,\n                    totalLength = 0,\n                    rangeStart,\n                    rangeEnd,\n                    fixRange = [],\n                    containingNode;\n\n                for (var i = 0, ii = lines.length; i < ii; i++) {\n                    matches = re.exec(lines[i]);\n\n                    // Always add linebreak length to line length to accommodate for line break (\\n or \\r\\n)\n                    // Because during the fix time they also reserve one spot in the array.\n                    // Usually linebreak length is 2 for \\r\\n (CRLF) and 1 for \\n (LF)\n                    var linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;\n                    var lineLength = lines[i].length + linebreakLength;\n\n                    if (matches) {\n                        location = {\n                            line: i + 1,\n                            column: matches.index\n                        };\n\n                        rangeStart = totalLength + location.column;\n                        rangeEnd = totalLength + lineLength - linebreakLength;\n                        containingNode = sourceCode.getNodeByRangeIndex(rangeStart);\n\n                        if (containingNode && containingNode.type === \"TemplateElement\" &&\n                          rangeStart > containingNode.parent.range[0] &&\n                          rangeEnd < containingNode.parent.range[1]) {\n                            totalLength += lineLength;\n                            continue;\n                        }\n\n                        // If the line has only whitespace, and skipBlankLines\n                        // is true, don't report it\n                        if (skipBlankLines && skipMatch.test(lines[i])) {\n                            continue;\n                        }\n\n                        fixRange = [rangeStart, rangeEnd];\n                        report(node, location, fixRange);\n                    }\n\n                    totalLength += lineLength;\n                }\n            }\n\n        };\n    }\n};\n"]}