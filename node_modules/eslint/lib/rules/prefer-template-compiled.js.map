{"version":3,"sources":["prefer-template.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;;;;;;AAWA,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3B,WAAO,KAAK,IAAL,KAAc,kBAAd,IAAoC,KAAK,QAAL,KAAkB,GAA7D;AACH;;;;;;;AAOD,SAAS,4BAAT,CAAsC,IAAtC,EAA4C;AACxC,WAAO,gBAAgB,KAAK,MAArB,CAAP,EAAqC;AACjC,eAAO,KAAK,MAAZ;AACH;AACD,WAAO,IAAP;AACH;;;;;;;AAOD,SAAS,mBAAT,CAA6B,IAA7B,EAAmC;AAC/B,QAAI,gBAAgB,IAAhB,CAAJ,EAA2B;;;AAGvB,eAAO,oBAAoB,KAAK,KAAzB,KAAmC,oBAAoB,KAAK,IAAzB,CAA1C;AACH;AACD,WAAO,CAAC,SAAS,eAAT,CAAyB,IAAzB,CAAR;AACH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,2DADX;AAEF,sBAAU,cAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,OAAO,OAAO,MAAP,CAAc,IAAd,CAAX;;;;;;;;AAQA,iBAAS,oBAAT,CAA8B,IAA9B,EAAoC;AAChC,gBAAI,CAAC,SAAS,eAAT,CAAyB,IAAzB,CAAD,IAAmC,CAAC,gBAAgB,KAAK,MAArB,CAAxC,EAAsE;AAClE;AACH;;AAED,gBAAI,gBAAgB,6BAA6B,KAAK,MAAlC,CAApB;;;AAGA,gBAAI,KAAK,cAAc,KAAd,CAAoB,CAApB,CAAL,CAAJ,EAAkC;AAC9B;AACH;AACD,iBAAK,cAAc,KAAd,CAAoB,CAApB,CAAL,IAA+B,IAA/B;;AAEA,gBAAI,oBAAoB,aAApB,CAAJ,EAAwC;AACpC,wBAAQ,MAAR,CACI,aADJ,EAEI,kCAFJ;AAGH;AACJ;;AAED,eAAO;AACH,qBAAS,YAAW;AAChB,uBAAO,OAAO,MAAP,CAAc,IAAd,CAAP;AACH,aAHE;;AAKH,qBAAS,oBALN;AAMH,6BAAiB;AANd,SAAP;AAQH;AAhDY,CAAjB","file":"prefer-template-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to suggest using template literals instead of string concatenation.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Gets the top binary expression node for concatenation in parents of a given node.\n * @param {ASTNode} node - A node to get.\n * @returns {ASTNode} the top binary expression node in parents of a given node.\n */\nfunction getTopConcatBinaryExpression(node) {\n    while (isConcatenation(node.parent)) {\n        node = node.parent;\n    }\n    return node;\n}\n\n/**\n * Checks whether or not a given binary expression has non string literals.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node has non string literals.\n */\nfunction hasNonStringLiteral(node) {\n    if (isConcatenation(node)) {\n\n        // `left` is deeper than `right` normally.\n        return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);\n    }\n    return !astUtils.isStringLiteral(node);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require template literals instead of string concatenation\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var done = Object.create(null);\n\n        /**\n         * Reports if a given node is string concatenation with non string literals.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkForStringConcat(node) {\n            if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {\n                return;\n            }\n\n            var topBinaryExpr = getTopConcatBinaryExpression(node.parent);\n\n            // Checks whether or not this node had been checked already.\n            if (done[topBinaryExpr.range[0]]) {\n                return;\n            }\n            done[topBinaryExpr.range[0]] = true;\n\n            if (hasNonStringLiteral(topBinaryExpr)) {\n                context.report(\n                    topBinaryExpr,\n                    \"Unexpected string concatenation.\");\n            }\n        }\n\n        return {\n            Program: function() {\n                done = Object.create(null);\n            },\n\n            Literal: checkForStringConcat,\n            TemplateLiteral: checkForStringConcat\n        };\n    }\n};\n"]}