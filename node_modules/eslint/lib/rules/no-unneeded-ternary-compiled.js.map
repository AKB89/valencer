{"version":3,"sources":["no-unneeded-ternary.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,4DADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,mCAAmB;AACf,0BAAM;AADS;AADX,aAFhB;AAOI,kCAAsB;AAP1B,SADI;AAPN,KADO;;AAqBb,YAAQ,gBAAS,OAAT,EAAkB;AACtB,YAAI,UAAU,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAApC;AACA,YAAI,oBAAoB,QAAQ,iBAAR,KAA8B,KAAtD;;;;;;;;AAQA,iBAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC5B,mBAAO,KAAK,IAAL,KAAc,SAAd,IAA2B,OAAO,KAAK,KAAZ,KAAsB,SAAxD;AACH;;;;;;;;AAQD,iBAAS,wBAAT,CAAkC,IAAlC,EAAwC;AACpC,mBAAO,KAAK,IAAL,CAAU,IAAV,KAAmB,YAAnB,IACA,KAAK,UAAL,CAAgB,IAAhB,KAAyB,YADzB,IAEA,KAAK,IAAL,CAAU,IAAV,KAAmB,KAAK,UAAL,CAAgB,IAF1C;AAGH;;AAED,eAAO;;AAEH,mCAAuB,+BAAS,IAAT,EAAe;AAClC,oBAAI,iBAAiB,KAAK,SAAtB,KAAoC,iBAAiB,KAAK,UAAtB,CAAxC,EAA2E;AACvE,4BAAQ,MAAR,CAAe,IAAf,EAAqB,KAAK,UAAL,CAAgB,GAAhB,CAAoB,KAAzC,EAAgD,+DAAhD;AACH,iBAFD,MAEO,IAAI,CAAC,iBAAD,IAAsB,yBAAyB,IAAzB,CAA1B,EAA0D;AAC7D,4BAAQ,MAAR,CAAe,IAAf,EAAqB,KAAK,UAAL,CAAgB,GAAhB,CAAoB,KAAzC,EAAgD,kEAAhD;AACH;AACJ;AARE,SAAP;AAUH;AAzDY,CAAjB","file":"no-unneeded-ternary-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag no-unneeded-ternary\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow ternary operators when simpler alternatives exist\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    defaultAssignment: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = context.options[0] || {};\n        var defaultAssignment = options.defaultAssignment !== false;\n\n        /**\n         * Test if the node is a boolean literal\n         * @param {ASTNode} node - The node to report.\n         * @returns {boolean} True if the its a boolean literal\n         * @private\n         */\n        function isBooleanLiteral(node) {\n            return node.type === \"Literal\" && typeof node.value === \"boolean\";\n        }\n\n        /**\n         * Test if the node matches the pattern id ? id : expression\n         * @param {ASTNode} node - The ConditionalExpression to check.\n         * @returns {boolean} True if the pattern is matched, and false otherwise\n         * @private\n         */\n        function matchesDefaultAssignment(node) {\n            return node.test.type === \"Identifier\" &&\n                   node.consequent.type === \"Identifier\" &&\n                   node.test.name === node.consequent.name;\n        }\n\n        return {\n\n            ConditionalExpression: function(node) {\n                if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {\n                    context.report(node, node.consequent.loc.start, \"Unnecessary use of boolean literals in conditional expression\");\n                } else if (!defaultAssignment && matchesDefaultAssignment(node)) {\n                    context.report(node, node.consequent.loc.start, \"Unnecessary use of conditional expression for default assignment\");\n                }\n            }\n        };\n    }\n};\n"]}