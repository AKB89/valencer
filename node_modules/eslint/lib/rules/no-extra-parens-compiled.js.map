{"version":3,"sources":["no-extra-parens.js"],"names":[],"mappings":"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","file":"no-extra-parens-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow parenthesising higher precedence subexpressions.\n * @author Michael Ficarra\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils.js\");\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary parentheses\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: {\n            anyOf: [\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"functions\"]\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 1\n                },\n                {\n                    type: \"array\",\n                    items: [\n                        {\n                            enum: [\"all\"]\n                        },\n                        {\n                            type: \"object\",\n                            properties: {\n                                conditionalAssign: {type: \"boolean\"},\n                                nestedBinaryExpressions: {type: \"boolean\"},\n                                returnAssign: {type: \"boolean\"}\n                            },\n                            additionalProperties: false\n                        }\n                    ],\n                    minItems: 0,\n                    maxItems: 2\n                }\n            ]\n        }\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        var isParenthesised = astUtils.isParenthesised.bind(astUtils, sourceCode);\n        var ALL_NODES = context.options[0] !== \"functions\";\n        var EXCEPT_COND_ASSIGN = ALL_NODES && context.options[1] && context.options[1].conditionalAssign === false;\n        var NESTED_BINARY = ALL_NODES && context.options[1] && context.options[1].nestedBinaryExpressions === false;\n        var EXCEPT_RETURN_ASSIGN = ALL_NODES && context.options[1] && context.options[1].returnAssign === false;\n\n        /**\n         * Determines if this rule should be enforced for a node given the current configuration.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the rule should be enforced for this node.\n         * @private\n         */\n        function ruleApplies(node) {\n            return ALL_NODES || node.type === \"FunctionExpression\" || node.type === \"ArrowFunctionExpression\";\n        }\n\n        /**\n         * Determines if a node is surrounded by parentheses twice.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is doubly parenthesised.\n         * @private\n         */\n        function isParenthesisedTwice(node) {\n            var previousToken = sourceCode.getTokenBefore(node, 1),\n                nextToken = sourceCode.getTokenAfter(node, 1);\n\n            return isParenthesised(node) && previousToken && nextToken &&\n                previousToken.value === \"(\" && previousToken.range[1] <= node.range[0] &&\n                nextToken.value === \")\" && nextToken.range[0] >= node.range[1];\n        }\n\n        /**\n         * Determines if a node is surrounded by (potentially) invalid parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParens(node) {\n            return ruleApplies(node) && isParenthesised(node);\n        }\n\n        /**\n         * Determines if a node that is expected to be parenthesised is surrounded by\n         * (potentially) invalid extra parentheses.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is has an unexpected extra pair of parentheses.\n         * @private\n         */\n        function hasDoubleExcessParens(node) {\n            return ruleApplies(node) && isParenthesisedTwice(node);\n        }\n\n        /**\n         * Determines if a node test expression is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isCondAssignException(node) {\n            return EXCEPT_COND_ASSIGN && node.test.type === \"AssignmentExpression\";\n        }\n\n        /**\n         * Determines if a node is in a return statement\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is in a return statement.\n         * @private\n         */\n        function isInReturnStatement(node) {\n            while (node) {\n                if (node.type === \"ReturnStatement\" ||\n                        (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\")) {\n                    return true;\n                }\n                node = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is or contains an assignment expression\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is or contains an assignment expression.\n         * @private\n         */\n        function containsAssignment(node) {\n            if (node.type === \"AssignmentExpression\") {\n                return true;\n            } else if (node.type === \"ConditionalExpression\" &&\n                    (node.consequent.type === \"AssignmentExpression\" || node.alternate.type === \"AssignmentExpression\")) {\n                return true;\n            } else if ((node.left && node.left.type === \"AssignmentExpression\") ||\n                    (node.right && node.right.type === \"AssignmentExpression\")) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Determines if a node is contained by or is itself a return statement and is allowed to have a parenthesised assignment\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the assignment can be parenthesised.\n         * @private\n         */\n        function isReturnAssignException(node) {\n            if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {\n                return false;\n            }\n\n            if (node.type === \"ReturnStatement\") {\n                return node.argument && containsAssignment(node.argument);\n            } else if (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") {\n                return containsAssignment(node.body);\n            } else {\n                return containsAssignment(node);\n            }\n        }\n\n        /**\n         * Determines if a node following a [no LineTerminator here] restriction is\n         * surrounded by (potentially) invalid extra parentheses.\n         * @param {Token} token - The token preceding the [no LineTerminator here] restriction.\n         * @param {ASTNode} node - The node to be checked.\n         * @returns {boolean} True if the node is incorrectly parenthesised.\n         * @private\n         */\n        function hasExcessParensNoLineTerminator(token, node) {\n            if (token.loc.end.line === node.loc.start.line) {\n                return hasExcessParens(node);\n            }\n\n            return hasDoubleExcessParens(node);\n        }\n\n        /**\n         * Checks whether or not a given node is located at the head of ExpressionStatement.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is located at the head of ExpressionStatement.\n         */\n        function isHeadOfExpressionStatement(node) {\n            var parent = node.parent;\n\n            while (parent) {\n                switch (parent.type) {\n                    case \"SequenceExpression\":\n                        if (parent.expressions[0] !== node || isParenthesised(node)) {\n                            return false;\n                        }\n                        break;\n\n                    case \"UnaryExpression\":\n                    case \"UpdateExpression\":\n                        if (parent.prefix || isParenthesised(node)) {\n                            return false;\n                        }\n                        break;\n\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        if (parent.left !== node || isParenthesised(node)) {\n                            return false;\n                        }\n                        break;\n\n                    case \"ConditionalExpression\":\n                        if (parent.test !== node || isParenthesised(node)) {\n                            return false;\n                        }\n                        break;\n\n                    case \"CallExpression\":\n                        if (parent.callee !== node || isParenthesised(node)) {\n                            return false;\n                        }\n                        break;\n\n                    case \"MemberExpression\":\n                        if (parent.object !== node || isParenthesised(node)) {\n                            return false;\n                        }\n                        break;\n\n                    case \"ExpressionStatement\":\n                        return true;\n\n                    default:\n                        return false;\n                }\n\n                node = parent;\n                parent = parent.parent;\n            }\n\n            /* istanbul ignore next */\n            throw new Error(\"unreachable\");\n        }\n\n        /**\n         * Get the precedence level based on the node type\n         * @param {ASTNode} node node to evaluate\n         * @returns {int} precedence level\n         * @private\n         */\n        function precedence(node) {\n\n            switch (node.type) {\n                case \"SequenceExpression\":\n                    return 0;\n\n                case \"AssignmentExpression\":\n                case \"ArrowFunctionExpression\":\n                case \"YieldExpression\":\n                    return 1;\n\n                case \"ConditionalExpression\":\n                    return 3;\n\n                case \"LogicalExpression\":\n                    switch (node.operator) {\n                        case \"||\":\n                            return 4;\n                        case \"&&\":\n                            return 5;\n\n                        // no default\n                    }\n\n                    /* falls through */\n\n                case \"BinaryExpression\":\n\n                    switch (node.operator) {\n                        case \"|\":\n                            return 6;\n                        case \"^\":\n                            return 7;\n                        case \"&\":\n                            return 8;\n                        case \"==\":\n                        case \"!=\":\n                        case \"===\":\n                        case \"!==\":\n                            return 9;\n                        case \"<\":\n                        case \"<=\":\n                        case \">\":\n                        case \">=\":\n                        case \"in\":\n                        case \"instanceof\":\n                            return 10;\n                        case \"<<\":\n                        case \">>\":\n                        case \">>>\":\n                            return 11;\n                        case \"+\":\n                        case \"-\":\n                            return 12;\n                        case \"*\":\n                        case \"/\":\n                        case \"%\":\n                            return 13;\n\n                        // no default\n                    }\n\n                    /* falls through */\n\n                case \"UnaryExpression\":\n                    return 14;\n\n                case \"UpdateExpression\":\n                    return 15;\n\n                case \"CallExpression\":\n\n                    // IIFE is allowed to have parens in any position (#655)\n                    if (node.callee.type === \"FunctionExpression\") {\n                        return -1;\n                    }\n                    return 16;\n\n                case \"NewExpression\":\n                    return 17;\n\n                // no default\n            }\n            return 18;\n        }\n\n        /**\n         * Report the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function report(node) {\n            var previousToken = sourceCode.getTokenBefore(node);\n\n            context.report(node, previousToken.loc.start, \"Gratuitous parentheses around expression.\");\n        }\n\n        /**\n         * Evaluate Unary update\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function dryUnaryUpdate(node) {\n            if (hasExcessParens(node.argument) && precedence(node.argument) >= precedence(node)) {\n                report(node.argument);\n            }\n        }\n\n        /**\n         * Evaluate a new call\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function dryCallNew(node) {\n            if (hasExcessParens(node.callee) && precedence(node.callee) >= precedence(node) && !(\n                node.type === \"CallExpression\" &&\n                node.callee.type === \"FunctionExpression\" &&\n\n                // One set of parentheses are allowed for a function expression\n                !hasDoubleExcessParens(node.callee)\n            )) {\n                report(node.callee);\n            }\n            if (node.arguments.length === 1) {\n                if (hasDoubleExcessParens(node.arguments[0]) && precedence(node.arguments[0]) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(node.arguments[0]);\n                }\n            } else {\n                [].forEach.call(node.arguments, function(arg) {\n                    if (hasExcessParens(arg) && precedence(arg) >= precedence({type: \"AssignmentExpression\"})) {\n                        report(arg);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Evaluate binary logicals\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function dryBinaryLogical(node) {\n            if (!NESTED_BINARY) {\n                var prec = precedence(node);\n\n                if (hasExcessParens(node.left) && precedence(node.left) >= prec) {\n                    report(node.left);\n                }\n                if (hasExcessParens(node.right) && precedence(node.right) > prec) {\n                    report(node.right);\n                }\n            }\n        }\n\n        return {\n            ArrayExpression: function(node) {\n                [].forEach.call(node.elements, function(e) {\n                    if (e && hasExcessParens(e) && precedence(e) >= precedence({type: \"AssignmentExpression\"})) {\n                        report(e);\n                    }\n                });\n            },\n\n            ArrowFunctionExpression: function(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.body.type !== \"BlockStatement\") {\n                    if (sourceCode.getFirstToken(node.body).value !== \"{\" && hasExcessParens(node.body) && precedence(node.body) >= precedence({type: \"AssignmentExpression\"})) {\n                        report(node.body);\n                        return;\n                    }\n\n                    // Object literals *must* be parenthesised\n                    if (node.body.type === \"ObjectExpression\" && hasDoubleExcessParens(node.body)) {\n                        report(node.body);\n                        return;\n                    }\n                }\n            },\n\n            AssignmentExpression: function(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.right) && precedence(node.right) >= precedence(node)) {\n                    report(node.right);\n                }\n            },\n\n            BinaryExpression: dryBinaryLogical,\n            CallExpression: dryCallNew,\n\n            ConditionalExpression: function(node) {\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (hasExcessParens(node.test) && precedence(node.test) >= precedence({type: \"LogicalExpression\", operator: \"||\"})) {\n                    report(node.test);\n                }\n\n                if (hasExcessParens(node.consequent) && precedence(node.consequent) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(node.consequent);\n                }\n\n                if (hasExcessParens(node.alternate) && precedence(node.alternate) >= precedence({type: \"AssignmentExpression\"})) {\n                    report(node.alternate);\n                }\n            },\n\n            DoWhileStatement: function(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            ExpressionStatement: function(node) {\n                var firstToken, secondToken, firstTokens;\n\n                if (hasExcessParens(node.expression)) {\n                    firstTokens = sourceCode.getFirstTokens(node.expression, 2);\n                    firstToken = firstTokens[0];\n                    secondToken = firstTokens[1];\n\n                    if (\n                        !firstToken ||\n                        firstToken.value !== \"{\" &&\n                        firstToken.value !== \"function\" &&\n                        firstToken.value !== \"class\" &&\n                        (\n                            firstToken.value !== \"let\" ||\n                            !secondToken ||\n                            secondToken.value !== \"[\"\n                        )\n                    ) {\n                        report(node.expression);\n                    }\n                }\n            },\n\n            ForInStatement: function(node) {\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForOfStatement: function(node) {\n                if (hasExcessParens(node.right)) {\n                    report(node.right);\n                }\n            },\n\n            ForStatement: function(node) {\n                if (node.init && hasExcessParens(node.init)) {\n                    report(node.init);\n                }\n\n                if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n\n                if (node.update && hasExcessParens(node.update)) {\n                    report(node.update);\n                }\n            },\n\n            IfStatement: function(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            LogicalExpression: dryBinaryLogical,\n\n            MemberExpression: function(node) {\n                if (\n                    hasExcessParens(node.object) &&\n                    precedence(node.object) >= precedence(node) &&\n                    (\n                        node.computed ||\n                        !(\n                            (node.object.type === \"Literal\" &&\n                            typeof node.object.value === \"number\" &&\n                            /^[0-9]+$/.test(sourceCode.getFirstToken(node.object).value))\n                            ||\n\n                            // RegExp literal is allowed to have parens (#1589)\n                            (node.object.type === \"Literal\" && node.object.regex)\n                        )\n                    ) &&\n                    !(\n                        (node.object.type === \"FunctionExpression\" || node.object.type === \"ClassExpression\") &&\n                        isHeadOfExpressionStatement(node) &&\n                        !hasDoubleExcessParens(node.object)\n                    )\n                ) {\n                    report(node.object);\n                }\n                if (node.computed && hasExcessParens(node.property)) {\n                    report(node.property);\n                }\n            },\n\n            NewExpression: dryCallNew,\n\n            ObjectExpression: function(node) {\n                [].forEach.call(node.properties, function(e) {\n                    var v = e.value;\n\n                    if (v && hasExcessParens(v) && precedence(v) >= precedence({type: \"AssignmentExpression\"})) {\n                        report(v);\n                    }\n                });\n            },\n\n            ReturnStatement: function(node) {\n                var returnToken = sourceCode.getFirstToken(node);\n\n                if (isReturnAssignException(node)) {\n                    return;\n                }\n\n                if (node.argument &&\n                        hasExcessParensNoLineTerminator(returnToken, node.argument) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.argument.type === \"Literal\" && node.argument.regex)) {\n                    report(node.argument);\n                }\n            },\n\n            SequenceExpression: function(node) {\n                [].forEach.call(node.expressions, function(e) {\n                    if (hasExcessParens(e) && precedence(e) >= precedence(node)) {\n                        report(e);\n                    }\n                });\n            },\n\n            SwitchCase: function(node) {\n                if (node.test && hasExcessParens(node.test)) {\n                    report(node.test);\n                }\n            },\n\n            SwitchStatement: function(node) {\n                if (hasDoubleExcessParens(node.discriminant)) {\n                    report(node.discriminant);\n                }\n            },\n\n            ThrowStatement: function(node) {\n                var throwToken = sourceCode.getFirstToken(node);\n\n                if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {\n                    report(node.argument);\n                }\n            },\n\n            UnaryExpression: dryUnaryUpdate,\n            UpdateExpression: dryUnaryUpdate,\n\n            VariableDeclarator: function(node) {\n                if (node.init && hasExcessParens(node.init) &&\n                        precedence(node.init) >= precedence({type: \"AssignmentExpression\"}) &&\n\n                        // RegExp literal is allowed to have parens (#1589)\n                        !(node.init.type === \"Literal\" && node.init.regex)) {\n                    report(node.init);\n                }\n            },\n\n            WhileStatement: function(node) {\n                if (hasDoubleExcessParens(node.test) && !isCondAssignException(node)) {\n                    report(node.test);\n                }\n            },\n\n            WithStatement: function(node) {\n                if (hasDoubleExcessParens(node.object)) {\n                    report(node.object);\n                }\n            },\n\n            YieldExpression: function(node) {\n                var yieldToken;\n\n                if (node.argument) {\n                    yieldToken = sourceCode.getFirstToken(node);\n\n                    if ((precedence(node.argument) >= precedence(node) &&\n                            hasExcessParensNoLineTerminator(yieldToken, node.argument)) ||\n                            hasDoubleExcessParens(node.argument)) {\n                        report(node.argument);\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]}