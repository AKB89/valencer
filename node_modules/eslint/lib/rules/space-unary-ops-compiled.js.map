{"version":3,"sources":["space-unary-ops.js"],"names":[],"mappings":"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","file":"space-unary-ops-compiled.js","sourcesContent":["/**\n * @fileoverview This rule shoud require or disallow spaces before or after unary operations.\n * @author Marcin Kumorek\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing before or after unary operators\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    words: {\n                        type: \"boolean\"\n                    },\n                    nonwords: {\n                        type: \"boolean\"\n                    },\n                    overrides: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"boolean\"\n                        }\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = context.options && Array.isArray(context.options) && context.options[0] || { words: true, nonwords: false };\n\n        var sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n        * Check if the node is the first \"!\" in a \"!!\" convert to Boolean expression\n        * @param {ASTnode} node AST node\n        * @returns {boolean} Whether or not the node is first \"!\" in \"!!\"\n        */\n        function isFirstBangInBangBangExpression(node) {\n            return node && node.type === \"UnaryExpression\" && node.argument.operator === \"!\" &&\n                node.argument && node.argument.type === \"UnaryExpression\" && node.argument.operator === \"!\";\n        }\n\n        /**\n        * Check if the node's child argument is an \"ObjectExpression\"\n        * @param {ASTnode} node AST node\n        * @returns {boolean} Whether or not the argument's type is \"ObjectExpression\"\n        */\n        function isArgumentObjectExpression(node) {\n            return node.argument && node.argument.type && node.argument.type === \"ObjectExpression\";\n        }\n\n        /**\n        * Checks if an override exists for a given operator.\n        * @param {ASTnode} node AST node\n        * @param {string} operator Operator\n        * @returns {boolean} Whether or not an override has been provided for the operator\n        */\n        function overrideExistsForOperator(node, operator) {\n            return options.overrides && options.overrides.hasOwnProperty(operator);\n        }\n\n        /**\n        * Gets the value that the override was set to for this operator\n        * @param {ASTnode} node AST node\n        * @param {string} operator Operator\n        * @returns {boolean} Whether or not an override enforces a space with this operator\n        */\n        function overrideEnforcesSpaces(node, operator) {\n            return options.overrides[operator];\n        }\n\n        /**\n        * Verify Unary Word Operator has spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {object} firstToken first token from the AST node\n        * @param {object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function verifyWordHasSpaces(node, firstToken, secondToken, word) {\n            if (secondToken.range[0] === firstToken.range[1]) {\n                context.report({\n                    node: node,\n                    message: \"Unary word operator '\" + word + \"' must be followed by whitespace.\",\n                    fix: function(fixer) {\n                        return fixer.insertTextAfter(firstToken, \" \");\n                    }\n                });\n            }\n        }\n\n        /**\n        * Verify Unary Word Operator doesn't have spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {object} firstToken first token from the AST node\n        * @param {object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {\n            if (isArgumentObjectExpression(node)) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node: node,\n                        message: \"Unexpected space after unary word operator '\" + word + \"'.\",\n                        fix: function(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Check Unary Word Operators for spaces after the word operator\n        * @param {ASTnode} node AST node\n        * @param {object} firstToken first token from the AST node\n        * @param {object} secondToken second token from the AST node\n        * @param {string} word The word to be used for reporting\n        * @returns {void}\n        */\n        function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {\n            word = word || firstToken.value;\n\n            if (overrideExistsForOperator(node, word)) {\n                if (overrideEnforcesSpaces(node, word)) {\n                    verifyWordHasSpaces(node, firstToken, secondToken, word);\n                } else {\n                    verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n                }\n            } else if (options.words) {\n                verifyWordHasSpaces(node, firstToken, secondToken, word);\n            } else {\n                verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);\n            }\n        }\n\n        /**\n        * Verifies YieldExpressions satisfy spacing requirements\n        * @param {ASTnode} node AST node\n        * @returns {void}\n        */\n        function checkForSpacesAfterYield(node) {\n            var tokens = sourceCode.getFirstTokens(node, 3),\n                word = \"yield\";\n\n            if (!node.argument || node.delegate) {\n                return;\n            }\n\n            checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression have spaces before or after the operator\n        * @param {ASTnode} node AST node\n        * @param {object} firstToken First token in the expression\n        * @param {object} secondToken Second token in the expression\n        * @returns {void}\n        */\n        function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (isFirstBangInBangBangExpression(node)) {\n                    return;\n                }\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node: node,\n                        message: \"Unary operator '\" + firstToken.value + \"' must be followed by whitespace.\",\n                        fix: function(fixer) {\n                            return fixer.insertTextAfter(firstToken, \" \");\n                        }\n                    });\n                }\n            } else {\n                if (firstToken.range[1] === secondToken.range[0]) {\n                    context.report({\n                        node: node,\n                        message: \"Space is required before unary expressions '\" + secondToken.value + \"'.\",\n                        fix: function(fixer) {\n                            return fixer.insertTextBefore(secondToken, \" \");\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression don't have spaces before or after the operator\n        * @param {ASTnode} node AST node\n        * @param {object} firstToken First token in the expression\n        * @param {object} secondToken Second token in the expression\n        * @returns {void}\n        */\n        function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {\n            if (node.prefix) {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node: node,\n                        message: \"Unexpected space after unary operator '\" + firstToken.value + \"'.\",\n                        fix: function(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            } else {\n                if (secondToken.range[0] > firstToken.range[1]) {\n                    context.report({\n                        node: node,\n                        message: \"Unexpected space before unary operator '\" + secondToken.value + \"'.\",\n                        fix: function(fixer) {\n                            return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);\n                        }\n                    });\n                }\n            }\n        }\n\n        /**\n        * Verifies UnaryExpression, UpdateExpression and NewExpression satisfy spacing requirements\n        * @param {ASTnode} node AST node\n        * @returns {void}\n        */\n        function checkForSpaces(node) {\n            var tokens = sourceCode.getFirstTokens(node, 2),\n                firstToken = tokens[0],\n                secondToken = tokens[1];\n\n            if ((node.type === \"NewExpression\" || node.prefix) && firstToken.type === \"Keyword\") {\n                checkUnaryWordOperatorForSpaces(node, firstToken, secondToken);\n                return;\n            }\n\n            var operator = node.prefix ? tokens[0].value : tokens[1].value;\n\n            if (overrideExistsForOperator(node, operator)) {\n                if (overrideEnforcesSpaces(node, operator)) {\n                    verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n                } else {\n                    verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n                }\n            } else if (options.nonwords) {\n                verifyNonWordsHaveSpaces(node, firstToken, secondToken);\n            } else {\n                verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            UnaryExpression: checkForSpaces,\n            UpdateExpression: checkForSpaces,\n            NewExpression: checkForSpaces,\n            YieldExpression: checkForSpacesAfterYield\n        };\n\n    }\n};\n"]}