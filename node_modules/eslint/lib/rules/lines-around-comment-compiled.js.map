{"version":3,"sources":["lines-around-comment.js"],"names":[],"mappings":"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","file":"lines-around-comment-compiled.js","sourcesContent":["/**\n * @fileoverview Enforces empty lines around comments.\n * @author Jamund Ferguson\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar lodash = require(\"lodash\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Return an array with with any line numbers that are empty.\n * @param {Array} lines An array of each line of the file.\n * @returns {Array} An array of line numbers.\n */\nfunction getEmptyLineNums(lines) {\n    var emptyLines = lines.map(function(line, i) {\n        return {\n            code: line.trim(),\n            num: i + 1\n        };\n    }).filter(function(line) {\n        return !line.code;\n    }).map(function(line) {\n        return line.num;\n    });\n\n    return emptyLines;\n}\n\n/**\n * Return an array with with any line numbers that contain comments.\n * @param {Array} comments An array of comment nodes.\n * @returns {Array} An array of line numbers.\n */\nfunction getCommentLineNums(comments) {\n    var lines = [];\n\n    comments.forEach(function(token) {\n        var start = token.loc.start.line;\n        var end = token.loc.end.line;\n\n        lines.push(start, end);\n    });\n    return lines;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require empty lines around comments\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    beforeBlockComment: {\n                        type: \"boolean\"\n                    },\n                    afterBlockComment: {\n                        type: \"boolean\"\n                    },\n                    beforeLineComment: {\n                        type: \"boolean\"\n                    },\n                    afterLineComment: {\n                        type: \"boolean\"\n                    },\n                    allowBlockStart: {\n                        type: \"boolean\"\n                    },\n                    allowBlockEnd: {\n                        type: \"boolean\"\n                    },\n                    allowObjectStart: {\n                        type: \"boolean\"\n                    },\n                    allowObjectEnd: {\n                        type: \"boolean\"\n                    },\n                    allowArrayStart: {\n                        type: \"boolean\"\n                    },\n                    allowArrayEnd: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var options = context.options[0] ? lodash.assign({}, context.options[0]) : {};\n\n        options.beforeLineComment = options.beforeLineComment || false;\n        options.afterLineComment = options.afterLineComment || false;\n        options.beforeBlockComment = typeof options.beforeBlockComment !== \"undefined\" ? options.beforeBlockComment : true;\n        options.afterBlockComment = options.afterBlockComment || false;\n        options.allowBlockStart = options.allowBlockStart || false;\n        options.allowBlockEnd = options.allowBlockEnd || false;\n\n        var sourceCode = context.getSourceCode();\n\n        var lines = sourceCode.lines,\n            numLines = lines.length + 1,\n            comments = sourceCode.getAllComments(),\n            commentLines = getCommentLineNums(comments),\n            emptyLines = getEmptyLineNums(lines),\n            commentAndEmptyLines = commentLines.concat(emptyLines);\n\n        /**\n         * Returns whether or not a token is a comment node type\n         * @param {Token} token The token to check\n         * @returns {boolean} True if the token is a comment node\n         */\n        function isCommentNodeType(token) {\n            return token && (token.type === \"Block\" || token.type === \"Line\");\n        }\n\n        /**\n         * Returns whether or not comments are on lines starting with or ending with code\n         * @param {ASTNode} node The comment node to check.\n         * @returns {boolean} True if the comment is not alone.\n         */\n        function codeAroundComment(node) {\n            var token;\n\n            token = node;\n            do {\n                token = sourceCode.getTokenOrCommentBefore(token);\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(token, node)) {\n                return true;\n            }\n\n            token = node;\n            do {\n                token = sourceCode.getTokenOrCommentAfter(token);\n            } while (isCommentNodeType(token));\n\n            if (token && astUtils.isTokenOnSameLine(node, token)) {\n                return true;\n            }\n\n            return false;\n        }\n\n        /**\n         * Returns whether or not comments are inside a node type or not.\n         * @param {ASTNode} node The Comment node.\n         * @param {ASTNode} parent The Comment parent node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is inside nodeType.\n         */\n        function isCommentInsideNodeType(node, parent, nodeType) {\n            return parent.type === nodeType ||\n                (parent.body && parent.body.type === nodeType) ||\n                (parent.consequent && parent.consequent.type === nodeType);\n        }\n\n        /**\n         * Returns whether or not comments are at the parent start or not.\n         * @param {ASTNode} node The Comment node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent start.\n         */\n        function isCommentAtParentStart(node, nodeType) {\n            var ancestors = context.getAncestors();\n            var parent;\n\n            if (ancestors.length) {\n                parent = ancestors.pop();\n            }\n\n            return parent && isCommentInsideNodeType(node, parent, nodeType) &&\n                    node.loc.start.line - parent.loc.start.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the parent end or not.\n         * @param {ASTNode} node The Comment node.\n         * @param {string} nodeType The parent type to check against.\n         * @returns {boolean} True if the comment is at parent end.\n         */\n        function isCommentAtParentEnd(node, nodeType) {\n            var ancestors = context.getAncestors();\n            var parent;\n\n            if (ancestors.length) {\n                parent = ancestors.pop();\n            }\n\n            return parent && isCommentInsideNodeType(node, parent, nodeType) &&\n                    parent.loc.end.line - node.loc.end.line === 1;\n        }\n\n        /**\n         * Returns whether or not comments are at the block start or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at block start.\n         */\n        function isCommentAtBlockStart(node) {\n            return isCommentAtParentStart(node, \"ClassBody\") || isCommentAtParentStart(node, \"BlockStatement\") || isCommentAtParentStart(node, \"SwitchCase\");\n        }\n\n        /**\n         * Returns whether or not comments are at the block end or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at block end.\n         */\n        function isCommentAtBlockEnd(node) {\n            return isCommentAtParentEnd(node, \"ClassBody\") || isCommentAtParentEnd(node, \"BlockStatement\") || isCommentAtParentEnd(node, \"SwitchCase\") || isCommentAtParentEnd(node, \"SwitchStatement\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object start or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at object start.\n         */\n        function isCommentAtObjectStart(node) {\n            return isCommentAtParentStart(node, \"ObjectExpression\") || isCommentAtParentStart(node, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the object end or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at object end.\n         */\n        function isCommentAtObjectEnd(node) {\n            return isCommentAtParentEnd(node, \"ObjectExpression\") || isCommentAtParentEnd(node, \"ObjectPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array start or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at array start.\n         */\n        function isCommentAtArrayStart(node) {\n            return isCommentAtParentStart(node, \"ArrayExpression\") || isCommentAtParentStart(node, \"ArrayPattern\");\n        }\n\n        /**\n         * Returns whether or not comments are at the array end or not.\n         * @param {ASTNode} node The Comment node.\n         * @returns {boolean} True if the comment is at array end.\n         */\n        function isCommentAtArrayEnd(node) {\n            return isCommentAtParentEnd(node, \"ArrayExpression\") || isCommentAtParentEnd(node, \"ArrayPattern\");\n        }\n\n        /**\n         * Checks if a comment node has lines around it (ignores inline comments)\n         * @param {ASTNode} node The Comment node.\n         * @param {Object} opts Options to determine the newline.\n         * @param {Boolean} opts.after Should have a newline after this line.\n         * @param {Boolean} opts.before Should have a newline before this line.\n         * @returns {void}\n         */\n        function checkForEmptyLine(node, opts) {\n            var after = opts.after,\n                before = opts.before;\n\n            var prevLineNum = node.loc.start.line - 1,\n                nextLineNum = node.loc.end.line + 1,\n                commentIsNotAlone = codeAroundComment(node);\n\n            var blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(node),\n                blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(node),\n                objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(node),\n                objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(node),\n                arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(node),\n                arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(node);\n\n            var exceptionStartAllowed = blockStartAllowed || objectStartAllowed || arrayStartAllowed;\n            var exceptionEndAllowed = blockEndAllowed || objectEndAllowed || arrayEndAllowed;\n\n            // ignore top of the file and bottom of the file\n            if (prevLineNum < 1) {\n                before = false;\n            }\n            if (nextLineNum >= numLines) {\n                after = false;\n            }\n\n            // we ignore all inline comments\n            if (commentIsNotAlone) {\n                return;\n            }\n\n            var previousTokenOrComment = sourceCode.getTokenOrCommentBefore(node);\n            var nextTokenOrComment = sourceCode.getTokenOrCommentAfter(node);\n\n            // check for newline before\n            if (!exceptionStartAllowed && before && !lodash.includes(commentAndEmptyLines, prevLineNum) &&\n                    !(isCommentNodeType(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, node))) {\n                var lineStart = node.range[0] - node.loc.start.column;\n                var range = [lineStart, lineStart];\n\n                context.report({\n                    node: node,\n                    message: \"Expected line before comment.\",\n                    fix: function(fixer) {\n                        return fixer.insertTextBeforeRange(range, \"\\n\");\n                    }\n                });\n            }\n\n            // check for newline after\n            if (!exceptionEndAllowed && after && !lodash.includes(commentAndEmptyLines, nextLineNum) &&\n                    !(isCommentNodeType(nextTokenOrComment) && astUtils.isTokenOnSameLine(node, nextTokenOrComment))) {\n                context.report({\n                    node: node,\n                    message: \"Expected line after comment.\",\n                    fix: function(fixer) {\n                        return fixer.insertTextAfter(node, \"\\n\");\n                    }\n                });\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            LineComment: function(node) {\n                if (options.beforeLineComment || options.afterLineComment) {\n                    checkForEmptyLine(node, {\n                        after: options.afterLineComment,\n                        before: options.beforeLineComment\n                    });\n                }\n            },\n\n            BlockComment: function(node) {\n                if (options.beforeBlockComment || options.afterBlockComment) {\n                    checkForEmptyLine(node, {\n                        after: options.afterBlockComment,\n                        before: options.beforeBlockComment\n                    });\n                }\n            }\n\n        };\n    }\n};\n"]}