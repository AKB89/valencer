{"version":3,"sources":["quotes.js"],"names":[],"mappings":"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","file":"quotes-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to choose between single and double quote marks\n * @author Matt DuVall <http://www.mattduvall.com/>, Brandon Payton\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nvar QUOTE_SETTINGS = {\n    double: {\n        quote: \"\\\"\",\n        alternateQuote: \"'\",\n        description: \"doublequote\"\n    },\n    single: {\n        quote: \"'\",\n        alternateQuote: \"\\\"\",\n        description: \"singlequote\"\n    },\n    backtick: {\n        quote: \"`\",\n        alternateQuote: \"\\\"\",\n        description: \"backtick\"\n    }\n};\n\n/**\n * Switches quoting of javascript string between ' \" and `\n * escaping and unescaping as necessary.\n * Only escaping of the minimal set of characters is changed.\n * Note: escaping of newlines when switching from backtick to other quotes is not handled.\n * @param {string} str - A string to convert.\n * @returns {string} The string with changed quotes.\n * @private\n */\nQUOTE_SETTINGS.double.convert =\nQUOTE_SETTINGS.single.convert =\nQUOTE_SETTINGS.backtick.convert = function(str) {\n    var newQuote = this.quote;\n    var oldQuote = str[0];\n\n    if (newQuote === oldQuote) {\n        return str;\n    }\n    return newQuote + str.slice(1, -1).replace(/\\\\(\\${|\\r\\n?|\\n|.)|[\"'`]|\\${|(\\r\\n?|\\n)/g, function(match, escaped, newline) {\n        if (escaped === oldQuote || oldQuote === \"`\" && escaped === \"${\") {\n            return escaped; // unescape\n        }\n        if (match === newQuote || newQuote === \"`\" && match === \"${\") {\n            return \"\\\\\" + match; // escape\n        }\n        if (newline && oldQuote === \"`\") {\n            return \"\\\\n\"; // escape newlines\n        }\n        return match;\n    }) + newQuote;\n};\n\nvar AVOID_ESCAPE = \"avoid-escape\",\n    FUNCTION_TYPE = /^(?:Arrow)?Function(?:Declaration|Expression)$/;\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce the consistent use of either backticks, double, or single quotes\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"single\", \"double\", \"backtick\"]\n            },\n            {\n                anyOf: [\n                    {\n                        enum: [\"avoid-escape\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            avoidEscape: {\n                                type: \"boolean\"\n                            },\n                            allowTemplateLiterals: {\n                                type: \"boolean\"\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var quoteOption = context.options[0],\n            settings = QUOTE_SETTINGS[quoteOption || \"double\"],\n            options = context.options[1],\n            avoidEscape = options && options.avoidEscape === true,\n            allowTemplateLiterals = options && options.allowTemplateLiterals === true,\n            sourceCode = context.getSourceCode();\n\n        // deprecated\n        if (options === AVOID_ESCAPE) {\n            avoidEscape = true;\n        }\n\n        /**\n         * Determines if a given node is part of JSX syntax.\n         * @param {ASTNode} node The node to check.\n         * @returns {boolean} True if the node is a JSX node, false if not.\n         * @private\n         */\n        function isJSXElement(node) {\n            return node.type.indexOf(\"JSX\") === 0;\n        }\n\n        /**\n         * Checks whether or not a given node is a directive.\n         * The directive is a `ExpressionStatement` which has only a string literal.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a directive.\n         * @private\n         */\n        function isDirective(node) {\n            return (\n                node.type === \"ExpressionStatement\" &&\n                node.expression.type === \"Literal\" &&\n                typeof node.expression.value === \"string\"\n            );\n        }\n\n        /**\n         * Checks whether or not a given node is a part of directive prologues.\n         * See also: http://www.ecma-international.org/ecma-262/6.0/#sec-directive-prologues-and-the-use-strict-directive\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is a part of directive prologues.\n         * @private\n         */\n        function isPartOfDirectivePrologue(node) {\n            var block = node.parent.parent;\n\n            if (block.type !== \"Program\" && (block.type !== \"BlockStatement\" || !FUNCTION_TYPE.test(block.parent.type))) {\n                return false;\n            }\n\n            // Check the node is at a prologue.\n            for (var i = 0; i < block.body.length; ++i) {\n                var statement = block.body[i];\n\n                if (statement === node.parent) {\n                    return true;\n                }\n                if (!isDirective(statement)) {\n                    break;\n                }\n            }\n\n            return false;\n        }\n\n        /**\n         * Checks whether or not a given node is allowed as non backtick.\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} Whether or not the node is allowed as non backtick.\n         * @private\n         */\n        function isAllowedAsNonBacktick(node) {\n            var parent = node.parent;\n\n            switch (parent.type) {\n\n                // Directive Prologues.\n                case \"ExpressionStatement\":\n                    return isPartOfDirectivePrologue(node);\n\n                // LiteralPropertyName.\n                case \"Property\":\n                    return parent.key === node && !parent.computed;\n\n                // ModuleSpecifier.\n                case \"ImportDeclaration\":\n                case \"ExportNamedDeclaration\":\n                case \"ExportAllDeclaration\":\n                    return parent.source === node;\n\n                // Others don't allow.\n                default:\n                    return false;\n            }\n        }\n\n        return {\n\n            Literal: function(node) {\n                var val = node.value,\n                    rawVal = node.raw,\n                    isValid;\n\n                if (settings && typeof val === \"string\") {\n                    isValid = (quoteOption === \"backtick\" && isAllowedAsNonBacktick(node)) ||\n                        isJSXElement(node.parent) ||\n                        astUtils.isSurroundedBy(rawVal, settings.quote);\n\n                    if (!isValid && avoidEscape) {\n                        isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;\n                    }\n\n                    if (!isValid) {\n                        context.report({\n                            node: node,\n                            message: \"Strings must use \" + settings.description + \".\",\n                            fix: function(fixer) {\n                                return fixer.replaceText(node, settings.convert(node.raw));\n                            }\n                        });\n                    }\n                }\n            },\n\n            TemplateLiteral: function(node) {\n\n                // If backticks are expected or it's a tagged template, then this shouldn't throw an errors\n                if (allowTemplateLiterals || quoteOption === \"backtick\" || node.parent.type === \"TaggedTemplateExpression\") {\n                    return;\n                }\n\n                var shouldWarn = node.quasis.length === 1 && (node.quasis[0].value.cooked.indexOf(\"\\n\") === -1);\n\n                if (shouldWarn) {\n                    context.report({\n                        node: node,\n                        message: \"Strings must use \" + settings.description + \".\",\n                        fix: function(fixer) {\n                            return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));\n                        }\n                    });\n                }\n            }\n        };\n\n    }\n};\n"]}