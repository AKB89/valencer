{"version":3,"sources":["padded-blocks.js"],"names":[],"mappings":"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","file":"padded-blocks-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to ensure blank lines within blocks.\n * @author Mathias Schreck <https://github.com/lo1tuma>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow padding within blocks\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"always\", \"never\"]\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            blocks: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            switches: {\n                                enum: [\"always\", \"never\"]\n                            },\n                            classes: {\n                                enum: [\"always\", \"never\"]\n                            }\n                        },\n                        additionalProperties: false,\n                        minProperties: 1\n                    }\n                ]\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = {};\n        var config = context.options[0] || \"always\";\n\n        if (typeof config === \"string\") {\n            options.blocks = config === \"always\";\n        } else {\n            if (config.hasOwnProperty(\"blocks\")) {\n                options.blocks = config.blocks === \"always\";\n            }\n            if (config.hasOwnProperty(\"switches\")) {\n                options.switches = config.switches === \"always\";\n            }\n            if (config.hasOwnProperty(\"classes\")) {\n                options.classes = config.classes === \"always\";\n            }\n        }\n\n        var ALWAYS_MESSAGE = \"Block must be padded by blank lines.\",\n            NEVER_MESSAGE = \"Block must not be padded by blank lines.\";\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Gets the open brace token from a given node.\n         * @param {ASTNode} node - A BlockStatement or SwitchStatement node from which to get the open brace.\n         * @returns {Token} The token of the open brace.\n         */\n        function getOpenBrace(node) {\n            if (node.type === \"SwitchStatement\") {\n                return sourceCode.getTokenBefore(node.cases[0]);\n            }\n            return sourceCode.getFirstToken(node);\n        }\n\n        /**\n         * Checks if the given parameter is a comment node\n         * @param {ASTNode|Token} node An AST node or token\n         * @returns {boolean} True if node is a comment\n         */\n        function isComment(node) {\n            return node.type === \"Line\" || node.type === \"Block\";\n        }\n\n        /**\n         * Checks if the given token has a blank line after it.\n         * @param {Token} token The token to check.\n         * @returns {boolean} Whether or not the token is followed by a blank line.\n         */\n        function isTokenTopPadded(token) {\n            var tokenStartLine = token.loc.start.line,\n                expectedFirstLine = tokenStartLine + 2,\n                first,\n                firstLine;\n\n            first = token;\n            do {\n                first = sourceCode.getTokenOrCommentAfter(first);\n            } while (isComment(first) && first.loc.start.line === tokenStartLine);\n\n            firstLine = first.loc.start.line;\n            return expectedFirstLine <= firstLine;\n        }\n\n        /**\n         * Checks if the given token is preceeded by a blank line.\n         * @param {Token} token The token to check\n         * @returns {boolean} Whether or not the token is preceeded by a blank line\n         */\n        function isTokenBottomPadded(token) {\n            var blockEnd = token.loc.end.line,\n                expectedLastLine = blockEnd - 2,\n                last,\n                lastLine;\n\n            last = token;\n            do {\n                last = sourceCode.getTokenOrCommentBefore(last);\n            } while (isComment(last) && last.loc.end.line === blockEnd);\n\n            lastLine = last.loc.end.line;\n            return lastLine <= expectedLastLine;\n        }\n\n        /**\n         * Checks if a node should be padded, according to the rule config.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {boolean} True if the node should be padded, false otherwise.\n         */\n        function requirePaddingFor(node) {\n            switch (node.type) {\n                case \"BlockStatement\":\n                    return options.blocks;\n                case \"SwitchStatement\":\n                    return options.switches;\n                case \"ClassBody\":\n                    return options.classes;\n\n                /* istanbul ignore next */\n                default:\n                    throw new Error(\"unreachable\");\n            }\n        }\n\n        /**\n         * Checks the given BlockStatement node to be padded if the block is not empty.\n         * @param {ASTNode} node The AST node of a BlockStatement.\n         * @returns {void} undefined.\n         */\n        function checkPadding(node) {\n            var openBrace = getOpenBrace(node),\n                closeBrace = sourceCode.getLastToken(node),\n                blockHasTopPadding = isTokenTopPadded(openBrace),\n                blockHasBottomPadding = isTokenBottomPadded(closeBrace);\n\n            if (requirePaddingFor(node)) {\n                if (!blockHasTopPadding) {\n                    context.report({\n                        node: node,\n                        loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n                if (!blockHasBottomPadding) {\n                    context.report({\n                        node: node,\n                        loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },\n                        message: ALWAYS_MESSAGE\n                    });\n                }\n            } else {\n                if (blockHasTopPadding) {\n                    context.report({\n                        node: node,\n                        loc: { line: openBrace.loc.start.line, column: openBrace.loc.start.column },\n                        message: NEVER_MESSAGE\n                    });\n                }\n\n                if (blockHasBottomPadding) {\n                    context.report({\n                        node: node,\n                        loc: {line: closeBrace.loc.end.line, column: closeBrace.loc.end.column - 1 },\n                        message: NEVER_MESSAGE\n                    });\n                }\n            }\n        }\n\n        var rule = {};\n\n        if (options.hasOwnProperty(\"switches\")) {\n            rule.SwitchStatement = function(node) {\n                if (node.cases.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (options.hasOwnProperty(\"blocks\")) {\n            rule.BlockStatement = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        if (options.hasOwnProperty(\"classes\")) {\n            rule.ClassBody = function(node) {\n                if (node.body.length === 0) {\n                    return;\n                }\n                checkPadding(node);\n            };\n        }\n\n        return rule;\n    }\n};\n"]}