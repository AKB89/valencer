{"version":3,"sources":["no-useless-concat.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;;;;;;AAWA,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3B,WAAO,KAAK,IAAL,KAAc,kBAAd,IAAoC,KAAK,QAAL,KAAkB,GAA7D;AACH;;;;;;;AAOD,SAAS,OAAT,CAAiB,IAAjB,EAAuB;AACnB,QAAI,OAAO,KAAK,IAAhB;;AAEA,WAAO,gBAAgB,IAAhB,CAAP,EAA8B;AAC1B,eAAO,KAAK,KAAZ;AACH;AACD,WAAO,IAAP;AACH;;;;;;;AAOD,SAAS,QAAT,CAAkB,IAAlB,EAAwB;AACpB,QAAI,QAAQ,KAAK,KAAjB;;AAEA,WAAO,gBAAgB,KAAhB,CAAP,EAA+B;AAC3B,gBAAQ,MAAM,IAAd;AACH;AACD,WAAO,KAAP;AACH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,qEADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;AAEA,eAAO;AACH,8BAAkB,UAAS,IAAT,EAAe;;;AAG7B,oBAAI,KAAK,QAAL,KAAkB,GAAtB,EAA2B;AACvB;AACH;;;AAGD,oBAAI,OAAO,QAAQ,IAAR,CAAX;AACA,oBAAI,QAAQ,SAAS,IAAT,CAAZ;;AAEA,oBAAI,SAAS,eAAT,CAAyB,IAAzB,KACA,SAAS,eAAT,CAAyB,KAAzB,CADA,IAEA,SAAS,iBAAT,CAA2B,IAA3B,EAAiC,KAAjC,CAFJ,EAGE;;;AAGE,wBAAI,gBAAgB,WAAW,aAAX,CAAyB,IAAzB,CAApB;;AAEA,2BAAO,cAAc,KAAd,KAAwB,GAA/B,EAAoC;AAChC,wCAAgB,WAAW,aAAX,CAAyB,aAAzB,CAAhB;AACH;;AAED,4BAAQ,MAAR,CACI,IADJ,EAEI,cAAc,GAAd,CAAkB,KAFtB,EAGI,8CAHJ;AAIH;AACJ;AA7BE,SAAP;AA+BH;AA7CY,CAAjB","file":"no-useless-concat-compiled.js","sourcesContent":["/**\n * @fileoverview disallow unncessary concatenation of template strings\n * @author Henry Zhu\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is a concatenation.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a concatenation.\n */\nfunction isConcatenation(node) {\n    return node.type === \"BinaryExpression\" && node.operator === \"+\";\n}\n\n/**\n * Get's the right most node on the left side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getLeft(node) {\n    var left = node.left;\n\n    while (isConcatenation(left)) {\n        left = left.right;\n    }\n    return left;\n}\n\n/**\n * Get's the left most node on the right side of a BinaryExpression with + operator.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {ASTNode} node\n */\nfunction getRight(node) {\n    var right = node.right;\n\n    while (isConcatenation(right)) {\n        right = right.left;\n    }\n    return right;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unnecessary concatenation of literals or template literals\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        return {\n            BinaryExpression: function(node) {\n\n                // check if not concatenation\n                if (node.operator !== \"+\") {\n                    return;\n                }\n\n                // account for the `foo + \"a\" + \"b\"` case\n                var left = getLeft(node);\n                var right = getRight(node);\n\n                if (astUtils.isStringLiteral(left) &&\n                    astUtils.isStringLiteral(right) &&\n                    astUtils.isTokenOnSameLine(left, right)\n                ) {\n\n                    // move warning location to operator\n                    var operatorToken = sourceCode.getTokenAfter(left);\n\n                    while (operatorToken.value !== \"+\") {\n                        operatorToken = sourceCode.getTokenAfter(operatorToken);\n                    }\n\n                    context.report(\n                        node,\n                        operatorToken.loc.start,\n                        \"Unexpected string concatenation of literals.\");\n                }\n            }\n        };\n    }\n};\n"]}