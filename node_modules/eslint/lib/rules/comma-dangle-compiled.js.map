{"version":3,"sources":["comma-dangle.js"],"names":[],"mappings":"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","file":"comma-dangle-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to forbid or enforce dangling commas.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar lodash = require(\"lodash\");\n\n/**\n * Checks whether or not a trailing comma is allowed in a given node.\n * `ArrayPattern` which has `RestElement` disallows it.\n *\n * @param {ASTNode} node - A node to check.\n * @param {ASTNode} lastItem - The node of the last element in the given node.\n * @returns {boolean} `true` if a trailing comma is allowed.\n */\nfunction isTrailingCommaAllowed(node, lastItem) {\n    return node.type !== \"ArrayPattern\" || lastItem.type !== \"RestElement\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow trailing commas\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        fixable: \"code\",\n\n        schema: [\n            {\n                enum: [\"always\", \"always-multiline\", \"only-multiline\", \"never\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n        var mode = context.options[0];\n        var UNEXPECTED_MESSAGE = \"Unexpected trailing comma.\";\n        var MISSING_MESSAGE = \"Missing trailing comma.\";\n\n        /**\n         * Checks whether or not a given node is multiline.\n         * This rule handles a given node as multiline when the closing parenthesis\n         * and the last element are not on the same line.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {boolean} `true` if the node is multiline.\n         */\n        function isMultiline(node) {\n            var lastItem = lodash.last(node.properties || node.elements || node.specifiers);\n\n            if (!lastItem) {\n                return false;\n            }\n\n            var sourceCode = context.getSourceCode(),\n                penultimateToken = sourceCode.getLastToken(lastItem),\n                lastToken = sourceCode.getTokenAfter(penultimateToken);\n\n            // parentheses are a pain\n            while (lastToken.value === \")\") {\n                penultimateToken = lastToken;\n                lastToken = sourceCode.getTokenAfter(lastToken);\n            }\n\n            if (lastToken.value === \",\") {\n                penultimateToken = lastToken;\n                lastToken = sourceCode.getTokenAfter(lastToken);\n            }\n\n            return lastToken.loc.end.line !== penultimateToken.loc.end.line;\n        }\n\n        /**\n         * Reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forbidTrailingComma(node) {\n            var lastItem = lodash.last(node.properties || node.elements || node.specifiers);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n\n            var sourceCode = context.getSourceCode(),\n                trailingToken;\n\n            // last item can be surrounded by parentheses for object and array literals\n            if (node.type === \"ObjectExpression\" || node.type === \"ArrayExpression\") {\n                trailingToken = sourceCode.getTokenBefore(sourceCode.getLastToken(node));\n            } else {\n                trailingToken = sourceCode.getTokenAfter(lastItem);\n            }\n\n            if (trailingToken.value === \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: trailingToken.loc.start,\n                    message: UNEXPECTED_MESSAGE,\n                    fix: function(fixer) {\n                        return fixer.remove(trailingToken);\n                    }\n                });\n            }\n        }\n\n        /**\n         * Reports the last element of a given node if it does not have a trailing\n         * comma.\n         *\n         * If a given node is `ArrayPattern` which has `RestElement`, the trailing\n         * comma is disallowed, so report if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingComma(node) {\n            var lastItem = lodash.last(node.properties || node.elements || node.specifiers);\n\n            if (!lastItem || (node.type === \"ImportDeclaration\" && lastItem.type !== \"ImportSpecifier\")) {\n                return;\n            }\n            if (!isTrailingCommaAllowed(node, lastItem)) {\n                forbidTrailingComma(node);\n                return;\n            }\n\n            var sourceCode = context.getSourceCode(),\n                penultimateToken = lastItem,\n                trailingToken = sourceCode.getTokenAfter(lastItem);\n\n            // Skip close parentheses.\n            while (trailingToken.value === \")\") {\n                penultimateToken = trailingToken;\n                trailingToken = sourceCode.getTokenAfter(trailingToken);\n            }\n\n            if (trailingToken.value !== \",\") {\n                context.report({\n                    node: lastItem,\n                    loc: lastItem.loc.end,\n                    message: MISSING_MESSAGE,\n                    fix: function(fixer) {\n                        return fixer.insertTextAfter(penultimateToken, \",\");\n                    }\n                });\n            }\n        }\n\n        /**\n         * If a given node is multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function forceTrailingCommaIfMultiline(node) {\n            if (isMultiline(node)) {\n                forceTrailingComma(node);\n            } else {\n                forbidTrailingComma(node);\n            }\n        }\n\n        /**\n         * Only if a given node is not multiline, reports the last element of a given node\n         * when it does not have a trailing comma.\n         * Otherwise, reports a trailing comma if it exists.\n         *\n         * @param {ASTNode} node - A node to check. Its type is one of\n         *   ObjectExpression, ObjectPattern, ArrayExpression, ArrayPattern,\n         *   ImportDeclaration, and ExportNamedDeclaration.\n         * @returns {void}\n         */\n        function allowTrailingCommaIfMultiline(node) {\n            if (!isMultiline(node)) {\n                forbidTrailingComma(node);\n            }\n        }\n\n        // Chooses a checking function.\n        var checkForTrailingComma;\n\n        if (mode === \"always\") {\n            checkForTrailingComma = forceTrailingComma;\n        } else if (mode === \"always-multiline\") {\n            checkForTrailingComma = forceTrailingCommaIfMultiline;\n        } else if (mode === \"only-multiline\") {\n            checkForTrailingComma = allowTrailingCommaIfMultiline;\n        } else {\n            checkForTrailingComma = forbidTrailingComma;\n        }\n\n        return {\n            ObjectExpression: checkForTrailingComma,\n            ObjectPattern: checkForTrailingComma,\n            ArrayExpression: checkForTrailingComma,\n            ArrayPattern: checkForTrailingComma,\n            ImportDeclaration: checkForTrailingComma,\n            ExportNamedDeclaration: checkForTrailingComma\n        };\n    }\n};\n"]}