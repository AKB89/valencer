{"version":3,"sources":["no-implied-eval.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,2CADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,YAAY,oCAAhB;;;;;;AAMA,YAAI,4BAA4B,EAAhC;;;;;;;;;;;;AAYA,iBAAS,IAAT,CAAc,GAAd,EAAmB;AACf,mBAAO,MAAM,IAAI,IAAI,MAAJ,GAAa,CAAjB,CAAN,GAA4B,IAAnC;AACH;;;;;;;;AAQD,iBAAS,6BAAT,CAAuC,IAAvC,EAA6C;AACzC,gBAAI,SAAS,KAAK,MAAlB;gBACI,WAAW,KAAK,QADpB;gBAEI,qBAAqB,UAAU,IAAV,CAAe,SAAS,IAAxB,KAAiC,UAAU,IAAV,CAAe,SAAS,KAAxB,CAF1D;;AAIA,mBAAO,OAAO,IAAP,KAAgB,QAAhB,IAA4B,kBAAnC;AACH;;;;;;;;;;;AAWD,iBAAS,2BAAT,CAAqC,IAArC,EAA2C;AACvC,gBAAI,qBAAsB,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAA/C;gBACI,eAAgB,KAAK,MAAL,CAAY,IAAZ,KAAqB,YADzC;gBAEI,sBACK,gBAAgB,UAAU,IAAV,CAAe,KAAK,MAAL,CAAY,IAA3B,CAAjB,IACC,sBAAsB,8BAA8B,KAAK,MAAnC,CAJ/B;;AAMA,mBAAO,uBAAuB,KAAK,SAAL,CAAe,MAA7C;AACH;;;;;;;;AAQD,iBAAS,oBAAT,CAA8B,IAA9B,EAAoC;;;AAGhC,mBAAO,KAAK,MAAL,KAAgB,KAAK,KAAK,yBAAL,CAAL,CAAhB;;;AAGF,iBAAK,MAAL,CAAY,IAAZ,KAAqB,gBAArB,IAAyC,SAAS,KAAK,MAAL,CAAY,SAAZ,CAAsB,CAAtB,CAHhD,CAAP;AAIH;;;;;;;;;;AAUD,iBAAS,WAAT,CAAqB,IAArB,EAA2B;AACvB,gBAAI,qBAAqB,IAArB,CAAJ,EAAgC;;;AAG5B,oBAAI,WAAW,0BAA0B,GAA1B,EAAf;;AAEA,wBAAQ,MAAR,CAAe,SAAS,CAAT,CAAf,EAA4B,gEAA5B;AACH;AACJ;;;;;;AAMD,eAAO;AACH,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,4BAA4B,IAA5B,CAAJ,EAAuC;;;AAGnC,8CAA0B,IAA1B,CAA+B,CAAC,IAAD,CAA/B;AACH;AACJ,aAPE;;AASH,mCAAuB,UAAS,IAAT,EAAe;AAClC,oBAAI,SAAS,KAAK,KAAK,yBAAL,CAAL,CAAb,EAAoD;;;;;;AAMhD,8CAA0B,GAA1B;AACH;AACJ,aAlBE;;AAoBH,8BAAkB,UAAS,IAAT,EAAe;AAC7B,oBAAI,KAAK,QAAL,KAAkB,GAAlB,IAAyB,qBAAqB,IAArB,CAA7B,EAAyD;AACrD,yBAAK,yBAAL,EAAgC,IAAhC,CAAqC,IAArC;AACH;AACJ,aAxBE;;AA0BH,qCAAyB,UAAS,IAAT,EAAe;AACpC,oBAAI,SAAS,KAAK,KAAK,yBAAL,CAAL,CAAb,EAAoD;AAChD,yBAAK,yBAAL,EAAgC,GAAhC;AACH;AACJ,aA9BE;;AAgCH,qBAAS,UAAS,IAAT,EAAe;AACpB,oBAAI,OAAO,KAAK,KAAZ,KAAsB,QAA1B,EAAoC;AAChC,gCAAY,IAAZ;AACH;AACJ,aApCE;;AAsCH,6BAAiB,UAAS,IAAT,EAAe;AAC5B,4BAAY,IAAZ;AACH;AAxCE,SAAP;AA2CH;AAnJY,CAAjB","file":"no-implied-eval-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of implied eval via setTimeout and setInterval\n * @author James Allardice\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `eval()`-like methods\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var CALLEE_RE = /set(?:Timeout|Interval)|execScript/;\n\n        /*\n         * Figures out if we should inspect a given binary expression. Is a stack\n         * of stacks, where the first element in each substack is a CallExpression.\n         */\n        var impliedEvalAncestorsStack = [];\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Get the last element of an array, without modifying arr, like pop(), but non-destructive.\n         * @param {array} arr What to inspect\n         * @returns {*} The last element of arr\n         * @private\n         */\n        function last(arr) {\n            return arr ? arr[arr.length - 1] : null;\n        }\n\n        /**\n         * Checks if the given MemberExpression node is a potentially implied eval identifier on window.\n         * @param {ASTNode} node The MemberExpression node to check.\n         * @returns {boolean} Whether or not the given node is potentially an implied eval.\n         * @private\n         */\n        function isImpliedEvalMemberExpression(node) {\n            var object = node.object,\n                property = node.property,\n                hasImpliedEvalName = CALLEE_RE.test(property.name) || CALLEE_RE.test(property.value);\n\n            return object.name === \"window\" && hasImpliedEvalName;\n        }\n\n        /**\n         * Determines if a node represents a call to a potentially implied eval.\n         *\n         * This checks the callee name and that there's an argument, but not the type of the argument.\n         *\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function isImpliedEvalCallExpression(node) {\n            var isMemberExpression = (node.callee.type === \"MemberExpression\"),\n                isIdentifier = (node.callee.type === \"Identifier\"),\n                isImpliedEvalCallee =\n                    (isIdentifier && CALLEE_RE.test(node.callee.name)) ||\n                    (isMemberExpression && isImpliedEvalMemberExpression(node.callee));\n\n            return isImpliedEvalCallee && node.arguments.length;\n        }\n\n        /**\n         * Checks that the parent is a direct descendent of an potential implied eval CallExpression, and if the parent is a CallExpression, that we're the first argument.\n         * @param {ASTNode} node The node to inspect the parent of.\n         * @returns {boolean} Was the parent a direct descendent, and is the child therefore potentially part of a dangerous argument?\n         * @private\n         */\n        function hasImpliedEvalParent(node) {\n\n            // make sure our parent is marked\n            return node.parent === last(last(impliedEvalAncestorsStack)) &&\n\n                // if our parent is a CallExpression, make sure we're the first argument\n                (node.parent.type !== \"CallExpression\" || node === node.parent.arguments[0]);\n        }\n\n        /**\n         * Checks if our parent is marked as part of an implied eval argument. If\n         * so, collapses the top of impliedEvalAncestorsStack and reports on the\n         * original CallExpression.\n         * @param {ASTNode} node The CallExpression to check.\n         * @returns {boolean} True if the node matches, false if not.\n         * @private\n         */\n        function checkString(node) {\n            if (hasImpliedEvalParent(node)) {\n\n                // remove the entire substack, to avoid duplicate reports\n                var substack = impliedEvalAncestorsStack.pop();\n\n                context.report(substack[0], \"Implied eval. Consider passing a function instead of a string.\");\n            }\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            CallExpression: function(node) {\n                if (isImpliedEvalCallExpression(node)) {\n\n                    // call expressions create a new substack\n                    impliedEvalAncestorsStack.push([node]);\n                }\n            },\n\n            \"CallExpression:exit\": function(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n\n                    /* Destroys the entire sub-stack, rather than just using\n                     * last(impliedEvalAncestorsStack).pop(), as a CallExpression is\n                     * always the bottom of a impliedEvalAncestorsStack substack.\n                     */\n                    impliedEvalAncestorsStack.pop();\n                }\n            },\n\n            BinaryExpression: function(node) {\n                if (node.operator === \"+\" && hasImpliedEvalParent(node)) {\n                    last(impliedEvalAncestorsStack).push(node);\n                }\n            },\n\n            \"BinaryExpression:exit\": function(node) {\n                if (node === last(last(impliedEvalAncestorsStack))) {\n                    last(impliedEvalAncestorsStack).pop();\n                }\n            },\n\n            Literal: function(node) {\n                if (typeof node.value === \"string\") {\n                    checkString(node);\n                }\n            },\n\n            TemplateLiteral: function(node) {\n                checkString(node);\n            }\n        };\n\n    }\n};\n"]}