{"version":3,"sources":["no-return-assign.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,IAAI,gBAAgB,sFAApB;;;;;;;;AAQA,SAAS,kBAAT,CAA4B,IAA5B,EAAkC,UAAlC,EAA8C;AAC1C,QAAI,YAAY,WAAW,cAAX,CAA0B,IAA1B,CAAhB;AACA,QAAI,YAAY,WAAW,aAAX,CAAyB,IAAzB,CAAhB;;AAEA,WAAO,aAAa,UAAU,KAAV,KAAoB,GAAjC,IAAwC,SAAxC,IAAqD,UAAU,KAAV,KAAoB,GAAhF;AACH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,sDADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,CAAC,eAAD,EAAkB,QAAlB;AADV,SADI;AAPN,KADO;;AAeb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,SAAS,CAAC,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,eAAvB,MAA4C,eAAzD;AACA,YAAI,aAAa,QAAQ,aAAR,EAAjB;;AAEA,eAAO;AACH,kCAAsB,UAAS,IAAT,EAAe;AACjC,oBAAI,CAAC,MAAD,IAAW,mBAAmB,IAAnB,EAAyB,UAAzB,CAAf,EAAqD;AACjD;AACH;;AAED,oBAAI,SAAS,KAAK,MAAlB;;;AAGA,uBAAO,UAAU,CAAC,cAAc,IAAd,CAAmB,OAAO,IAA1B,CAAlB,EAAmD;AAC/C,2BAAO,MAAP;AACA,6BAAS,OAAO,MAAhB;AACH;;;AAGD,oBAAI,UAAU,OAAO,IAAP,KAAgB,iBAA9B,EAAiD;AAC7C,4BAAQ,MAAR,CAAe;AACX,8BAAM,MADK;AAEX,iCAAS;AAFE,qBAAf;AAIH,iBALD,MAKO,IAAI,UAAU,OAAO,IAAP,KAAgB,yBAA1B,IAAuD,OAAO,IAAP,KAAgB,IAA3E,EAAiF;AACpF,4BAAQ,MAAR,CAAe;AACX,8BAAM,MADK;AAEX,iCAAS;AAFE,qBAAf;AAIH;AACJ;AA1BE,SAAP;AA4BH;AA/CY,CAAjB","file":"no-return-assign-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag when return statement contains assignment\n * @author Ilya Volodin\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/;\n\n/**\n * Checks whether or not a node is enclosed in parentheses.\n * @param {Node|null} node - A node to check.\n * @param {sourceCode} sourceCode - The ESLint SourceCode object.\n * @returns {boolean} Whether or not the node is enclosed in parentheses.\n */\nfunction isEnclosedInParens(node, sourceCode) {\n    var prevToken = sourceCode.getTokenBefore(node);\n    var nextToken = sourceCode.getTokenAfter(node);\n\n    return prevToken && prevToken.value === \"(\" && nextToken && nextToken.value === \")\";\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow assignment operators in `return` statements\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"except-parens\", \"always\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n        var always = (context.options[0] || \"except-parens\") !== \"except-parens\";\n        var sourceCode = context.getSourceCode();\n\n        return {\n            AssignmentExpression: function(node) {\n                if (!always && isEnclosedInParens(node, sourceCode)) {\n                    return;\n                }\n\n                var parent = node.parent;\n\n                // Find ReturnStatement or ArrowFunctionExpression in ancestors.\n                while (parent && !SENTINEL_TYPE.test(parent.type)) {\n                    node = parent;\n                    parent = parent.parent;\n                }\n\n                // Reports.\n                if (parent && parent.type === \"ReturnStatement\") {\n                    context.report({\n                        node: parent,\n                        message: \"Return statement should not contain assignment.\"\n                    });\n                } else if (parent && parent.type === \"ArrowFunctionExpression\" && parent.body === node) {\n                    context.report({\n                        node: parent,\n                        message: \"Arrow function should not return assignment.\"\n                    });\n                }\n            }\n        };\n    }\n};\n"]}