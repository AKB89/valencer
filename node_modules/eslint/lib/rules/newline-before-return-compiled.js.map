{"version":3,"sources":["newline-before-return.js"],"names":[],"mappings":"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","file":"newline-before-return-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to require newlines before `return` statement\n * @author Kai Cataldo\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require an empty line before `return` statements\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tests whether node is preceded by supplied tokens\n         * @param {ASTNode} node - node to check\n         * @param {array} testTokens - array of tokens to test against\n         * @returns {boolean} Whether or not the node is preceded by one of the supplied tokens\n         * @private\n         */\n        function isPrecededByTokens(node, testTokens) {\n            var tokenBefore = sourceCode.getTokenBefore(node);\n\n            return testTokens.some(function(token) {\n                return tokenBefore.value === token;\n            });\n        }\n\n        /**\n         * Checks whether node is the first node after statement or in block\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is the first node after statement or in block\n         * @private\n         */\n        function isFirstNode(node) {\n            var parentType = node.parent.type;\n\n            if (node.parent.body) {\n                return Array.isArray(node.parent.body)\n                  ? node.parent.body[0] === node\n                  : node.parent.body === node;\n            }\n\n            if (parentType === \"IfStatement\") {\n                return isPrecededByTokens(node, [\"else\", \")\"]);\n            } else if (parentType === \"DoWhileStatement\") {\n                return isPrecededByTokens(node, [\"do\"]);\n            } else if (parentType === \"SwitchCase\") {\n                return isPrecededByTokens(node, [\":\"]);\n            } else {\n                return isPrecededByTokens(node, [\")\"]);\n            }\n        }\n\n        /**\n         * Returns the number of lines of comments that precede the node\n         * @param {ASTNode} node - node to check for overlapping comments\n         * @param {number} lineNumTokenBefore - line number of previous token, to check for overlapping comments\n         * @returns {number} Number of lines of comments that precede the node\n         * @private\n         */\n        function calcCommentLines(node, lineNumTokenBefore) {\n            var comments = sourceCode.getComments(node).leading,\n                numLinesComments = 0;\n\n            if (!comments.length) {\n                return numLinesComments;\n            }\n\n            comments.forEach(function(comment) {\n                numLinesComments++;\n\n                if (comment.type === \"Block\") {\n                    numLinesComments += comment.loc.end.line - comment.loc.start.line;\n                }\n\n                // avoid counting lines with inline comments twice\n                if (comment.loc.start.line === lineNumTokenBefore) {\n                    numLinesComments--;\n                }\n\n                if (comment.loc.end.line === node.loc.start.line) {\n                    numLinesComments--;\n                }\n            });\n\n            return numLinesComments;\n        }\n\n        /**\n         * Checks whether node is preceded by a newline\n         * @param {ASTNode} node - node to check\n         * @returns {boolean} Whether or not the node is preceded by a newline\n         * @private\n         */\n        function hasNewlineBefore(node) {\n            var tokenBefore = sourceCode.getTokenBefore(node),\n                lineNumNode = node.loc.start.line,\n                lineNumTokenBefore,\n                commentLines;\n\n            /**\n             * Global return (at the beginning of a script) is a special case.\n             * If there is no token before `return`, then we expect no line\n             * break before the return. Comments are allowed to occupy lines\n             * before the global return, just no blank lines.\n             * Setting lineNumTokenBefore to zero in that case results in the\n             * desired behavior.\n             */\n            if (tokenBefore) {\n                lineNumTokenBefore = tokenBefore.loc.end.line;\n            } else {\n                lineNumTokenBefore = 0;     // global return at beginning of script\n            }\n\n            commentLines = calcCommentLines(node, lineNumTokenBefore);\n\n            return (lineNumNode - lineNumTokenBefore - commentLines) > 1;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ReturnStatement: function(node) {\n                if (!isFirstNode(node) && !hasNewlineBefore(node)) {\n                    context.report({\n                        node: node,\n                        message: \"Expected newline before return statement.\"\n                    });\n                }\n            }\n        };\n    }\n};\n"]}