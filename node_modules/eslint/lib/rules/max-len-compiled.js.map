{"version":3,"sources":["max-len.js"],"names":[],"mappings":"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","file":"max-len-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to check for max length on a line.\n * @author Matt DuVall <http://www.mattduvall.com>\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nvar OPTIONS_SCHEMA = {\n    type: \"object\",\n    properties: {\n        code: {\n            type: \"integer\",\n            minimum: 0\n        },\n        comments: {\n            type: \"integer\",\n            minimum: 0\n        },\n        tabWidth: {\n            type: \"integer\",\n            minimum: 0\n        },\n        ignorePattern: {\n            type: \"string\"\n        },\n        ignoreComments: {\n            type: \"boolean\"\n        },\n        ignoreUrls: {\n            type: \"boolean\"\n        },\n        ignoreTrailingComments: {\n            type: \"boolean\"\n        }\n    },\n    additionalProperties: false\n};\n\nvar OPTIONS_OR_INTEGER_SCHEMA = {\n    anyOf: [\n        OPTIONS_SCHEMA,\n        {\n            type: \"integer\",\n            minimum: 0\n        }\n    ]\n};\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum line length\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_OR_INTEGER_SCHEMA,\n            OPTIONS_SCHEMA\n        ]\n    },\n\n    create: function(context) {\n\n        /*\n         * Inspired by http://tools.ietf.org/html/rfc3986#appendix-B, however:\n         * - They're matching an entire string that we know is a URI\n         * - We're matching part of a string where we think there *might* be a URL\n         * - We're only concerned about URLs, as picking out any URI would cause\n         *   too many false positives\n         * - We don't care about matching the entire URL, any small segment is fine\n         */\n        var URL_REGEXP = /[^:/?#]:\\/\\/[^?#]/;\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Computes the length of a line that may contain tabs. The width of each\n         * tab will be the number of spaces to the next tab stop.\n         * @param {string} line The line.\n         * @param {int} tabWidth The width of each tab stop in spaces.\n         * @returns {int} The computed line length.\n         * @private\n         */\n        function computeLineLength(line, tabWidth) {\n            var extraCharacterCount = 0;\n\n            line.replace(/\\t/g, function(match, offset) {\n                var totalOffset = offset + extraCharacterCount,\n                    previousTabStopOffset = tabWidth ? totalOffset % tabWidth : 0,\n                    spaceCount = tabWidth - previousTabStopOffset;\n\n                extraCharacterCount += spaceCount - 1;  // -1 for the replaced tab\n            });\n            return line.length + extraCharacterCount;\n        }\n\n        // The options object must be the last option specified…\n        var lastOption = context.options[context.options.length - 1];\n        var options = typeof lastOption === \"object\" ? Object.create(lastOption) : {};\n\n        // …but max code length…\n        if (typeof context.options[0] === \"number\") {\n            options.code = context.options[0];\n        }\n\n        // …and tabWidth can be optionally specified directly as integers.\n        if (typeof context.options[1] === \"number\") {\n            options.tabWidth = context.options[1];\n        }\n\n        var maxLength = options.code || 80,\n            tabWidth = options.tabWidth || 4,\n            ignorePattern = options.ignorePattern || null,\n            ignoreComments = options.ignoreComments || false,\n            ignoreTrailingComments = options.ignoreTrailingComments || options.ignoreComments || false,\n            ignoreUrls = options.ignoreUrls || false,\n            maxCommentLength = options.comments;\n\n        if (ignorePattern) {\n            ignorePattern = new RegExp(ignorePattern);\n        }\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        /**\n         * Tells if a given comment is trailing: it starts on the current line and\n         * extends to or past the end of the current line.\n         * @param {string} line The source line we want to check for a trailing comment on\n         * @param {number} lineNumber The one-indexed line number for line\n         * @param {ASTNode} comment The comment to inspect\n         * @returns {boolean} If the comment is trailing on the given line\n         */\n        function isTrailingComment(line, lineNumber, comment) {\n            return comment &&\n                (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) &&\n                (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);\n        }\n\n        /**\n         * Tells if a comment encompasses the entire line.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {boolean} If the comment covers the entire line\n         */\n        function isFullLineComment(line, lineNumber, comment) {\n            var start = comment.loc.start,\n                end = comment.loc.end;\n\n            return comment &&\n                (start.line < lineNumber || (start.line === lineNumber && start.column === 0)) &&\n                (end.line > lineNumber || end.column === line.length);\n        }\n\n        /**\n         * Gets the line after the comment and any remaining trailing whitespace is\n         * stripped.\n         * @param {string} line The source line with a trailing comment\n         * @param {number} lineNumber The one-indexed line number this is on\n         * @param {ASTNode} comment The comment to remove\n         * @returns {string} Line without comment and trailing whitepace\n         */\n        function stripTrailingComment(line, lineNumber, comment) {\n\n            // loc.column is zero-indexed\n            return line.slice(0, comment.loc.start.column).replace(/\\s+$/, \"\");\n        }\n\n        /**\n         * Check the program for max length\n         * @param {ASTNode} node Node to examine\n         * @returns {void}\n         * @private\n         */\n        function checkProgramForMaxLength(node) {\n\n            // split (honors line-ending)\n            var lines = sourceCode.lines,\n\n                // list of comments to ignore\n                comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? sourceCode.getAllComments() : [],\n\n                // we iterate over comments in parallel with the lines\n                commentsIndex = 0;\n\n            lines.forEach(function(line, i) {\n\n                // i is zero-indexed, line numbers are one-indexed\n                var lineNumber = i + 1;\n\n                /*\n                 * if we're checking comment length; we need to know whether this\n                 * line is a comment\n                 */\n                var lineIsComment = false;\n\n                /*\n                 * We can short-circuit the comment checks if we're already out of\n                 * comments to check.\n                 */\n                if (commentsIndex < comments.length) {\n\n                    // iterate over comments until we find one past the current line\n                    do {\n                        var comment = comments[++commentsIndex];\n                    } while (comment && comment.loc.start.line <= lineNumber);\n\n                    // and step back by one\n                    comment = comments[--commentsIndex];\n\n                    if (isFullLineComment(line, lineNumber, comment)) {\n                        lineIsComment = true;\n                    } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {\n                        line = stripTrailingComment(line, lineNumber, comment);\n                    }\n                }\n                if (ignorePattern && ignorePattern.test(line) ||\n                    ignoreUrls && URL_REGEXP.test(line)) {\n\n                    // ignore this line\n                    return;\n                }\n\n                var lineLength = computeLineLength(line, tabWidth);\n\n                if (lineIsComment && ignoreComments) {\n                    return;\n                }\n\n                if (lineIsComment && lineLength > maxCommentLength) {\n                    context.report(node, { line: lineNumber, column: 0 }, \"Line \" + (i + 1) + \" exceeds the maximum comment line length of \" + maxCommentLength + \".\");\n                } else if (lineLength > maxLength) {\n                    context.report(node, { line: lineNumber, column: 0 }, \"Line \" + (i + 1) + \" exceeds the maximum line length of \" + maxLength + \".\");\n                }\n            });\n        }\n\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: checkProgramForMaxLength\n        };\n\n    }\n};\n"]}