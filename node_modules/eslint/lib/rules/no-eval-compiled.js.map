{"version":3,"sources":["no-eval.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;AAMA,IAAI,2BAA2B,OAAO,MAAP,CAAc,CACzC,QADyC,EAEzC,QAFyC,CAAd,CAA/B;;;;;;;;;AAYA,SAAS,YAAT,CAAsB,IAAtB,EAA4B,IAA5B,EAAkC;AAC9B,WAAO,KAAK,IAAL,KAAc,YAAd,IAA8B,KAAK,IAAL,KAAc,IAAnD;AACH;;;;;;;;;AASD,SAAS,UAAT,CAAoB,IAApB,EAA0B,IAA1B,EAAgC;AAC5B,YAAQ,KAAK,IAAb;AACI,aAAK,SAAL;AACI,mBAAO,KAAK,KAAL,KAAe,IAAtB;;AAEJ,aAAK,iBAAL;AACI,mBACI,KAAK,WAAL,CAAiB,MAAjB,KAA4B,CAA5B,IACA,KAAK,MAAL,CAAY,CAAZ,EAAe,KAAf,CAAqB,MAArB,KAAgC,IAFpC;;AAKJ;AACI,mBAAO,KAAP;AAXR;AAaH;;;;;;;;;;;AAWD,SAAS,QAAT,CAAkB,IAAlB,EAAwB,IAAxB,EAA8B;AAC1B,WACI,KAAK,IAAL,KAAc,kBAAd,IACA,CAAC,KAAK,QAAL,GAAgB,UAAhB,GAA6B,YAA9B,EAA4C,KAAK,QAAjD,EAA2D,IAA3D,CAFJ;AAIH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,8BADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,+BAAe,EAAC,MAAM,SAAP;AADP,aAFhB;AAKI,kCAAsB;AAL1B,SADI;AAPN,KADO;;AAmBb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,gBAAgB,QAChB,QAAQ,OAAR,CAAgB,CAAhB,KACA,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,aAFH,CAApB;AAIA,YAAI,aAAa,QAAQ,aAAR,EAAjB;AACA,YAAI,WAAW,IAAf;;;;;;;;;;;;AAYA,iBAAS,aAAT,CAAuB,IAAvB,EAA6B;AACzB,gBAAI,SAAS,QAAQ,QAAR,GAAmB,QAAhC;;AAEA,uBAAW;AACP,uBAAO,QADA;AAEP,sBAAM,IAFC;AAGP,wBAAQ,MAHD;AAIP,6BAAa,KAJN;AAKP,6BAAa;AALN,aAAX;AAOH;;;;;;;AAOD,iBAAS,YAAT,GAAwB;AACpB,uBAAW,SAAS,KAApB;AACH;;;;;;;;;;;;;;;AAeD,iBAAS,MAAT,CAAgB,IAAhB,EAAsB;AAClB,gBAAI,eAAe,IAAnB;AACA,gBAAI,SAAS,KAAK,MAAlB;;AAEA,gBAAI,KAAK,IAAL,KAAc,kBAAlB,EAAsC;AAClC,+BAAe,KAAK,QAApB;AACH;AACD,gBAAI,OAAO,IAAP,KAAgB,gBAAhB,IAAoC,OAAO,MAAP,KAAkB,IAA1D,EAAgE;AAC5D,uBAAO,MAAP;AACH;;AAED,oBAAQ,MAAR,CAAe;AACX,sBAAM,IADK;AAEX,qBAAK,aAAa,GAAb,CAAiB,KAFX;AAGX,yBAAS;AAHE,aAAf;AAKH;;;;;;;;AAQD,iBAAS,kCAAT,CAA4C,WAA5C,EAAyD;AACrD,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,yBAAyB,MAA7C,EAAqD,EAAE,CAAvD,EAA0D;AACtD,oBAAI,OAAO,yBAAyB,CAAzB,CAAX;AACA,oBAAI,WAAW,SAAS,iBAAT,CAA2B,WAA3B,EAAwC,IAAxC,CAAf;;AAEA,oBAAI,CAAC,QAAL,EAAe;AACX;AACH;;AAED,oBAAI,aAAa,SAAS,UAA1B;;AAEA,qBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,WAAW,MAA/B,EAAuC,EAAE,CAAzC,EAA4C;AACxC,wBAAI,aAAa,WAAW,CAAX,EAAc,UAA/B;AACA,wBAAI,OAAO,WAAW,MAAtB;;;AAGA,2BAAO,SAAS,IAAT,EAAe,IAAf,CAAP,EAA6B;AACzB,+BAAO,KAAK,MAAZ;AACH;;;AAGD,wBAAI,SAAS,IAAT,EAAe,MAAf,CAAJ,EAA4B;AACxB,+BAAO,IAAP;AACH;AACJ;AACJ;AACJ;;;;;;;;AAQD,iBAAS,mBAAT,CAA6B,WAA7B,EAA0C;AACtC,gBAAI,WAAW,SAAS,iBAAT,CAA2B,WAA3B,EAAwC,MAAxC,CAAf;;AAEA,gBAAI,CAAC,QAAL,EAAe;AACX;AACH;;AAED,gBAAI,aAAa,SAAS,UAA1B;;AAEA,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,WAAW,MAA/B,EAAuC,EAAE,CAAzC,EAA4C;AACxC,oBAAI,YAAY,WAAW,CAAX,CAAhB;AACA,oBAAI,KAAK,UAAU,UAAnB;;AAEA,oBAAI,GAAG,IAAH,KAAY,MAAZ,IAAsB,CAAC,SAAS,QAAT,CAAkB,EAAlB,CAA3B,EAAkD;;;AAG9C,2BAAO,EAAP;AACH;AACJ;AACJ;;AAED,YAAI,aAAJ,EAAmB;;;AAGf,mBAAO;AACH,uCAAuB,UAAS,IAAT,EAAe;AAClC,wBAAI,SAAS,KAAK,MAAlB;;AAEA,wBAAI,aAAa,MAAb,EAAqB,MAArB,CAAJ,EAAkC;AAC9B,+BAAO,MAAP;AACH;AACJ;AAPE,aAAP;AASH;;AAED,eAAO;AACH,mCAAuB,UAAS,IAAT,EAAe;AAClC,oBAAI,SAAS,KAAK,MAAlB;;AAEA,oBAAI,aAAa,MAAb,EAAqB,MAArB,CAAJ,EAAkC;AAC9B,2BAAO,MAAP;AACH;AACJ,aAPE;;AASH,qBAAS,UAAS,IAAT,EAAe;AACpB,oBAAI,QAAQ,QAAQ,QAAR,EAAZ;oBACI,WAAW,QAAQ,aAAR,CAAsB,YAAtB,IAAsC,EADrD;oBAEI,SACI,MAAM,QAAN,IACA,KAAK,UAAL,KAAoB,QADpB,IAEC,SAAS,YAAT,IAAyB,MAAM,WAAN,CAAkB,CAAlB,EAAqB,QALvD;;AAOA,2BAAW;AACP,2BAAO,IADA;AAEP,0BAAM,IAFC;AAGP,4BAAQ,MAHD;AAIP,iCAAa,IAJN;AAKP,iCAAa;AALN,iBAAX;AAOH,aAxBE;;AA0BH,4BAAgB,YAAW;AACvB,oBAAI,cAAc,QAAQ,QAAR,EAAlB;;AAEA;AACA,oCAAoB,WAApB;AACA,mDAAmC,WAAnC;AACH,aAhCE;;AAkCH,iCAAqB,aAlClB;AAmCH,wCAA4B,YAnCzB;AAoCH,gCAAoB,aApCjB;AAqCH,uCAA2B,YArCxB;AAsCH,qCAAyB,aAtCtB;AAuCH,4CAAgC,YAvC7B;;AAyCH,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,CAAC,SAAS,KAAK,MAAd,EAAsB,MAAtB,CAAL,EAAoC;AAChC;AACH;;;;;;AAMD,oBAAI,CAAC,SAAS,WAAd,EAA2B;AACvB,6BAAS,WAAT,GAAuB,IAAvB;AACA,6BAAS,WAAT,GAAuB,SAAS,oBAAT,CACnB,SAAS,IADU,EAEnB,UAFmB,CAAvB;AAIH;;AAED,oBAAI,CAAC,SAAS,MAAV,IAAoB,SAAS,WAAjC,EAA8C;;;AAG1C,2BAAO,KAAK,MAAZ;AACH;AACJ;AA/DE,SAAP;AAkEH;AAtOY,CAAjB","file":"no-eval-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag use of eval() statement\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar candidatesOfGlobalObject = Object.freeze([\n    \"global\",\n    \"window\"\n]);\n\n/**\n * Checks a given node is a Identifier node of the specified name.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Identifier node of the name.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks a given node is a Literal node of the specified string value.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a Literal node of the name.\n */\nfunction isConstant(node, name) {\n    switch (node.type) {\n        case \"Literal\":\n            return node.value === name;\n\n        case \"TemplateLiteral\":\n            return (\n                node.expressions.length === 0 &&\n                node.quasis[0].value.cooked === name\n            );\n\n        default:\n            return false;\n    }\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @param {string} name - A name to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isMember(node, name) {\n    return (\n        node.type === \"MemberExpression\" &&\n        (node.computed ? isConstant : isIdentifier)(node.property, name)\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow the use of `eval()`\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    allowIndirect: {type: \"boolean\"}\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var allowIndirect = Boolean(\n            context.options[0] &&\n            context.options[0].allowIndirect\n        );\n        var sourceCode = context.getSourceCode();\n        var funcInfo = null;\n\n        /**\n         * Pushs a variable scope (Program or Function) information to the stack.\n         *\n         * This is used in order to check whether or not `this` binding is a\n         * reference to the global object.\n         *\n         * @param {ASTNode} node - A node of the scope. This is one of Program,\n         *      FunctionDeclaration, FunctionExpression, and ArrowFunctionExpression.\n         * @returns {void}\n         */\n        function enterVarScope(node) {\n            var strict = context.getScope().isStrict;\n\n            funcInfo = {\n                upper: funcInfo,\n                node: node,\n                strict: strict,\n                defaultThis: false,\n                initialized: strict\n            };\n        }\n\n        /**\n         * Pops a variable scope from the stack.\n         *\n         * @returns {void}\n         */\n        function exitVarScope() {\n            funcInfo = funcInfo.upper;\n        }\n\n        /**\n         * Reports a given node.\n         *\n         * `node` is `Identifier` or `MemberExpression`.\n         * The parent of `node` might be `CallExpression`.\n         *\n         * The location of the report is always `eval` `Identifier` (or possibly\n         * `Literal`). The type of the report is `CallExpression` if the parent is\n         * `CallExpression`. Otherwise, it's the given node type.\n         *\n         * @param {ASTNode} node - A node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            var locationNode = node;\n            var parent = node.parent;\n\n            if (node.type === \"MemberExpression\") {\n                locationNode = node.property;\n            }\n            if (parent.type === \"CallExpression\" && parent.callee === node) {\n                node = parent;\n            }\n\n            context.report({\n                node: node,\n                loc: locationNode.loc.start,\n                message: \"eval can be harmful.\"\n            });\n        }\n\n        /**\n         * Reports accesses of `eval` via the global object.\n         *\n         * @param {escope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEvalViaGlobalObject(globalScope) {\n            for (var i = 0; i < candidatesOfGlobalObject.length; ++i) {\n                var name = candidatesOfGlobalObject[i];\n                var variable = astUtils.getVariableByName(globalScope, name);\n\n                if (!variable) {\n                    continue;\n                }\n\n                var references = variable.references;\n\n                for (var j = 0; j < references.length; ++j) {\n                    var identifier = references[j].identifier;\n                    var node = identifier.parent;\n\n                    // To detect code like `window.window.eval`.\n                    while (isMember(node, name)) {\n                        node = node.parent;\n                    }\n\n                    // Reports.\n                    if (isMember(node, \"eval\")) {\n                        report(node);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Reports all accesses of `eval` (excludes direct calls to eval).\n         *\n         * @param {escope.Scope} globalScope - The global scope.\n         * @returns {void}\n         */\n        function reportAccessingEval(globalScope) {\n            var variable = astUtils.getVariableByName(globalScope, \"eval\");\n\n            if (!variable) {\n                return;\n            }\n\n            var references = variable.references;\n\n            for (var i = 0; i < references.length; ++i) {\n                var reference = references[i];\n                var id = reference.identifier;\n\n                if (id.name === \"eval\" && !astUtils.isCallee(id)) {\n\n                    // Is accessing to eval (excludes direct calls to eval)\n                    report(id);\n                }\n            }\n        }\n\n        if (allowIndirect) {\n\n            // Checks only direct calls to eval. It's simple!\n            return {\n                \"CallExpression:exit\": function(node) {\n                    var callee = node.callee;\n\n                    if (isIdentifier(callee, \"eval\")) {\n                        report(callee);\n                    }\n                }\n            };\n        }\n\n        return {\n            \"CallExpression:exit\": function(node) {\n                var callee = node.callee;\n\n                if (isIdentifier(callee, \"eval\")) {\n                    report(callee);\n                }\n            },\n\n            Program: function(node) {\n                var scope = context.getScope(),\n                    features = context.parserOptions.ecmaFeatures || {},\n                    strict =\n                        scope.isStrict ||\n                        node.sourceType === \"module\" ||\n                        (features.globalReturn && scope.childScopes[0].isStrict);\n\n                funcInfo = {\n                    upper: null,\n                    node: node,\n                    strict: strict,\n                    defaultThis: true,\n                    initialized: true\n                };\n            },\n\n            \"Program:exit\": function() {\n                var globalScope = context.getScope();\n\n                exitVarScope();\n                reportAccessingEval(globalScope);\n                reportAccessingEvalViaGlobalObject(globalScope);\n            },\n\n            FunctionDeclaration: enterVarScope,\n            \"FunctionDeclaration:exit\": exitVarScope,\n            FunctionExpression: enterVarScope,\n            \"FunctionExpression:exit\": exitVarScope,\n            ArrowFunctionExpression: enterVarScope,\n            \"ArrowFunctionExpression:exit\": exitVarScope,\n\n            ThisExpression: function(node) {\n                if (!isMember(node.parent, \"eval\")) {\n                    return;\n                }\n\n                /*\n                 * `this.eval` is found.\n                 * Checks whether or not the value of `this` is the global object.\n                 */\n                if (!funcInfo.initialized) {\n                    funcInfo.initialized = true;\n                    funcInfo.defaultThis = astUtils.isDefaultThisBinding(\n                        funcInfo.node,\n                        sourceCode\n                    );\n                }\n\n                if (!funcInfo.strict && funcInfo.defaultThis) {\n\n                    // `this.eval` is possible built-in `eval`.\n                    report(node.parent);\n                }\n            }\n        };\n\n    }\n};\n"]}