{"version":3,"sources":["prefer-spread.js"],"names":[],"mappings":";;;;;AAKA;;AAEA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;;;;;;AAWA,SAAS,sBAAT,CAAgC,IAAhC,EAAsC;AAClC,WACI,KAAK,MAAL,CAAY,IAAZ,KAAqB,kBAArB,IACA,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,KAA8B,YAD9B,IAEA,KAAK,MAAL,CAAY,QAAZ,CAAqB,IAArB,KAA8B,OAF9B,IAGA,KAAK,MAAL,CAAY,QAAZ,KAAyB,KAHzB,IAIA,KAAK,SAAL,CAAe,MAAf,KAA0B,CAJ1B,IAKA,KAAK,SAAL,CAAe,CAAf,EAAkB,IAAlB,KAA2B,iBAN/B;AAQH;;;;;;;;;AASD,SAAS,WAAT,CAAqB,IAArB,EAA2B,KAA3B,EAAkC,UAAlC,EAA8C;AAC1C,QAAI,UAAU,WAAW,SAAX,CAAqB,IAArB,CAAd;AACA,QAAI,UAAU,WAAW,SAAX,CAAqB,KAArB,CAAd;;AAEA,QAAI,QAAQ,MAAR,KAAmB,QAAQ,MAA/B,EAAuC;AACnC,eAAO,KAAP;AACH;AACD,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,MAA5B,EAAoC,EAAE,CAAtC,EAAyC;AACrC,YAAI,QAAQ,CAAR,EAAW,IAAX,KAAoB,QAAQ,CAAR,EAAW,IAA/B,IACA,QAAQ,CAAR,EAAW,KAAX,KAAqB,QAAQ,CAAR,EAAW,KADpC,EAEE;AACE,mBAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;;;;;;;;AASD,SAAS,cAAT,CAAwB,YAAxB,EAAsC,OAAtC,EAA+C,OAA/C,EAAwD;AACpD,QAAI,CAAC,YAAL,EAAmB;AACf,eAAO,SAAS,iBAAT,CAA2B,OAA3B,CAAP;AACH;AACD,WAAO,YAAY,YAAZ,EAA0B,OAA1B,EAAmC,OAAnC,CAAP;AACH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,gDADX;AAEF,sBAAU,cAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,aAAa,QAAQ,aAAR,EAAjB;;AAEA,eAAO;AACH,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,CAAC,uBAAuB,IAAvB,CAAL,EAAmC;AAC/B;AACH;;AAED,oBAAI,UAAU,KAAK,MAAL,CAAY,MAA1B;AACA,oBAAI,eAAgB,QAAQ,IAAR,KAAiB,kBAAlB,GAAwC,QAAQ,MAAhD,GAAyD,IAA5E;AACA,oBAAI,UAAU,KAAK,SAAL,CAAe,CAAf,CAAd;;AAEA,oBAAI,eAAe,YAAf,EAA6B,OAA7B,EAAsC,UAAtC,CAAJ,EAAuD;AACnD,4BAAQ,MAAR,CAAe,IAAf,EAAqB,oDAArB;AACH;AACJ;AAbE,SAAP;AAeH;AA7BY,CAAjB","file":"prefer-spread-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to suggest using of the spread operator instead of `.apply()`.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a node is a `.apply()` for variadic.\n * @param {ASTNode} node - A CallExpression node to check.\n * @returns {boolean} Whether or not the node is a `.apply()` for variadic.\n */\nfunction isVariadicApplyCalling(node) {\n    return (\n        node.callee.type === \"MemberExpression\" &&\n        node.callee.property.type === \"Identifier\" &&\n        node.callee.property.name === \"apply\" &&\n        node.callee.computed === false &&\n        node.arguments.length === 2 &&\n        node.arguments[1].type !== \"ArrayExpression\"\n    );\n}\n\n/**\n * Checks whether or not the tokens of two given nodes are same.\n * @param {ASTNode} left - A node 1 to compare.\n * @param {ASTNode} right - A node 2 to compare.\n * @param {SourceCode} sourceCode - The ESLint source code object.\n * @returns {boolean} the source code for the given node.\n */\nfunction equalTokens(left, right, sourceCode) {\n    var tokensL = sourceCode.getTokens(left);\n    var tokensR = sourceCode.getTokens(right);\n\n    if (tokensL.length !== tokensR.length) {\n        return false;\n    }\n    for (var i = 0; i < tokensL.length; ++i) {\n        if (tokensL[i].type !== tokensR[i].type ||\n            tokensL[i].value !== tokensR[i].value\n        ) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n/**\n * Checks whether or not `thisArg` is not changed by `.apply()`.\n * @param {ASTNode|null} expectedThis - The node that is the owner of the applied function.\n * @param {ASTNode} thisArg - The node that is given to the first argument of the `.apply()`.\n * @param {RuleContext} context - The ESLint rule context object.\n * @returns {boolean} Whether or not `thisArg` is not changed by `.apply()`.\n */\nfunction isValidThisArg(expectedThis, thisArg, context) {\n    if (!expectedThis) {\n        return astUtils.isNullOrUndefined(thisArg);\n    }\n    return equalTokens(expectedThis, thisArg, context);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require spread operators instead of `.apply()`\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var sourceCode = context.getSourceCode();\n\n        return {\n            CallExpression: function(node) {\n                if (!isVariadicApplyCalling(node)) {\n                    return;\n                }\n\n                var applied = node.callee.object;\n                var expectedThis = (applied.type === \"MemberExpression\") ? applied.object : null;\n                var thisArg = node.arguments[0];\n\n                if (isValidThisArg(expectedThis, thisArg, sourceCode)) {\n                    context.report(node, \"use the spread operator instead of the '.apply()'.\");\n                }\n            }\n        };\n    }\n};\n"]}