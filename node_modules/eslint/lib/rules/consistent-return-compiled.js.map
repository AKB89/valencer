{"version":3,"sources":["consistent-return.js"],"names":[],"mappings":"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","file":"consistent-return-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag consistent return values\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given code path segment is unreachable.\n * @param {CodePathSegment} segment - A CodePathSegment to check.\n * @returns {boolean} `true` if the segment is unreachable.\n */\nfunction isUnreachable(segment) {\n    return !segment.reachable;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `return` statements to either always or never specify values\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                treatUndefinedAsUnspecified: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create: function(context) {\n        var options = context.options[0] || {};\n        var treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;\n        var funcInfo = null;\n\n        /**\n         * Checks whether of not the implicit returning is consistent if the last\n         * code path segment is reachable.\n         *\n         * @param {ASTNode} node - A program/function node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            var loc, type;\n\n            /*\n             * Skip if it expected no return value or unreachable.\n             * When unreachable, all paths are returned or thrown.\n             */\n            if (!funcInfo.hasReturnValue ||\n                funcInfo.codePath.currentSegments.every(isUnreachable) ||\n                astUtils.isES5Constructor(node)\n            ) {\n                return;\n            }\n\n            // Adjust a location and a message.\n            if (node.type === \"Program\") {\n\n                // The head of program.\n                loc = {line: 1, column: 0};\n                type = \"program\";\n            } else if (node.type === \"ArrowFunctionExpression\") {\n\n                // `=>` token\n                loc = context.getSourceCode().getTokenBefore(node.body).loc.start;\n                type = \"function\";\n            } else if (\n                node.parent.type === \"MethodDefinition\" ||\n                (node.parent.type === \"Property\" && node.parent.method)\n            ) {\n\n                // Method name.\n                loc = node.parent.key.loc.start;\n                type = \"method\";\n            } else {\n\n                // Function name or `function` keyword.\n                loc = (node.id || node).loc.start;\n                type = \"function\";\n            }\n\n            // Reports.\n            context.report({\n                node: node,\n                loc: loc,\n                message: \"Expected to return a value at the end of this {{type}}.\",\n                data: {type: type}\n            });\n        }\n\n        return {\n\n            // Initializes/Disposes state of each code path.\n            onCodePathStart: function(codePath) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath: codePath,\n                    hasReturn: false,\n                    hasReturnValue: false,\n                    message: \"\"\n                };\n            },\n            onCodePathEnd: function() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Reports a given return statement if it's inconsistent.\n            ReturnStatement: function(node) {\n                var argument = node.argument;\n                var hasReturnValue = Boolean(argument);\n\n                if (treatUndefinedAsUnspecified && hasReturnValue) {\n                    hasReturnValue = !isIdentifier(argument, \"undefined\") && argument.operator !== \"void\";\n                }\n\n                if (!funcInfo.hasReturn) {\n                    funcInfo.hasReturn = true;\n                    funcInfo.hasReturnValue = hasReturnValue;\n                    funcInfo.message = \"Expected \" + (hasReturnValue ? \"a\" : \"no\") + \" return value.\";\n                } else if (funcInfo.hasReturnValue !== hasReturnValue) {\n                    context.report({node: node, message: funcInfo.message});\n                }\n            },\n\n            // Reports a given program/function if the implicit returning is not consistent.\n            \"Program:exit\": checkLastSegment,\n            \"FunctionDeclaration:exit\": checkLastSegment,\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"]}