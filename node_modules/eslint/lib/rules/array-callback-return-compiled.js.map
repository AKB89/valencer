{"version":3,"sources":["array-callback-return.js"],"names":[],"mappings":"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","file":"array-callback-return-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to enforce return statements in callbacks of array's methods\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/;\nvar TARGET_METHODS = /^(?:every|filter|find(?:Index)?|map|reduce(?:Right)?|some|sort)$/;\n\n/**\n * Checks a given code path segment is reachable.\n *\n * @param {CodePathSegment} segment - A segment to check.\n * @returns {boolean} `true` if the segment is reachable.\n */\nfunction isReachable(segment) {\n    return segment.reachable;\n}\n\n/**\n * Gets a readable location.\n *\n * - FunctionExpression -> the function name or `function` keyword.\n * - ArrowFunctionExpression -> `=>` token.\n *\n * @param {ASTNode} node - A function node to get.\n * @param {SourceCode} sourceCode - A source code to get tokens.\n * @returns {ASTNode|Token} The node or the token of a location.\n */\nfunction getLocation(node, sourceCode) {\n    if (node.type === \"ArrowFunctionExpression\") {\n        return sourceCode.getTokenBefore(node.body);\n    }\n    return node.id || node;\n}\n\n/**\n * Gets the name of a given node if the node is a Identifier node.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string} The name of the node, or an empty string.\n */\nfunction getIdentifierName(node) {\n    return node.type === \"Identifier\" ? node.name : \"\";\n}\n\n/**\n * Gets the value of a given node if the node is a Literal node or a\n * TemplateLiteral node.\n *\n * @param {ASTNode} node - A node to get.\n * @returns {string} The value of the node, or an empty string.\n */\nfunction getConstantStringValue(node) {\n    switch (node.type) {\n        case \"Literal\":\n            return String(node.value);\n\n        case \"TemplateLiteral\":\n            return node.expressions.length === 0\n                ? node.quasis[0].value.cooked\n                : \"\";\n\n        default:\n            return \"\";\n    }\n}\n\n/**\n * Checks a given node is a MemberExpression node which has the specified name's\n * property.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a MemberExpression node which has\n *      the specified name's property\n */\nfunction isTargetMethod(node) {\n    return (\n        node.type === \"MemberExpression\" &&\n        TARGET_METHODS.test(\n            (node.computed ? getConstantStringValue : getIdentifierName)(node.property)\n        )\n    );\n}\n\n/**\n * Checks whether or not a given node is a function expression which is the\n * callback of an array method.\n *\n * @param {ASTNode} node - A node to check. This is one of\n *      FunctionExpression or ArrowFunctionExpression.\n * @returns {boolean} `true` if the node is the callback of an array method.\n */\nfunction isCallbackOfArrayMethod(node) {\n    while (node) {\n        var parent = node.parent;\n\n        switch (parent.type) {\n\n            /*\n             * Looks up the destination. e.g.,\n             * foo.every(nativeFoo || function foo() { ... });\n             */\n            case \"LogicalExpression\":\n            case \"ConditionalExpression\":\n                node = parent;\n                break;\n\n            // If the upper function is IIFE, checks the destination of the return value.\n            // e.g.\n            //   foo.every((function() {\n            //     // setup...\n            //     return function callback() { ... };\n            //   })());\n            case \"ReturnStatement\":\n                var func = astUtils.getUpperFunction(parent);\n\n                if (func === null || !astUtils.isCallee(func)) {\n                    return false;\n                }\n                node = func.parent;\n                break;\n\n            // e.g.\n            //   Array.from([], function() {});\n            //   list.every(function() {});\n            case \"CallExpression\":\n                if (astUtils.isArrayFromMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 2 &&\n                        parent.arguments[1] === node\n                    );\n                }\n                if (isTargetMethod(parent.callee)) {\n                    return (\n                        parent.arguments.length >= 1 &&\n                        parent.arguments[0] === node\n                    );\n                }\n                return false;\n\n            // Otherwise this node is not target.\n            default:\n                return false;\n        }\n    }\n\n    /* istanbul ignore next: unreachable */\n    return false;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce `return` statements in callbacks of array methods\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var funcInfo = {\n            upper: null,\n            codePath: null,\n            hasReturn: false,\n            shouldCheck: false\n        };\n\n        /**\n         * Checks whether or not the last code path segment is reachable.\n         * Then reports this function if the segment is reachable.\n         *\n         * If the last code path segment is reachable, there are paths which are not\n         * returned or thrown.\n         *\n         * @param {ASTNode} node - A node to check.\n         * @returns {void}\n         */\n        function checkLastSegment(node) {\n            if (funcInfo.shouldCheck &&\n                funcInfo.codePath.currentSegments.some(isReachable)\n            ) {\n                context.report({\n                    node: node,\n                    loc: getLocation(node, context.getSourceCode()).loc.start,\n                    message: funcInfo.hasReturn\n                        ? \"Expected to return a value at the end of this function.\"\n                        : \"Expected to return a value in this function.\"\n                });\n            }\n        }\n\n        return {\n\n            // Stacks this function's information.\n            onCodePathStart: function(codePath, node) {\n                funcInfo = {\n                    upper: funcInfo,\n                    codePath: codePath,\n                    hasReturn: false,\n                    shouldCheck:\n                        TARGET_NODE_TYPE.test(node.type) &&\n                        node.body.type === \"BlockStatement\" &&\n                        isCallbackOfArrayMethod(node)\n                };\n            },\n\n            // Pops this function's information.\n            onCodePathEnd: function() {\n                funcInfo = funcInfo.upper;\n            },\n\n            // Checks the return statement is valid.\n            ReturnStatement: function(node) {\n                if (funcInfo.shouldCheck) {\n                    funcInfo.hasReturn = true;\n\n                    if (!node.argument) {\n                        context.report({\n                            node: node,\n                            message: \"Expected a return value.\"\n                        });\n                    }\n                }\n            },\n\n            // Reports a given function if the last path is reachable.\n            \"FunctionExpression:exit\": checkLastSegment,\n            \"ArrowFunctionExpression:exit\": checkLastSegment\n        };\n    }\n};\n"]}