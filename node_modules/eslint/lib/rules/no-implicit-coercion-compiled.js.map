{"version":3,"sources":["no-implicit-coercion.js"],"names":[],"mappings":"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","file":"no-implicit-coercion-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to disallow the type conversions with shorter notations.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/;\nvar ALLOWABLE_OPERATORS = [\"~\", \"!!\", \"+\", \"*\"];\n\n/**\n * Parses and normalizes an option object.\n * @param {object} options - An option object to parse.\n * @returns {object} The parsed and normalized option object.\n */\nfunction parseOptions(options) {\n    options = options || {};\n    return {\n        boolean: \"boolean\" in options ? Boolean(options.boolean) : true,\n        number: \"number\" in options ? Boolean(options.number) : true,\n        string: \"string\" in options ? Boolean(options.string) : true,\n        allow: options.allow || []\n    };\n}\n\n/**\n * Checks whether or not a node is a double logical nigating.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a double logical nigating.\n */\nfunction isDoubleLogicalNegating(node) {\n    return (\n        node.operator === \"!\" &&\n        node.argument.type === \"UnaryExpression\" &&\n        node.argument.operator === \"!\"\n    );\n}\n\n/**\n * Checks whether or not a node is a binary negating of `.indexOf()` method calling.\n * @param {ASTNode} node - An UnaryExpression node to check.\n * @returns {boolean} Whether or not the node is a binary negating of `.indexOf()` method calling.\n */\nfunction isBinaryNegatingOfIndexOf(node) {\n    return (\n        node.operator === \"~\" &&\n        node.argument.type === \"CallExpression\" &&\n        node.argument.callee.type === \"MemberExpression\" &&\n        node.argument.callee.property.type === \"Identifier\" &&\n        INDEX_OF_PATTERN.test(node.argument.callee.property.name)\n    );\n}\n\n/**\n * Checks whether or not a node is a multiplying by one.\n * @param {BinaryExpression} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a multiplying by one.\n */\nfunction isMultiplyByOne(node) {\n    return node.operator === \"*\" && (\n        node.left.type === \"Literal\" && node.left.value === 1 ||\n        node.right.type === \"Literal\" && node.right.value === 1\n    );\n}\n\n/**\n * Checks whether the result of a node is numeric or not\n * @param {ASTNode} node The node to test\n * @returns {boolean} true if the node is a number literal or a `Number()`, `parseInt` or `parseFloat` call\n */\nfunction isNumeric(node) {\n    return (\n        node.type === \"Literal\" && typeof node.value === \"number\" ||\n        node.type === \"CallExpression\" && (\n            node.callee.name === \"Number\" ||\n            node.callee.name === \"parseInt\" ||\n            node.callee.name === \"parseFloat\"\n        )\n    );\n}\n\n/**\n * Returns the first non-numeric operand in a BinaryExpression. Designed to be\n * used from bottom to up since it walks up the BinaryExpression trees using\n * node.parent to find the result.\n * @param {BinaryExpression} node The BinaryExpression node to be walked up on\n * @returns {ASTNode|null} The first non-numeric item in the BinaryExpression tree or null\n */\nfunction getNonNumericOperand(node) {\n    var left = node.left,\n        right = node.right;\n\n    if (right.type !== \"BinaryExpression\" && !isNumeric(right)) {\n        return right;\n    }\n\n    if (left.type !== \"BinaryExpression\" && !isNumeric(left)) {\n        return left;\n    }\n\n    return null;\n}\n\n/**\n * Checks whether or not a node is a concatenating with an empty string.\n * @param {ASTNode} node - A BinaryExpression node to check.\n * @returns {boolean} Whether or not the node is a concatenating with an empty string.\n */\nfunction isConcatWithEmptyString(node) {\n    return node.operator === \"+\" && (\n        (node.left.type === \"Literal\" && node.left.value === \"\") ||\n        (node.right.type === \"Literal\" && node.right.value === \"\")\n    );\n}\n\n/**\n * Checks whether or not a node is appended with an empty string.\n * @param {ASTNode} node - An AssignmentExpression node to check.\n * @returns {boolean} Whether or not the node is appended with an empty string.\n */\nfunction isAppendEmptyString(node) {\n    return node.operator === \"+=\" && node.right.type === \"Literal\" && node.right.value === \"\";\n}\n\n/**\n * Gets a node that is the left or right operand of a node, is not the specified literal.\n * @param {ASTNode} node - A BinaryExpression node to get.\n * @param {any} value - A literal value to check.\n * @returns {ASTNode} A node that is the left or right operand of the node, is not the specified literal.\n */\nfunction getOtherOperand(node, value) {\n    if (node.left.type === \"Literal\" && node.left.value === value) {\n        return node.right;\n    }\n    return node.left;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow shorthand type conversions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [{\n            type: \"object\",\n            properties: {\n                boolean: {\n                    type: \"boolean\"\n                },\n                number: {\n                    type: \"boolean\"\n                },\n                string: {\n                    type: \"boolean\"\n                },\n                allow: {\n                    type: \"array\",\n                    items: {\n                        enum: ALLOWABLE_OPERATORS\n                    },\n                    uniqueItems: true\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n\n    create: function(context) {\n        var options = parseOptions(context.options[0]),\n            operatorAllowed = false;\n\n        var sourceCode = context.getSourceCode();\n\n        return {\n            UnaryExpression: function(node) {\n\n                // !!foo\n                operatorAllowed = options.allow.indexOf(\"!!\") >= 0;\n                if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {\n                    context.report(\n                        node,\n                        \"use `Boolean({{code}})` instead.\", {\n                            code: sourceCode.getText(node.argument.argument)\n                        });\n                }\n\n                // ~foo.indexOf(bar)\n                operatorAllowed = options.allow.indexOf(\"~\") >= 0;\n                if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {\n                    context.report(\n                        node,\n                        \"use `{{code}} !== -1` instead.\", {\n                            code: sourceCode.getText(node.argument)\n                        });\n                }\n\n                // +foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.number && node.operator === \"+\" && !isNumeric(node.argument)) {\n                    context.report(\n                        node,\n                        \"use `Number({{code}})` instead.\", {\n                            code: sourceCode.getText(node.argument)\n                        });\n                }\n            },\n\n            // Use `:exit` to prevent double reporting\n            \"BinaryExpression:exit\": function(node) {\n\n                // 1 * foo\n                operatorAllowed = options.allow.indexOf(\"*\") >= 0;\n                var nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);\n\n                if (nonNumericOperand) {\n                    context.report(\n                        node,\n                        \"use `Number({{code}})` instead.\", {\n                            code: sourceCode.getText(nonNumericOperand)\n                        });\n                }\n\n                // \"\" + foo\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {\n                    context.report(\n                        node,\n                        \"use `String({{code}})` instead.\", {\n                            code: sourceCode.getText(getOtherOperand(node, \"\"))\n                        });\n                }\n            },\n\n            AssignmentExpression: function(node) {\n\n                // foo += \"\"\n                operatorAllowed = options.allow.indexOf(\"+\") >= 0;\n                if (options.string && isAppendEmptyString(node)) {\n                    context.report(\n                        node,\n                        \"use `{{code}} = String({{code}})` instead.\", {\n                            code: sourceCode.getText(getOtherOperand(node, \"\"))\n                        });\n                }\n            }\n        };\n    }\n};\n"]}