{"version":3,"sources":["indent.js"],"names":[],"mappings":"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","file":"indent-compiled.js","sourcesContent":["/**\n * @fileoverview This option sets a specific tab width for your code\n *\n * This rule has been ported and modified from nodeca.\n * @author Vitaly Puzrin\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\nvar util = require(\"util\");\nvar lodash = require(\"lodash\");\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent indentation\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        enum: [\"tab\"]\n                    },\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                ]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    SwitchCase: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    VariableDeclarator: {\n                        oneOf: [\n                            {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            {\n                                type: \"object\",\n                                properties: {\n                                    var: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    let: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    },\n                                    const: {\n                                        type: \"integer\",\n                                        minimum: 0\n                                    }\n                                }\n                            }\n                        ]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var MESSAGE = \"Expected indentation of {{needed}} {{type}} {{characters}} but found {{gotten}}.\";\n        var DEFAULT_VARIABLE_INDENT = 1;\n\n        var indentType = \"space\";\n        var indentSize = 4;\n        var options = {\n            SwitchCase: 0,\n            VariableDeclarator: {\n                var: DEFAULT_VARIABLE_INDENT,\n                let: DEFAULT_VARIABLE_INDENT,\n                const: DEFAULT_VARIABLE_INDENT\n            }\n        };\n\n        var sourceCode = context.getSourceCode();\n\n        if (context.options.length) {\n            if (context.options[0] === \"tab\") {\n                indentSize = 1;\n                indentType = \"tab\";\n            } else /* istanbul ignore else : this will be caught by options validation */ if (typeof context.options[0] === \"number\") {\n                indentSize = context.options[0];\n                indentType = \"space\";\n            }\n\n            if (context.options[1]) {\n                var opts = context.options[1];\n\n                options.SwitchCase = opts.SwitchCase || 0;\n                var variableDeclaratorRules = opts.VariableDeclarator;\n\n                if (typeof variableDeclaratorRules === \"number\") {\n                    options.VariableDeclarator = {\n                        var: variableDeclaratorRules,\n                        let: variableDeclaratorRules,\n                        const: variableDeclaratorRules\n                    };\n                } else if (typeof variableDeclaratorRules === \"object\") {\n                    lodash.assign(options.VariableDeclarator, variableDeclaratorRules);\n                }\n            }\n        }\n\n        var indentPattern = {\n            normal: indentType === \"space\" ? /^ +/ : /^\\t+/,\n            excludeCommas: indentType === \"space\" ? /^[ ,]+/ : /^[\\t,]+/\n        };\n\n        var caseIndentStore = {};\n\n        /**\n         * Reports a given indent violation and properly pluralizes the message\n         * @param {ASTNode} node Node violating the indent rule\n         * @param {int} needed Expected indentation character count\n         * @param {int} gotten Indentation character count in the actual node/code\n         * @param {Object=} loc Error line and column location\n         * @param {boolean} isLastNodeCheck Is the error for last node check\n         * @returns {void}\n         */\n        function report(node, needed, gotten, loc, isLastNodeCheck) {\n            var msgContext = {\n                needed: needed,\n                type: indentType,\n                characters: needed === 1 ? \"character\" : \"characters\",\n                gotten: gotten\n            };\n            var indentChar = indentType === \"space\" ? \" \" : \"\\t\";\n\n            /**\n             * Responsible for fixing the indentation issue fix\n             * @returns {Function} function to be executed by the fixer\n             * @private\n             */\n            function getFixerFunction() {\n                var rangeToFix = [];\n\n                if (needed > gotten) {\n                    var spaces = \"\" + new Array(needed - gotten + 1).join(indentChar);  // replace with repeat in future\n\n                    if (isLastNodeCheck === true) {\n                        rangeToFix = [\n                            node.range[1] - 1,\n                            node.range[1] - 1\n                        ];\n                    } else {\n                        rangeToFix = [\n                            node.range[0],\n                            node.range[0]\n                        ];\n                    }\n\n                    return function(fixer) {\n                        return fixer.insertTextBeforeRange(rangeToFix, spaces);\n                    };\n                } else {\n                    if (isLastNodeCheck === true) {\n                        rangeToFix = [\n                            node.range[1] - (gotten - needed) - 1,\n                            node.range[1] - 1\n                        ];\n                    } else {\n                        rangeToFix = [\n                            node.range[0] - (gotten - needed),\n                            node.range[0]\n                        ];\n                    }\n\n                    return function(fixer) {\n                        return fixer.removeRange(rangeToFix);\n                    };\n                }\n            }\n\n            if (loc) {\n                context.report({\n                    node: node,\n                    loc: loc,\n                    message: MESSAGE,\n                    data: msgContext,\n                    fix: getFixerFunction()\n                });\n            } else {\n                context.report({\n                    node: node,\n                    message: MESSAGE,\n                    data: msgContext,\n                    fix: getFixerFunction()\n                });\n            }\n        }\n\n        /**\n         * Get node indent\n         * @param {ASTNode|Token} node Node to examine\n         * @param {boolean} [byLastLine=false] get indent of node's last line\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {int} Indent\n         */\n        function getNodeIndent(node, byLastLine, excludeCommas) {\n            var token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);\n            var src = sourceCode.getText(token, token.loc.start.column);\n            var regExp = excludeCommas ? indentPattern.excludeCommas : indentPattern.normal;\n            var indent = regExp.exec(src);\n\n            return indent ? indent[0].length : 0;\n        }\n\n        /**\n         * Checks node is the first in its own start line. By default it looks by start line.\n         * @param {ASTNode} node The node to check\n         * @param {boolean} [byEndLocation=false] Lookup based on start position or end\n         * @returns {boolean} true if its the first in the its start line\n         */\n        function isNodeFirstInLine(node, byEndLocation) {\n            var firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node),\n                startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line,\n                endLine = firstToken ? firstToken.loc.end.line : -1;\n\n            return startLine !== endLine;\n        }\n\n        /**\n         * Check indent for node\n         * @param {ASTNode} node Node to check\n         * @param {int} indent needed indent\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {void}\n         */\n        function checkNodeIndent(node, indent, excludeCommas) {\n            var nodeIndent = getNodeIndent(node, false, excludeCommas);\n\n            if (\n                node.type !== \"ArrayExpression\" && node.type !== \"ObjectExpression\" &&\n                nodeIndent !== indent && isNodeFirstInLine(node)\n            ) {\n                report(node, indent, nodeIndent);\n            }\n        }\n\n        /**\n         * Check indent for nodes list\n         * @param {ASTNode[]} nodes list of node objects\n         * @param {int} indent needed indent\n         * @param {boolean} [excludeCommas=false] skip comma on start of line\n         * @returns {void}\n         */\n        function checkNodesIndent(nodes, indent, excludeCommas) {\n            nodes.forEach(function(node) {\n                if (node.type === \"IfStatement\" && node.alternate) {\n                    var elseToken = sourceCode.getTokenBefore(node.alternate);\n\n                    checkNodeIndent(elseToken, indent, excludeCommas);\n                }\n                checkNodeIndent(node, indent, excludeCommas);\n            });\n        }\n\n        /**\n         * Check last node line indent this detects, that block closed correctly\n         * @param {ASTNode} node Node to examine\n         * @param {int} lastLineIndent needed indent\n         * @returns {void}\n         */\n        function checkLastNodeLineIndent(node, lastLineIndent) {\n            var lastToken = sourceCode.getLastToken(node);\n            var endIndent = getNodeIndent(lastToken, true);\n\n            if (endIndent !== lastLineIndent && isNodeFirstInLine(node, true)) {\n                report(\n                    node,\n                    lastLineIndent,\n                    endIndent,\n                    { line: lastToken.loc.start.line, column: lastToken.loc.start.column },\n                    true\n                );\n            }\n        }\n\n        /**\n         * Check first node line indent is correct\n         * @param {ASTNode} node Node to examine\n         * @param {int} firstLineIndent needed indent\n         * @returns {void}\n         */\n        function checkFirstNodeLineIndent(node, firstLineIndent) {\n            var startIndent = getNodeIndent(node, false);\n\n            if (startIndent !== firstLineIndent && isNodeFirstInLine(node)) {\n                report(\n                    node,\n                    firstLineIndent,\n                    startIndent,\n                    { line: node.loc.start.line, column: node.loc.start.column }\n                );\n            }\n        }\n\n        /**\n         * Returns the VariableDeclarator based on the current node\n         * if not present then return null\n         * @param {ASTNode} node node to examine\n         * @returns {ASTNode|void} if found then node otherwise null\n         */\n        function getVariableDeclaratorNode(node) {\n            var parent = node.parent;\n\n            while (parent.type !== \"VariableDeclarator\" && parent.type !== \"Program\") {\n                parent = parent.parent;\n            }\n\n            return parent.type === \"VariableDeclarator\" ? parent : null;\n        }\n\n        /**\n         * Check to see if the node is part of the multi-line variable declaration.\n         * Also if its on the same line as the varNode\n         * @param {ASTNode} node node to check\n         * @param {ASTNode} varNode variable declaration node to check against\n         * @returns {boolean} True if all the above condition satisfy\n         */\n        function isNodeInVarOnTop(node, varNode) {\n            return varNode &&\n                varNode.parent.loc.start.line === node.loc.start.line &&\n                varNode.parent.declarations.length > 1;\n        }\n\n        /**\n         * Check to see if the argument before the callee node is multi-line and\n         * there should only be 1 argument before the callee node\n         * @param {ASTNode} node node to check\n         * @returns {boolean} True if arguments are multi-line\n         */\n        function isArgBeforeCalleeNodeMultiline(node) {\n            var parent = node.parent;\n\n            if (parent.arguments.length >= 2 && parent.arguments[1] === node) {\n                return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;\n            }\n\n            return false;\n        }\n\n        /**\n         * Check indent for function block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInFunctionBlock(node) {\n\n            /*\n             * Search first caller in chain.\n             * Ex.:\n             *\n             * Models <- Identifier\n             *   .User\n             *   .find()\n             *   .exec(function() {\n             *   // function body\n             * });\n             *\n             * Looks for 'Models'\n             */\n            var calleeNode = node.parent; // FunctionExpression\n            var indent;\n\n            if (calleeNode.parent &&\n                (calleeNode.parent.type === \"Property\" ||\n                calleeNode.parent.type === \"ArrayExpression\")) {\n\n                // If function is part of array or object, comma can be put at left\n                indent = getNodeIndent(calleeNode, false, false);\n            } else {\n\n                // If function is standalone, simple calculate indent\n                indent = getNodeIndent(calleeNode);\n            }\n\n            if (calleeNode.parent.type === \"CallExpression\") {\n                var calleeParent = calleeNode.parent;\n\n                if (calleeNode.type !== \"FunctionExpression\" && calleeNode.type !== \"ArrowFunctionExpression\") {\n                    if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {\n                        indent = getNodeIndent(calleeParent);\n                    }\n                } else {\n                    if (isArgBeforeCalleeNodeMultiline(calleeNode) &&\n                        calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line &&\n                        !isNodeFirstInLine(calleeNode)) {\n                        indent = getNodeIndent(calleeParent);\n                    }\n                }\n            }\n\n            // function body indent should be indent + indent size\n            indent += indentSize;\n\n            // check if the node is inside a variable\n            var parentVarNode = getVariableDeclaratorNode(node);\n\n            if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {\n                indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            if (node.body.length > 0) {\n                checkNodesIndent(node.body, indent);\n            }\n\n            checkLastNodeLineIndent(node, indent - indentSize);\n        }\n\n\n        /**\n         * Checks if the given node starts and ends on the same line\n         * @param {ASTNode} node The node to check\n         * @returns {boolean} Whether or not the block starts and ends on the same line.\n         */\n        function isSingleLineNode(node) {\n            var lastToken = sourceCode.getLastToken(node),\n                startLine = node.loc.start.line,\n                endLine = lastToken.loc.end.line;\n\n            return startLine === endLine;\n        }\n\n        /**\n         * Check to see if the first element inside an array is an object and on the same line as the node\n         * If the node is not an array then it will return false.\n         * @param {ASTNode} node node to check\n         * @returns {boolean} success/failure\n         */\n        function isFirstArrayElementOnSameLine(node) {\n            if (node.type === \"ArrayExpression\" && node.elements[0]) {\n                return node.elements[0].loc.start.line === node.loc.start.line && node.elements[0].type === \"ObjectExpression\";\n            } else {\n                return false;\n            }\n        }\n\n        /**\n         * Check indent for array block content or object block content\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInArrayOrObjectBlock(node) {\n\n            // Skip inline\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            var elements = (node.type === \"ArrayExpression\") ? node.elements : node.properties;\n\n            // filter out empty elements example would be [ , 2] so remove first element as espree considers it as null\n            elements = elements.filter(function(elem) {\n                return elem !== null;\n            });\n\n            // Skip if first element is in same line with this node\n            if (elements.length > 0 && elements[0].loc.start.line === node.loc.start.line) {\n                return;\n            }\n\n            var nodeIndent;\n            var elementsIndent;\n            var parentVarNode = getVariableDeclaratorNode(node);\n\n            // TODO - come up with a better strategy in future\n            if (isNodeFirstInLine(node)) {\n                var parent = node.parent;\n                var effectiveParent = parent;\n\n                if (parent.type === \"MemberExpression\") {\n                    if (isNodeFirstInLine(parent)) {\n                        effectiveParent = parent.parent.parent;\n                    } else {\n                        effectiveParent = parent.parent;\n                    }\n                }\n                nodeIndent = getNodeIndent(effectiveParent);\n                if (parentVarNode && parentVarNode.loc.start.line !== node.loc.start.line) {\n                    if (parent.type !== \"VariableDeclarator\" || parentVarNode === parentVarNode.parent.declarations[0]) {\n                        if (parent.type === \"VariableDeclarator\" && parentVarNode.loc.start.line === effectiveParent.loc.start.line) {\n                            nodeIndent = nodeIndent + (indentSize * options.VariableDeclarator[parentVarNode.parent.kind]);\n                        } else if (\n                            parent.type === \"ObjectExpression\" ||\n                            parent.type === \"ArrayExpression\" ||\n                            parent.type === \"CallExpression\" ||\n                            parent.type === \"ArrowFunctionExpression\" ||\n                            parent.type === \"NewExpression\"\n                        ) {\n                            nodeIndent = nodeIndent + indentSize;\n                        }\n                    }\n                } else if (!parentVarNode && !isFirstArrayElementOnSameLine(parent) && effectiveParent.type !== \"MemberExpression\" && effectiveParent.type !== \"ExpressionStatement\" && effectiveParent.type !== \"AssignmentExpression\" && effectiveParent.type !== \"Property\") {\n                    nodeIndent = nodeIndent + indentSize;\n                }\n\n                elementsIndent = nodeIndent + indentSize;\n\n                checkFirstNodeLineIndent(node, nodeIndent);\n            } else {\n                nodeIndent = getNodeIndent(node);\n                elementsIndent = nodeIndent + indentSize;\n            }\n\n            /*\n             * Check if the node is a multiple variable declaration; if so, then\n             * make sure indentation takes that into account.\n             */\n            if (isNodeInVarOnTop(node, parentVarNode)) {\n                elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];\n            }\n\n            // Comma can be placed before property name\n            checkNodesIndent(elements, elementsIndent, true);\n\n            if (elements.length > 0) {\n\n                // Skip last block line check if last item in same line\n                if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {\n                    return;\n                }\n            }\n\n            checkLastNodeLineIndent(node, elementsIndent - indentSize);\n        }\n\n        /**\n         * Check if the node or node body is a BlockStatement or not\n         * @param {ASTNode} node node to test\n         * @returns {boolean} True if it or its body is a block statement\n         */\n        function isNodeBodyBlock(node) {\n            return node.type === \"BlockStatement\" || node.type === \"ClassBody\" || (node.body && node.body.type === \"BlockStatement\") ||\n                (node.consequent && node.consequent.type === \"BlockStatement\");\n        }\n\n        /**\n         * Check indentation for blocks\n         * @param {ASTNode} node node to check\n         * @returns {void}\n         */\n        function blockIndentationCheck(node) {\n\n            // Skip inline blocks\n            if (isSingleLineNode(node)) {\n                return;\n            }\n\n            if (node.parent && (\n                    node.parent.type === \"FunctionExpression\" ||\n                    node.parent.type === \"FunctionDeclaration\" ||\n                    node.parent.type === \"ArrowFunctionExpression\"\n            )) {\n                checkIndentInFunctionBlock(node);\n                return;\n            }\n\n            var indent;\n            var nodesToCheck = [];\n\n            /*\n             * For this statements we should check indent from statement beginning,\n             * not from the beginning of the block.\n             */\n            var statementsWithProperties = [\n                \"IfStatement\", \"WhileStatement\", \"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"DoWhileStatement\", \"ClassDeclaration\"\n            ];\n\n            if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {\n                indent = getNodeIndent(node.parent);\n            } else {\n                indent = getNodeIndent(node);\n            }\n\n            if (node.type === \"IfStatement\" && node.consequent.type !== \"BlockStatement\") {\n                nodesToCheck = [node.consequent];\n            } else if (util.isArray(node.body)) {\n                nodesToCheck = node.body;\n            } else {\n                nodesToCheck = [node.body];\n            }\n\n            if (nodesToCheck.length > 0) {\n                checkNodesIndent(nodesToCheck, indent + indentSize);\n            }\n\n            if (node.type === \"BlockStatement\") {\n                checkLastNodeLineIndent(node, indent);\n            }\n        }\n\n        /**\n         * Filter out the elements which are on the same line of each other or the node.\n         * basically have only 1 elements from each line except the variable declaration line.\n         * @param {ASTNode} node Variable declaration node\n         * @returns {ASTNode[]} Filtered elements\n         */\n        function filterOutSameLineVars(node) {\n            return node.declarations.reduce(function(finalCollection, elem) {\n                var lastElem = finalCollection[finalCollection.length - 1];\n\n                if ((elem.loc.start.line !== node.loc.start.line && !lastElem) ||\n                    (lastElem && lastElem.loc.start.line !== elem.loc.start.line)) {\n                    finalCollection.push(elem);\n                }\n\n                return finalCollection;\n            }, []);\n        }\n\n        /**\n         * Check indentation for variable declarations\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function checkIndentInVariableDeclarations(node) {\n            var elements = filterOutSameLineVars(node);\n            var nodeIndent = getNodeIndent(node);\n            var lastElement = elements[elements.length - 1];\n\n            var elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];\n\n            // Comma can be placed before declaration\n            checkNodesIndent(elements, elementsIndent, true);\n\n            // Only check the last line if there is any token after the last item\n            if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {\n                return;\n            }\n\n            var tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);\n\n            if (tokenBeforeLastElement.value === \",\") {\n\n                // Special case for comma-first syntax where the semicolon is indented\n                checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement));\n            } else {\n                checkLastNodeLineIndent(node, elementsIndent - indentSize);\n            }\n        }\n\n        /**\n         * Check and decide whether to check for indentation for blockless nodes\n         * Scenarios are for or while statements without braces around them\n         * @param {ASTNode} node node to examine\n         * @returns {void}\n         */\n        function blockLessNodes(node) {\n            if (node.body.type !== \"BlockStatement\") {\n                blockIndentationCheck(node);\n            }\n        }\n\n        /**\n         * Returns the expected indentation for the case statement\n         * @param {ASTNode} node node to examine\n         * @param {int} [switchIndent] indent for switch statement\n         * @returns {int} indent size\n         */\n        function expectedCaseIndent(node, switchIndent) {\n            var switchNode = (node.type === \"SwitchStatement\") ? node : node.parent;\n            var caseIndent;\n\n            if (caseIndentStore[switchNode.loc.start.line]) {\n                return caseIndentStore[switchNode.loc.start.line];\n            } else {\n                if (typeof switchIndent === \"undefined\") {\n                    switchIndent = getNodeIndent(switchNode);\n                }\n\n                if (switchNode.cases.length > 0 && options.SwitchCase === 0) {\n                    caseIndent = switchIndent;\n                } else {\n                    caseIndent = switchIndent + (indentSize * options.SwitchCase);\n                }\n\n                caseIndentStore[switchNode.loc.start.line] = caseIndent;\n                return caseIndent;\n            }\n        }\n\n        return {\n            Program: function(node) {\n                if (node.body.length > 0) {\n\n                    // Root nodes should have no indent\n                    checkNodesIndent(node.body, getNodeIndent(node));\n                }\n            },\n\n            ClassBody: blockIndentationCheck,\n\n            BlockStatement: blockIndentationCheck,\n\n            WhileStatement: blockLessNodes,\n\n            ForStatement: blockLessNodes,\n\n            ForInStatement: blockLessNodes,\n\n            ForOfStatement: blockLessNodes,\n\n            DoWhileStatement: blockLessNodes,\n\n            IfStatement: function(node) {\n                if (node.consequent.type !== \"BlockStatement\" && node.consequent.loc.start.line > node.loc.start.line) {\n                    blockIndentationCheck(node);\n                }\n            },\n\n            VariableDeclaration: function(node) {\n                if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {\n                    checkIndentInVariableDeclarations(node);\n                }\n            },\n\n            ObjectExpression: function(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            ArrayExpression: function(node) {\n                checkIndentInArrayOrObjectBlock(node);\n            },\n\n            SwitchStatement: function(node) {\n\n                // Switch is not a 'BlockStatement'\n                var switchIndent = getNodeIndent(node);\n                var caseIndent = expectedCaseIndent(node, switchIndent);\n\n                checkNodesIndent(node.cases, caseIndent);\n\n\n                checkLastNodeLineIndent(node, switchIndent);\n            },\n\n            SwitchCase: function(node) {\n\n                // Skip inline cases\n                if (isSingleLineNode(node)) {\n                    return;\n                }\n                var caseIndent = expectedCaseIndent(node);\n\n                checkNodesIndent(node.consequent, caseIndent + indentSize);\n            }\n        };\n\n    }\n};\n"]}