{"version":3,"sources":["wrap-iife.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,6DADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,CAAC,SAAD,EAAY,QAAZ,EAAsB,KAAtB;AADV,SADI;AAPN,KADO;;AAeb,YAAQ,UAAS,OAAT,EAAkB;;AAEtB,YAAI,QAAQ,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,SAAlC;;AAEA,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;;;;AAQA,iBAAS,OAAT,CAAiB,IAAjB,EAAuB;AACnB,gBAAI,gBAAgB,WAAW,cAAX,CAA0B,IAA1B,CAApB;gBACI,YAAY,WAAW,aAAX,CAAyB,IAAzB,CADhB;;AAGA,mBAAO,iBAAiB,cAAc,KAAd,KAAwB,GAAzC,IACH,SADG,IACU,UAAU,KAAV,KAAoB,GADrC;AAEH;;AAED,eAAO;;AAEH,4BAAgB,UAAS,IAAT,EAAe;AAC3B,oBAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,oBAAzB,EAA+C;AAC3C,wBAAI,wBAAwB,QAAQ,IAAR,CAA5B;wBACI,4BAA4B,QAAQ,KAAK,MAAb,CADhC;;AAGA,wBAAI,CAAC,qBAAD,IAA0B,CAAC,yBAA/B,EAA0D;AACtD,gCAAQ,MAAR,CAAe,IAAf,EAAqB,uDAArB;AACH,qBAFD,MAEO,IAAI,UAAU,QAAV,IAAsB,CAAC,yBAA3B,EAAsD;AACzD,gCAAQ,MAAR,CAAe,IAAf,EAAqB,8CAArB;AACH,qBAFM,MAEA,IAAI,UAAU,SAAV,IAAuB,CAAC,qBAA5B,EAAmD;AACtD,gCAAQ,MAAR,CAAe,IAAf,EAAqB,gEAArB;AACH;AACJ;AACJ;AAfE,SAAP;AAkBH;AArDY,CAAjB","file":"wrap-iife-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag when IIFE is not wrapped in parens\n * @author Ilya Volodin\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require parentheses around immediate `function` invocations\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"outside\", \"inside\", \"any\"]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var style = context.options[0] || \"outside\";\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Check if the node is wrapped in ()\n         * @param {ASTNode} node node to evaluate\n         * @returns {boolean} True if it is wrapped\n         * @private\n         */\n        function wrapped(node) {\n            var previousToken = sourceCode.getTokenBefore(node),\n                nextToken = sourceCode.getTokenAfter(node);\n\n            return previousToken && previousToken.value === \"(\" &&\n                nextToken && nextToken.value === \")\";\n        }\n\n        return {\n\n            CallExpression: function(node) {\n                if (node.callee.type === \"FunctionExpression\") {\n                    var callExpressionWrapped = wrapped(node),\n                        functionExpressionWrapped = wrapped(node.callee);\n\n                    if (!callExpressionWrapped && !functionExpressionWrapped) {\n                        context.report(node, \"Wrap an immediate function invocation in parentheses.\");\n                    } else if (style === \"inside\" && !functionExpressionWrapped) {\n                        context.report(node, \"Wrap only the function expression in parens.\");\n                    } else if (style === \"outside\" && !callExpressionWrapped) {\n                        context.report(node, \"Move the invocation into the parens that contain the function.\");\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]}