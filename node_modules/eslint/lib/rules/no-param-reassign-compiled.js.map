{"version":3,"sources":["no-param-reassign.js"],"names":[],"mappings":";;;;AAIA;;;;;;AAMA,IAAI,kBAAkB,4DAAtB;;AAEA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,4CADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,uBAAO,EAAC,MAAM,SAAP;AADC,aAFhB;AAKI,kCAAsB;AAL1B,SADI;AAPN,KADO;;AAmBb,YAAQ,UAAS,OAAT,EAAkB;AACtB,YAAI,QAAQ,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,QAAQ,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,KAA3B,CAAlC;;;;;;;AAOA,iBAAS,eAAT,CAAyB,SAAzB,EAAoC;AAChC,gBAAI,OAAO,UAAU,UAArB;AACA,gBAAI,SAAS,KAAK,MAAlB;;AAEA,mBAAO,UAAU,CAAC,gBAAgB,IAAhB,CAAqB,OAAO,IAA5B,CAAlB,EAAqD;AACjD,wBAAQ,OAAO,IAAf;;;AAGI,yBAAK,sBAAL;AACI,+BAAO,OAAO,IAAP,KAAgB,IAAvB;;;AAGJ,yBAAK,kBAAL;AACI,+BAAO,IAAP;;;AAGJ,yBAAK,iBAAL;AACI,4BAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,mCAAO,IAAP;AACH;AACD;;;AAGJ,yBAAK,gBAAL;AACI,4BAAI,OAAO,MAAP,KAAkB,IAAtB,EAA4B;AACxB,mCAAO,KAAP;AACH;AACD;;;AAGJ,yBAAK,kBAAL;AACI,4BAAI,OAAO,QAAP,KAAoB,IAAxB,EAA8B;AAC1B,mCAAO,KAAP;AACH;AACD;;AAEJ;AACI;AAhCR;;AAmCA,uBAAO,MAAP;AACA,yBAAS,KAAK,MAAd;AACH;;AAED,mBAAO,KAAP;AACH;;;;;;;;;AASD,iBAAS,cAAT,CAAwB,SAAxB,EAAmC,KAAnC,EAA0C,UAA1C,EAAsD;AAClD,gBAAI,aAAa,UAAU,UAA3B;;AAEA,gBAAI,cACA,CAAC,UAAU,IADX;;;;AAKC,sBAAU,CAAV,IAAe,WAAW,QAAQ,CAAnB,EAAsB,UAAtB,KAAqC,UALrD,CAAJ,EAME;AACE,oBAAI,UAAU,OAAV,EAAJ,EAAyB;AACrB,4BAAQ,MAAR,CACI,UADJ,EAEI,8CAFJ,EAGI,EAAC,MAAM,WAAW,IAAlB,EAHJ;AAIH,iBALD,MAKO,IAAI,SAAS,gBAAgB,SAAhB,CAAb,EAAyC;AAC5C,4BAAQ,MAAR,CACI,UADJ,EAEI,0DAFJ,EAGI,EAAC,MAAM,WAAW,IAAlB,EAHJ;AAIH;AACJ;AACJ;;;;;;;AAOD,iBAAS,aAAT,CAAuB,QAAvB,EAAiC;AAC7B,gBAAI,SAAS,IAAT,CAAc,CAAd,EAAiB,IAAjB,KAA0B,WAA9B,EAA2C;AACvC,yBAAS,UAAT,CAAoB,OAApB,CAA4B,cAA5B;AACH;AACJ;;;;;;;AAOD,iBAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC5B,oBAAQ,oBAAR,CAA6B,IAA7B,EAAmC,OAAnC,CAA2C,aAA3C;AACH;;AAED,eAAO;;;AAGH,wCAA4B,gBAHzB;AAIH,uCAA2B,gBAJxB;AAKH,4CAAgC;AAL7B,SAAP;AAQH;AArIY,CAAjB","file":"no-param-reassign-compiled.js","sourcesContent":["/**\n * @fileoverview Disallow reassignment of function parameters.\n * @author Nat Burns\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nvar stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/;\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow reassigning `function` parameters\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    props: {type: \"boolean\"}\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var props = context.options[0] && Boolean(context.options[0].props);\n\n        /**\n         * Checks whether or not the reference modifies properties of its variable.\n         * @param {Reference} reference - A reference to check.\n         * @returns {boolean} Whether or not the reference modifies properties of its variable.\n         */\n        function isModifyingProp(reference) {\n            var node = reference.identifier;\n            var parent = node.parent;\n\n            while (parent && !stopNodePattern.test(parent.type)) {\n                switch (parent.type) {\n\n                    // e.g. foo.a = 0;\n                    case \"AssignmentExpression\":\n                        return parent.left === node;\n\n                    // e.g. ++foo.a;\n                    case \"UpdateExpression\":\n                        return true;\n\n                    // e.g. delete foo.a;\n                    case \"UnaryExpression\":\n                        if (parent.operator === \"delete\") {\n                            return true;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache.get(foo.a).b = 0;\n                    case \"CallExpression\":\n                        if (parent.callee !== node) {\n                            return false;\n                        }\n                        break;\n\n                    // EXCLUDES: e.g. cache[foo.a] = 0;\n                    case \"MemberExpression\":\n                        if (parent.property === node) {\n                            return false;\n                        }\n                        break;\n\n                    default:\n                        break;\n                }\n\n                node = parent;\n                parent = node.parent;\n            }\n\n            return false;\n        }\n\n        /**\n         * Reports a reference if is non initializer and writable.\n         * @param {Reference} reference - A reference to check.\n         * @param {int} index - The index of the reference in the references.\n         * @param {Reference[]} references - The array that the reference belongs to.\n         * @returns {void}\n         */\n        function checkReference(reference, index, references) {\n            var identifier = reference.identifier;\n\n            if (identifier &&\n                !reference.init &&\n\n                // Destructuring assignments can have multiple default value,\n                // so possibly there are multiple writeable references for the same identifier.\n                (index === 0 || references[index - 1].identifier !== identifier)\n            ) {\n                if (reference.isWrite()) {\n                    context.report(\n                        identifier,\n                        \"Assignment to function parameter '{{name}}'.\",\n                        {name: identifier.name});\n                } else if (props && isModifyingProp(reference)) {\n                    context.report(\n                        identifier,\n                        \"Assignment to property of function parameter '{{name}}'.\",\n                        {name: identifier.name});\n                }\n            }\n        }\n\n        /**\n         * Finds and reports references that are non initializer and writable.\n         * @param {Variable} variable - A variable to check.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            if (variable.defs[0].type === \"Parameter\") {\n                variable.references.forEach(checkReference);\n            }\n        }\n\n        /**\n         * Checks parameters of a given function node.\n         * @param {ASTNode} node - A function node to check.\n         * @returns {void}\n         */\n        function checkForFunction(node) {\n            context.getDeclaredVariables(node).forEach(checkVariable);\n        }\n\n        return {\n\n            // `:exit` is needed for the `node.parent` property of identifier nodes.\n            \"FunctionDeclaration:exit\": checkForFunction,\n            \"FunctionExpression:exit\": checkForFunction,\n            \"ArrowFunctionExpression:exit\": checkForFunction\n        };\n\n    }\n};\n"]}