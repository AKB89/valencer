{"version":3,"sources":["yoda.js"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;AAWA,SAAS,oBAAT,CAA8B,QAA9B,EAAwC;AACpC,WAAQ,8BAAD,CAAgC,IAAhC,CAAqC,QAArC;AAAP;AACH;;;;;;;AAOD,SAAS,kBAAT,CAA4B,QAA5B,EAAsC;AAClC,WAAQ,aAAD,CAAe,IAAf,CAAoB,QAApB;AAAP;AACH;;;;;;;;AAQD,SAAS,mBAAT,CAA6B,QAA7B,EAAuC;AACnC,WAAO,CAAC,GAAD,EAAM,IAAN,EAAY,OAAZ,CAAoB,QAApB,KAAiC,CAAxC;AACH;;;;;;;;;AASD,SAAS,gBAAT,CAA0B,IAA1B,EAAgC;AAC5B,WAAQ,KAAK,IAAL,KAAc,iBAAd,IACJ,KAAK,QAAL,KAAkB,GADd,IAEJ,KAAK,MAFD,IAGJ,KAAK,QAAL,CAAc,IAAd,KAAuB,SAHnB,IAIJ,OAAO,KAAK,QAAL,CAAc,KAArB,KAA+B,QAJnC;AAKH;;;;;;;;;;;AAWD,SAAS,oBAAT,CAA8B,IAA9B,EAAoC;AAChC,QAAI,KAAK,IAAL,KAAc,SAAlB,EAA6B;AACzB,eAAO,IAAP;AACH;;AAED,QAAI,iBAAiB,IAAjB,CAAJ,EAA4B;AACxB,eAAO;AACH,kBAAM,SADH;AAEH,mBAAO,CAAC,KAAK,QAAL,CAAc,KAFnB;AAGH,iBAAK,MAAM,KAAK,QAAL,CAAc;AAHtB,SAAP;AAKH;;AAED,WAAO,IAAP;AACH;;;;;;;;;;;;AAYD,SAAS,IAAT,CAAc,CAAd,EAAiB,CAAjB,EAAoB;AAChB,QAAI,EAAE,IAAF,KAAW,EAAE,IAAjB,EAAuB;AACnB,eAAO,KAAP;AACH;;AAED,YAAQ,EAAE,IAAV;AACI,aAAK,YAAL;AACI,mBAAO,EAAE,IAAF,KAAW,EAAE,IAApB;;AAEJ,aAAK,SAAL;AACI,mBAAO,EAAE,KAAF,KAAY,EAAE,KAArB;;AAEJ,aAAK,kBAAL;;;;;AAKI,mBAAO,KAAK,EAAE,MAAP,EAAe,EAAE,MAAjB,KAA4B,KAAK,EAAE,QAAP,EAAiB,EAAE,QAAnB,CAAnC;;AAEJ,aAAK,gBAAL;AACI,mBAAO,IAAP;;AAEJ;AACI,mBAAO,KAAP;AAlBR;AAoBH;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,yCADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,CAAC,QAAD,EAAW,OAAX;AADV,SADI,EAIJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,6BAAa;AACT,0BAAM;AADG,iBADL;AAIR,8BAAc;AACV,0BAAM;AADI;AAJN,aAFhB;AAUI,kCAAsB;AAV1B,SAJI;AAPN,KADO;;AA2Bb,YAAQ,UAAS,OAAT,EAAkB;;;AAGtB,YAAI,SAAU,QAAQ,OAAR,CAAgB,CAAhB,MAAuB,QAArC;AACA,YAAI,cAAe,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,WAA5D;AACA,YAAI,eAAgB,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,YAA7D;;AAEA,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;;;;;;;;AAYA,iBAAS,WAAT,CAAqB,IAArB,EAA2B;AACvB,gBAAI,OAAO,KAAK,IAAhB;gBACI,QAAQ,KAAK,KADjB;;;;;;AAOA,qBAAS,aAAT,GAAyB;AACrB,oBAAI,WAAJ,EAAiB,YAAjB;;AAEA,uBAAQ,KAAK,QAAL,KAAkB,IAAlB,KACH,cAAc,qBAAqB,KAAK,IAA1B,CADX,MAEH,eAAe,qBAAqB,MAAM,KAA3B,CAFZ,KAGJ,YAAY,KAAZ,IAAqB,aAAa,KAH9B,IAIJ,KAAK,KAAK,KAAV,EAAiB,MAAM,IAAvB,CAJJ;AAKH;;;;;;AAMD,qBAAS,aAAT,GAAyB;AACrB,oBAAI,WAAJ,EAAiB,YAAjB;;AAEA,uBAAQ,KAAK,QAAL,KAAkB,IAAlB,KACH,cAAc,qBAAqB,KAAK,KAA1B,CADX,MAEH,eAAe,qBAAqB,MAAM,IAA3B,CAFZ,KAGJ,YAAY,KAAZ,IAAqB,aAAa,KAH9B,IAIJ,KAAK,KAAK,IAAV,EAAgB,MAAM,KAAtB,CAJJ;AAKH;;;;;;;;AAQD,qBAAS,cAAT,GAA0B;AACtB,oBAAI,WAAJ,EAAiB,UAAjB;;AAEA,uBAAQ,CAAC,cAAc,WAAW,cAAX,CAA0B,IAA1B,CAAf,KACJ,YAAY,KAAZ,KAAsB,GADlB,KAEH,aAAa,WAAW,aAAX,CAAyB,IAAzB,CAFV,KAGJ,WAAW,KAAX,KAAqB,GAHzB;AAIH;;AAED,mBAAQ,KAAK,IAAL,KAAc,mBAAd,IACJ,KAAK,IAAL,KAAc,kBADV,IAEJ,MAAM,IAAN,KAAe,kBAFX,IAGJ,oBAAoB,KAAK,QAAzB,CAHI,IAIJ,oBAAoB,MAAM,QAA1B,CAJI,KAKH,mBAAmB,eALhB,KAMJ,gBANJ;AAOH;;;;;;AAMD,eAAO;AACH,8BAAkB,SAAS,UAAS,IAAT,EAAe;;;AAGtC,oBACI,CAAC,KAAK,KAAL,CAAW,IAAX,KAAoB,SAApB,IAAiC,iBAAiB,KAAK,KAAtB,CAAlC,KACA,EAAE,KAAK,IAAL,CAAU,IAAV,KAAmB,SAAnB,IAAgC,iBAAiB,KAAK,IAAtB,CAAlC,CADA,IAEA,EAAE,CAAC,mBAAmB,KAAK,QAAxB,CAAD,IAAsC,YAAxC,CAFA,IAGA,qBAAqB,KAAK,QAA1B,CAHA,IAIA,EAAE,eAAe,YAAY,QAAQ,YAAR,GAAuB,GAAvB,EAAZ,CAAjB,CALJ,EAME;AACE,4BAAQ,MAAR,CAAe,IAAf,EAAqB,gDAAgD,KAAK,QAArD,GAAgE,GAArF;AACH;AAEJ,aAbiB,GAad,UAAS,IAAT,EAAe;;;AAGf,oBACI,CAAC,KAAK,IAAL,CAAU,IAAV,KAAmB,SAAnB,IAAgC,iBAAiB,KAAK,IAAtB,CAAjC,KACA,EAAE,KAAK,KAAL,CAAW,IAAX,KAAoB,SAApB,IAAiC,iBAAiB,KAAK,KAAtB,CAAnC,CADA,IAEA,EAAE,CAAC,mBAAmB,KAAK,QAAxB,CAAD,IAAsC,YAAxC,CAFA,IAGA,qBAAqB,KAAK,QAA1B,CAHA,IAIA,EAAE,eAAe,YAAY,QAAQ,YAAR,GAAuB,GAAvB,EAAZ,CAAjB,CALJ,EAME;AACE,4BAAQ,MAAR,CAAe,IAAf,EAAqB,iDAAiD,KAAK,QAAtD,GAAiE,GAAtF;AACH;AAEJ;AA3BE,SAAP;AA8BH;AAxIY,CAAjB","file":"yoda-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to require or disallow yoda comparisons\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//--------------------------------------------------------------------------\n// Helpers\n//--------------------------------------------------------------------------\n\n/**\n * Determines whether an operator is a comparison operator.\n * @param {String} operator The operator to check.\n * @returns {boolean} Whether or not it is a comparison operator.\n */\nfunction isComparisonOperator(operator) {\n    return (/^(==|===|!=|!==|<|>|<=|>=)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is an equality operator.\n * @param {String} operator The operator to check.\n * @returns {boolean} Whether or not it is an equality operator.\n */\nfunction isEqualityOperator(operator) {\n    return (/^(==|===)$/).test(operator);\n}\n\n/**\n * Determines whether an operator is one used in a range test.\n * Allowed operators are `<` and `<=`.\n * @param {String} operator The operator to check.\n * @returns {boolean} Whether the operator is used in range tests.\n */\nfunction isRangeTestOperator(operator) {\n    return [\"<\", \"<=\"].indexOf(operator) >= 0;\n}\n\n/**\n * Determines whether a non-Literal node is a negative number that should be\n * treated as if it were a single Literal node.\n * @param {ASTNode} node Node to test.\n * @returns {boolean} True if the node is a negative number that looks like a\n *                    real literal and should be treated as such.\n */\nfunction looksLikeLiteral(node) {\n    return (node.type === \"UnaryExpression\" &&\n        node.operator === \"-\" &&\n        node.prefix &&\n        node.argument.type === \"Literal\" &&\n        typeof node.argument.value === \"number\");\n}\n\n/**\n * Attempts to derive a Literal node from nodes that are treated like literals.\n * @param {ASTNode} node Node to normalize.\n * @returns {ASTNode} The original node if the node is already a Literal, or a\n *                    normalized Literal node with the negative number as the\n *                    value if the node represents a negative number literal,\n *                    otherwise null if the node cannot be converted to a\n *                    normalized literal.\n */\nfunction getNormalizedLiteral(node) {\n    if (node.type === \"Literal\") {\n        return node;\n    }\n\n    if (looksLikeLiteral(node)) {\n        return {\n            type: \"Literal\",\n            value: -node.argument.value,\n            raw: \"-\" + node.argument.value\n        };\n    }\n\n    return null;\n}\n\n/**\n * Checks whether two expressions reference the same value. For example:\n *     a = a\n *     a.b = a.b\n *     a[0] = a[0]\n *     a['b'] = a['b']\n * @param   {ASTNode} a Left side of the comparison.\n * @param   {ASTNode} b Right side of the comparison.\n * @returns {boolean}   True if both sides match and reference the same value.\n */\nfunction same(a, b) {\n    if (a.type !== b.type) {\n        return false;\n    }\n\n    switch (a.type) {\n        case \"Identifier\":\n            return a.name === b.name;\n\n        case \"Literal\":\n            return a.value === b.value;\n\n        case \"MemberExpression\":\n\n            // x[0] = x[0]\n            // x[y] = x[y]\n            // x.y = x.y\n            return same(a.object, b.object) && same(a.property, b.property);\n\n        case \"ThisExpression\":\n            return true;\n\n        default:\n            return false;\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require or disallow \\\"Yoda\\\" conditions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptRange: {\n                        type: \"boolean\"\n                    },\n                    onlyEquality: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        // Default to \"never\" (!always) if no option\n        var always = (context.options[0] === \"always\");\n        var exceptRange = (context.options[1] && context.options[1].exceptRange);\n        var onlyEquality = (context.options[1] && context.options[1].onlyEquality);\n\n        var sourceCode = context.getSourceCode();\n\n        /**\n         * Determines whether node represents a range test.\n         * A range test is a \"between\" test like `(0 <= x && x < 1)` or an \"outside\"\n         * test like `(x < 0 || 1 <= x)`. It must be wrapped in parentheses, and\n         * both operators must be `<` or `<=`. Finally, the literal on the left side\n         * must be less than or equal to the literal on the right side so that the\n         * test makes any sense.\n         * @param {ASTNode} node LogicalExpression node to test.\n         * @returns {Boolean} Whether node is a range test.\n         */\n        function isRangeTest(node) {\n            var left = node.left,\n                right = node.right;\n\n            /**\n             * Determines whether node is of the form `0 <= x && x < 1`.\n             * @returns {Boolean} Whether node is a \"between\" range test.\n             */\n            function isBetweenTest() {\n                var leftLiteral, rightLiteral;\n\n                return (node.operator === \"&&\" &&\n                    (leftLiteral = getNormalizedLiteral(left.left)) &&\n                    (rightLiteral = getNormalizedLiteral(right.right)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.right, right.left));\n            }\n\n            /**\n             * Determines whether node is of the form `x < 0 || 1 <= x`.\n             * @returns {Boolean} Whether node is an \"outside\" range test.\n             */\n            function isOutsideTest() {\n                var leftLiteral, rightLiteral;\n\n                return (node.operator === \"||\" &&\n                    (leftLiteral = getNormalizedLiteral(left.right)) &&\n                    (rightLiteral = getNormalizedLiteral(right.left)) &&\n                    leftLiteral.value <= rightLiteral.value &&\n                    same(left.left, right.right));\n            }\n\n            /**\n             * Determines whether node is wrapped in parentheses.\n             * @returns {Boolean} Whether node is preceded immediately by an open\n             *                    paren token and followed immediately by a close\n             *                    paren token.\n             */\n            function isParenWrapped() {\n                var tokenBefore, tokenAfter;\n\n                return ((tokenBefore = sourceCode.getTokenBefore(node)) &&\n                    tokenBefore.value === \"(\" &&\n                    (tokenAfter = sourceCode.getTokenAfter(node)) &&\n                    tokenAfter.value === \")\");\n            }\n\n            return (node.type === \"LogicalExpression\" &&\n                left.type === \"BinaryExpression\" &&\n                right.type === \"BinaryExpression\" &&\n                isRangeTestOperator(left.operator) &&\n                isRangeTestOperator(right.operator) &&\n                (isBetweenTest() || isOutsideTest()) &&\n                isParenWrapped());\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            BinaryExpression: always ? function(node) {\n\n                // Comparisons must always be yoda-style: if (\"blue\" === color)\n                if (\n                    (node.right.type === \"Literal\" || looksLikeLiteral(node.right)) &&\n                    !(node.left.type === \"Literal\" || looksLikeLiteral(node.left)) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report(node, \"Expected literal to be on the left side of \" + node.operator + \".\");\n                }\n\n            } : function(node) {\n\n                // Comparisons must never be yoda-style (default)\n                if (\n                    (node.left.type === \"Literal\" || looksLikeLiteral(node.left)) &&\n                    !(node.right.type === \"Literal\" || looksLikeLiteral(node.right)) &&\n                    !(!isEqualityOperator(node.operator) && onlyEquality) &&\n                    isComparisonOperator(node.operator) &&\n                    !(exceptRange && isRangeTest(context.getAncestors().pop()))\n                ) {\n                    context.report(node, \"Expected literal to be on the right side of \" + node.operator + \".\");\n                }\n\n            }\n        };\n\n    }\n};\n"]}