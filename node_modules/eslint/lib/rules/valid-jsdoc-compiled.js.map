{"version":3,"sources":["valid-jsdoc.js"],"names":[],"mappings":"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","file":"valid-jsdoc-compiled.js","sourcesContent":["/**\n * @fileoverview Validates JSDoc comments are syntactically correct\n * @author Nicholas C. Zakas\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar doctrine = require(\"doctrine\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce valid JSDoc comments\",\n            category: \"Possible Errors\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    prefer: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    preferType: {\n                        type: \"object\",\n                        additionalProperties: {\n                            type: \"string\"\n                        }\n                    },\n                    requireReturn: {\n                        type: \"boolean\"\n                    },\n                    requireParamDescription: {\n                        type: \"boolean\"\n                    },\n                    requireReturnDescription: {\n                        type: \"boolean\"\n                    },\n                    matchDescription: {\n                        type: \"string\"\n                    },\n                    requireReturnType: {\n                        type: \"boolean\"\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var options = context.options[0] || {},\n            prefer = options.prefer || {},\n            sourceCode = context.getSourceCode(),\n\n            // these both default to true, so you have to explicitly make them false\n            requireReturn = options.requireReturn !== false,\n            requireParamDescription = options.requireParamDescription !== false,\n            requireReturnDescription = options.requireReturnDescription !== false,\n            requireReturnType = options.requireReturnType !== false,\n            preferType = options.preferType || {},\n            checkPreferType = Object.keys(preferType).length !== 0;\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        // Using a stack to store if a function returns or not (handling nested functions)\n        var fns = [];\n\n        /**\n         * Check if node type is a Class\n         * @param {ASTNode} node node to check.\n         * @returns {boolean} True is its a class\n         * @private\n         */\n        function isTypeClass(node) {\n            return node.type === \"ClassExpression\" || node.type === \"ClassDeclaration\";\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack.\n         * @param {ASTNode} node A function node to check.\n         * @returns {void}\n         * @private\n         */\n        function startFunction(node) {\n            fns.push({\n                returnPresent: (node.type === \"ArrowFunctionExpression\" && node.body.type !== \"BlockStatement\") ||\n                    isTypeClass(node)\n            });\n        }\n\n        /**\n         * Indicate that return has been found in the current function.\n         * @param {ASTNode} node The return node.\n         * @returns {void}\n         * @private\n         */\n        function addReturn(node) {\n            var functionState = fns[fns.length - 1];\n\n            if (functionState && node.argument !== null) {\n                functionState.returnPresent = true;\n            }\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} tag JSDoc tag\n         * @returns {boolean} True if its of type void or undefined\n         * @private\n         */\n        function isValidReturnType(tag) {\n            return tag.type === null || tag.type.name === \"void\" || tag.type.type === \"UndefinedLiteral\";\n        }\n\n        /**\n         * Check if type should be validated based on some exceptions\n         * @param {Object} type JSDoc tag\n         * @returns {boolean} True if it can be validated\n         * @private\n         */\n        function canTypeBeValidated(type) {\n            return type !== \"UndefinedLiteral\" && // {undefined} as there is no name property available.\n                   type !== \"NullLiteral\" && // {null}\n                   type !== \"NullableLiteral\" && // {?}\n                   type !== \"FunctionType\" && // {function(a)}\n                   type !== \"AllLiteral\"; // {*}\n        }\n\n        /**\n         * Extract the current and expected type based on the input type object\n         * @param {Object} type JSDoc tag\n         * @returns {Object} current and expected type object\n         * @private\n         */\n        function getCurrentExpectedTypes(type) {\n            var currentType;\n            var expectedType;\n\n            if (type.name) {\n                currentType = type.name;\n            } else if (type.expression) {\n                currentType = type.expression.name;\n            }\n\n            expectedType = currentType && preferType[currentType];\n\n            return {\n                currentType: currentType,\n                expectedType: expectedType\n            };\n        }\n\n        /**\n         * Check if return tag type is void or undefined\n         * @param {Object} jsdocNode JSDoc node\n         * @param {Object} type JSDoc tag\n         * @returns {void}\n         * @private\n         */\n        function validateType(jsdocNode, type) {\n            if (!type || !canTypeBeValidated(type.type)) {\n                return;\n            }\n\n            var typesToCheck = [];\n            var elements = [];\n\n            switch (type.type) {\n                case \"TypeApplication\":  // {Array.<String>}\n                    elements = type.applications[0].type === \"UnionType\" ? type.applications[0].elements : type.applications;\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n                    break;\n                case \"RecordType\":  // {{20:String}}\n                    elements = type.fields;\n                    break;\n                case \"UnionType\":  // {String|number|Test}\n                case \"ArrayType\":  // {[String, number, Test]}\n                    elements = type.elements;\n                    break;\n                case \"FieldType\":  // Array.<{count: number, votes: number}>\n                    typesToCheck.push(getCurrentExpectedTypes(type.value));\n                    break;\n                default:\n                    typesToCheck.push(getCurrentExpectedTypes(type));\n            }\n\n            elements.forEach(validateType.bind(null, jsdocNode));\n\n            typesToCheck.forEach(function(typeToCheck) {\n                if (typeToCheck.expectedType &&\n                    typeToCheck.expectedType !== typeToCheck.currentType) {\n                    context.report({\n                        node: jsdocNode,\n                        message: \"Use '{{expectedType}}' instead of '{{currentType}}'.\",\n                        data: {\n                            currentType: typeToCheck.currentType,\n                            expectedType: typeToCheck.expectedType\n                        }\n                    });\n                }\n            });\n        }\n\n        /**\n         * Validate the JSDoc node and output warnings if anything is wrong.\n         * @param {ASTNode} node The AST node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkJSDoc(node) {\n            var jsdocNode = sourceCode.getJSDocComment(node),\n                functionData = fns.pop(),\n                hasReturns = false,\n                hasConstructor = false,\n                isInterface = false,\n                isOverride = false,\n                isAbstract = false,\n                params = Object.create(null),\n                jsdoc;\n\n            // make sure only to validate JSDoc comments\n            if (jsdocNode) {\n\n                try {\n                    jsdoc = doctrine.parse(jsdocNode.value, {\n                        strict: true,\n                        unwrap: true,\n                        sloppy: true\n                    });\n                } catch (ex) {\n\n                    if (/braces/i.test(ex.message)) {\n                        context.report(jsdocNode, \"JSDoc type missing brace.\");\n                    } else {\n                        context.report(jsdocNode, \"JSDoc syntax error.\");\n                    }\n\n                    return;\n                }\n\n                jsdoc.tags.forEach(function(tag) {\n\n                    switch (tag.title.toLowerCase()) {\n\n                        case \"param\":\n                        case \"arg\":\n                        case \"argument\":\n                            if (!tag.type) {\n                                context.report(jsdocNode, \"Missing JSDoc parameter type for '{{name}}'.\", { name: tag.name });\n                            }\n\n                            if (!tag.description && requireParamDescription) {\n                                context.report(jsdocNode, \"Missing JSDoc parameter description for '{{name}}'.\", { name: tag.name });\n                            }\n\n                            if (params[tag.name]) {\n                                context.report(jsdocNode, \"Duplicate JSDoc parameter '{{name}}'.\", { name: tag.name });\n                            } else if (tag.name.indexOf(\".\") === -1) {\n                                params[tag.name] = 1;\n                            }\n                            break;\n\n                        case \"return\":\n                        case \"returns\":\n                            hasReturns = true;\n\n                            if (!requireReturn && !functionData.returnPresent && (tag.type === null || !isValidReturnType(tag)) && !isAbstract) {\n                                context.report(jsdocNode, \"Unexpected @\" + tag.title + \" tag; function has no return statement.\");\n                            } else {\n                                if (requireReturnType && !tag.type) {\n                                    context.report(jsdocNode, \"Missing JSDoc return type.\");\n                                }\n\n                                if (!isValidReturnType(tag) && !tag.description && requireReturnDescription) {\n                                    context.report(jsdocNode, \"Missing JSDoc return description.\");\n                                }\n                            }\n\n                            break;\n\n                        case \"constructor\":\n                        case \"class\":\n                            hasConstructor = true;\n                            break;\n\n                        case \"override\":\n                        case \"inheritdoc\":\n                            isOverride = true;\n                            break;\n\n                        case \"abstract\":\n                        case \"virtual\":\n                            isAbstract = true;\n                            break;\n\n                        case \"interface\":\n                            isInterface = true;\n                            break;\n\n                        // no default\n                    }\n\n                    // check tag preferences\n                    if (prefer.hasOwnProperty(tag.title) && tag.title !== prefer[tag.title]) {\n                        context.report(jsdocNode, \"Use @{{name}} instead.\", { name: prefer[tag.title] });\n                    }\n\n                    // validate the types\n                    if (checkPreferType && tag.type) {\n                        validateType(jsdocNode, tag.type);\n                    }\n                });\n\n                // check for functions missing @returns\n                if (!isOverride && !hasReturns && !hasConstructor && !isInterface &&\n                    node.parent.kind !== \"get\" && node.parent.kind !== \"constructor\" &&\n                    node.parent.kind !== \"set\" && !isTypeClass(node)) {\n                    if (requireReturn || functionData.returnPresent) {\n                        context.report(jsdocNode, \"Missing JSDoc @\" + (prefer.returns || \"returns\") + \" for function.\");\n                    }\n                }\n\n                // check the parameters\n                var jsdocParams = Object.keys(params);\n\n                if (node.params) {\n                    node.params.forEach(function(param, i) {\n                        if (param.type === \"AssignmentPattern\") {\n                            param = param.left;\n                        }\n\n                        var name = param.name;\n\n                        // TODO(nzakas): Figure out logical things to do with destructured, default, rest params\n                        if (param.type === \"Identifier\") {\n                            if (jsdocParams[i] && (name !== jsdocParams[i])) {\n                                context.report(jsdocNode, \"Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.\", {\n                                    name: name,\n                                    jsdocName: jsdocParams[i]\n                                });\n                            } else if (!params[name] && !isOverride) {\n                                context.report(jsdocNode, \"Missing JSDoc for parameter '{{name}}'.\", {\n                                    name: name\n                                });\n                            }\n                        }\n                    });\n                }\n\n                if (options.matchDescription) {\n                    var regex = new RegExp(options.matchDescription);\n\n                    if (!regex.test(jsdoc.description)) {\n                        context.report(jsdocNode, \"JSDoc description does not satisfy the regex pattern.\");\n                    }\n                }\n\n            }\n\n        }\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n            ArrowFunctionExpression: startFunction,\n            FunctionExpression: startFunction,\n            FunctionDeclaration: startFunction,\n            ClassExpression: startFunction,\n            ClassDeclaration: startFunction,\n            \"ArrowFunctionExpression:exit\": checkJSDoc,\n            \"FunctionExpression:exit\": checkJSDoc,\n            \"FunctionDeclaration:exit\": checkJSDoc,\n            \"ClassExpression:exit\": checkJSDoc,\n            \"ClassDeclaration:exit\": checkJSDoc,\n            ReturnStatement: addReturn\n        };\n\n    }\n};\n"]}