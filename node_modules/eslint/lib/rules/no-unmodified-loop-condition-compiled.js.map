{"version":3,"sources":["no-unmodified-loop-condition.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,IAAI,MAAM,QAAQ,SAAR,CAAV;IACI,YAAY,QAAQ,mBAAR,CADhB;IAEI,WAAW,QAAQ,cAAR,CAFf;;;;;;AAQA,IAAI,UAAU,SAAS,KAAT,CAAe,IAAf,CAAoB,MAAM,SAAN,CAAgB,IAApC,CAAd;AACA,IAAI,mBAAmB,+EAAvB;AACA,IAAI,eAAe,kCAAnB;AACA,IAAI,gBAAgB,8CAApB;AACA,IAAI,eAAe,8CAAnB;AACA,IAAI,kBAAkB,sDAAtB;;;;;;;;;;;;;;;;;;;AAmBA,SAAS,gBAAT,CAA0B,SAA1B,EAAqC;AACjC,QAAI,UAAU,IAAd,EAAoB;AAChB,YAAI,MAAM,UAAU,QAAV,IAAsB,UAAU,QAAV,CAAmB,IAAnB,CAAwB,CAAxB,CAAhC;;AAEA,YAAI,CAAC,GAAD,IAAQ,IAAI,IAAJ,KAAa,UAArB,IAAmC,IAAI,MAAJ,CAAW,IAAX,KAAoB,KAA3D,EAAkE;AAC9D,mBAAO,KAAP;AACH;AACJ;AACD,WAAO,UAAU,OAAV,EAAP;AACH;;;;;;;;;AASD,SAAS,YAAT,CAAsB,SAAtB,EAAiC;AAC7B,WAAO,CAAC,UAAU,QAAlB;AACH;;;;;;;;;AASD,SAAS,+BAAT,CAAyC,SAAzC,EAAoD;AAChD,WAAO,EAAE,UAAU,QAAV,IAAsB,UAAU,KAAlC,CAAP;AACH;;;;;;;;;AASD,SAAS,SAAT,CAAmB,IAAnB,EAAyB,SAAzB,EAAoC;AAChC,QAAI,KAAK,KAAK,KAAd;AACA,QAAI,KAAK,UAAU,UAAV,CAAqB,KAA9B;;AAEA,WAAO,GAAG,CAAH,KAAS,GAAG,CAAH,CAAT,IAAkB,GAAG,CAAH,KAAS,GAAG,CAAH,CAAlC;AACH;;;;;;;;;;AAUD,IAAI,WAAW;AACX,oBAAgB,SADL;AAEX,sBAAkB,SAFP;AAGX,kBAAc,sBAAS,IAAT,EAAe,SAAf,EAA0B;AACpC,eACI,UAAU,IAAV,EAAgB,SAAhB,KACA,EAAE,KAAK,IAAL,IAAa,UAAU,KAAK,IAAf,EAAqB,SAArB,CAAf,CAFJ;AAIH;AARU,CAAf;;;;;;;;;AAkBA,SAAS,qBAAT,CAA+B,IAA/B,EAAqC;AACjC,QAAI,OAAO,KAAX;QACI,YAAY,IAAI,SAAJ,EADhB;;AAGA,cAAU,QAAV,CAAmB,IAAnB,EAAyB;AACrB,eAAO,eAAS,IAAT,EAAe;AAClB,gBAAI,gBAAgB,IAAhB,CAAqB,KAAK,IAA1B,CAAJ,EAAqC;AACjC,uBAAO,IAAP;AACA,qBAAK,KAAL;AACH,aAHD,MAGO,IAAI,aAAa,IAAb,CAAkB,KAAK,IAAvB,CAAJ,EAAkC;AACrC,qBAAK,IAAL;AACH;AACJ;AARoB,KAAzB;;AAWA,WAAO,IAAP;AACH;;;;;;;;AAQD,SAAS,eAAT,CAAyB,SAAzB,EAAoC;AAChC,QAAI,UAAU,IAAd,EAAoB;AAChB,eAAO,IAAP;AACH;;AAED,QAAI,QAAQ,IAAZ;AACA,QAAI,QAAQ,UAAU,UAAtB;AACA,QAAI,OAAO,MAAM,MAAjB;;AAEA,WAAO,IAAP,EAAa;AACT,YAAI,iBAAiB,IAAjB,CAAsB,KAAK,IAA3B,CAAJ,EAAsC;AAClC,gBAAI,aAAa,IAAb,CAAkB,KAAK,IAAvB,KAAgC,KAAK,IAAL,KAAc,KAAlD,EAAyD;;;AAGrD,uBAAO;AACH,+BAAW,SADR;AAEH,2BAAO,KAFJ;AAGH,8BAAU,SAAS,KAAK,IAAd,EAAoB,IAApB,CAAyB,IAAzB,EAA+B,IAA/B,CAHP;AAIH,8BAAU;AAJP,iBAAP;AAMH;;;AAGD;AACH;;;;;;AAMD,YAAI,cAAc,IAAd,CAAmB,KAAK,IAAxB,CAAJ,EAAmC;;;AAG/B,gBAAI,sBAAsB,IAAtB,CAAJ,EAAiC;AAC7B;AACH,aAFD,MAEO;AACH,wBAAQ,IAAR;AACH;AACJ;;AAED,gBAAQ,IAAR;AACA,eAAO,KAAK,MAAZ;AACH;;AAED,WAAO,IAAP;AACH;;;;;;;;;AASD,SAAS,6BAAT,CAAuC,SAAvC,EAAkD;AAC9C,QAAI,OAAO,UAAU,UAArB;;AAEA,WAAO,IAAP,EAAa;AACT,YAAI,KAAK,IAAL,KAAc,qBAAlB,EAAyC;AACrC,mBAAO,KAAK,EAAL,GAAU,IAAV,GAAiB,IAAxB;AACH;;AAED,eAAO,KAAK,MAAZ;AACH;;AAED,WAAO,IAAP;AACH;;;;;;;;;AASD,SAAS,kBAAT,CAA4B,UAA5B,EAAwC,SAAxC,EAAmD;AAC/C,QAAI,QAAJ,EAAc,OAAd;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,WAAW,MAA/B,EAAuC,EAAE,CAAzC,EAA4C;AACxC,YAAI,YAAY,WAAW,CAAX,CAAhB;;AAEA,aAAK,IAAI,IAAI,CAAb,EAAgB,CAAC,UAAU,QAAX,IAAuB,IAAI,UAAU,MAArD,EAA6D,EAAE,CAA/D,EAAkE;AAC9D,gBAAI,WAAW,UAAU,CAAV,CAAf;gBACI,MADJ;;;;;;;;AASA,qBAAS,UAAU,QAAV,CAAmB,QAAnB,KAAgC,QACrC,CAAC,WAAW,8BAA8B,QAA9B,CAAZ,MACC,UAAU,SAAS,iBAAT,CAA2B,SAAS,IAAT,CAAc,KAAzC,EAAgD,SAAS,EAAT,CAAY,IAA5D,CADX,KAEA,QAAQ,UAAR,CAAmB,IAAnB,CAAwB,UAAU,QAAlC,CAHqC,CAAzC;AAKA,sBAAU,QAAV,GAAqB,MAArB;AACH;AACJ;AACJ;;;;;;AAMD,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,qCADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,gBAAS,OAAT,EAAkB;AACtB,YAAI,WAAW,IAAf;;;;;;;;AAQA,iBAAS,MAAT,CAAgB,SAAhB,EAA2B;AACvB,gBAAI,OAAO,UAAU,SAAV,CAAoB,UAA/B;;AAEA,oBAAQ,MAAR,CAAe;AACX,sBAAM,IADK;AAEX,yBAAS,0CAFE;AAGX,sBAAM;AAHK,aAAf;AAKH;;;;;;;;;AASD,iBAAS,yBAAT,CAAmC,UAAnC,EAA+C;AAC3C,iBAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,WAAW,MAA/B,EAAuC,EAAE,CAAzC,EAA4C;AACxC,oBAAI,YAAY,WAAW,CAAX,CAAhB;;AAEA,oBAAI,UAAU,KAAd,EAAqB;AACjB,wBAAI,QAAQ,SAAS,GAAT,CAAa,UAAU,KAAvB,CAAZ;;AAEA,wBAAI,CAAC,KAAL,EAAY;AACR,gCAAQ,EAAR;AACA,iCAAS,GAAT,CAAa,UAAU,KAAvB,EAA8B,KAA9B;AACH;AACD,0BAAM,IAAN,CAAW,SAAX;AACH;AACJ;AACJ;;;;;;;;AAQD,iBAAS,sBAAT,CAAgC,UAAhC,EAA4C;AACxC,gBAAI,WAAW,KAAX,CAAiB,YAAjB,CAAJ,EAAoC;AAChC,2BAAW,OAAX,CAAmB,MAAnB;AACH;AACJ;;;;;;;;;AASD,iBAAS,eAAT,CAAyB,QAAzB,EAAmC;;;AAG/B,gBAAI,aAAa,SACZ,UADY,CAEZ,GAFY,CAER,eAFQ,EAGZ,MAHY,CAGL,OAHK,CAAjB;;AAKA,gBAAI,WAAW,MAAX,KAAsB,CAA1B,EAA6B;AACzB;AACH;;;AAGD,sCAA0B,UAA1B;;;AAGA,gBAAI,YAAY,SAAS,UAAT,CAAoB,MAApB,CAA2B,gBAA3B,CAAhB;;AAEA,gBAAI,UAAU,MAAV,GAAmB,CAAvB,EAA0B;AACtB,mCAAmB,UAAnB,EAA+B,SAA/B;AACH;;;;;;AAMD,uBACK,MADL,CACY,+BADZ,EAEK,OAFL,CAEa,MAFb;AAGH;;AAED,eAAO;AACH,4BAAgB,uBAAW;AACvB,oBAAI,QAAQ,CAAC,QAAQ,QAAR,EAAD,CAAZ;;AAEA,2BAAW,IAAI,GAAJ,EAAX;;AAEA,oBAAI,KAAJ;;AAEA,uBAAQ,QAAQ,MAAM,GAAN,EAAhB,EAA8B;AAC1B,4BAAQ,KAAR,EAAe,MAAM,WAArB;AACA,0BAAM,SAAN,CAAgB,OAAhB,CAAwB,eAAxB;AACH;;AAED,yBAAS,OAAT,CAAiB,sBAAjB;AACA,2BAAW,IAAX;AACH;AAfE,SAAP;AAiBH;AAxHY,CAAjB","file":"no-unmodified-loop-condition-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to disallow use of unmodified expressions in loop conditions\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar Map = require(\"es6-map\"),\n    Traverser = require(\"../util/traverser\"),\n    astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar pushAll = Function.apply.bind(Array.prototype.push);\nvar SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/;\nvar LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/;\nvar GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/;\nvar SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/;\nvar DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/;\n\n/**\n * @typedef {object} LoopConditionInfo\n * @property {escope.Reference} reference - The reference.\n * @property {ASTNode} group - BinaryExpression or ConditionalExpression nodes\n *      that the reference is belonging to.\n * @property {function} isInLoop - The predicate which checks a given reference\n *      is in this loop.\n * @property {boolean} modified - The flag that the reference is modified in\n *      this loop.\n */\n\n/**\n * Checks whether or not a given reference is a write reference.\n *\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is a write reference.\n */\nfunction isWriteReference(reference) {\n    if (reference.init) {\n        var def = reference.resolved && reference.resolved.defs[0];\n\n        if (!def || def.type !== \"Variable\" || def.parent.kind !== \"var\") {\n            return false;\n        }\n    }\n    return reference.isWrite();\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodified(condition) {\n    return !condition.modified;\n}\n\n/**\n * Checks whether or not a given loop condition info does not have the modified\n * flag and does not have the group this condition belongs to.\n *\n * @param {LoopConditionInfo} condition - A loop condition info to check.\n * @returns {boolean} `true` if the loop condition info is \"unmodified\".\n */\nfunction isUnmodifiedAndNotBelongToGroup(condition) {\n    return !(condition.modified || condition.group);\n}\n\n/**\n * Checks whether or not a given reference is inside of a given node.\n *\n * @param {ASTNode} node - A node to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the node.\n */\nfunction isInRange(node, reference) {\n    var or = node.range;\n    var ir = reference.identifier.range;\n\n    return or[0] <= ir[0] && ir[1] <= or[1];\n}\n\n/**\n * Checks whether or not a given reference is inside of a loop node's condition.\n *\n * @param {ASTNode} node - A node to check.\n * @param {escope.Reference} reference - A reference to check.\n * @returns {boolean} `true` if the reference is inside of the loop node's\n *      condition.\n */\nvar isInLoop = {\n    WhileStatement: isInRange,\n    DoWhileStatement: isInRange,\n    ForStatement: function(node, reference) {\n        return (\n            isInRange(node, reference) &&\n            !(node.init && isInRange(node.init, reference))\n        );\n    }\n};\n\n/**\n * Checks whether or not a given group node has any dynamic elements.\n *\n * @param {ASTNode} root - A node to check.\n *      This node is one of BinaryExpression or ConditionalExpression.\n * @returns {boolean} `true` if the node is dynamic.\n */\nfunction hasDynamicExpressions(root) {\n    var retv = false,\n        traverser = new Traverser();\n\n    traverser.traverse(root, {\n        enter: function(node) {\n            if (DYNAMIC_PATTERN.test(node.type)) {\n                retv = true;\n                this.break();\n            } else if (SKIP_PATTERN.test(node.type)) {\n                this.skip();\n            }\n        }\n    });\n\n    return retv;\n}\n\n/**\n * Creates the loop condition information from a given reference.\n *\n * @param {escope.Reference} reference - A reference to create.\n * @returns {LoopConditionInfo|null} Created loop condition info, or null.\n */\nfunction toLoopCondition(reference) {\n    if (reference.init) {\n        return null;\n    }\n\n    var group = null;\n    var child = reference.identifier;\n    var node = child.parent;\n\n    while (node) {\n        if (SENTINEL_PATTERN.test(node.type)) {\n            if (LOOP_PATTERN.test(node.type) && node.test === child) {\n\n                // This reference is inside of a loop condition.\n                return {\n                    reference: reference,\n                    group: group,\n                    isInLoop: isInLoop[node.type].bind(null, node),\n                    modified: false\n                };\n            }\n\n            // This reference is outside of a loop condition.\n            break;\n        }\n\n        /*\n         * If it's inside of a group, OK if either operand is modified.\n         * So stores the group this reference belongs to.\n         */\n        if (GROUP_PATTERN.test(node.type)) {\n\n            // If this expression is dynamic, no need to check.\n            if (hasDynamicExpressions(node)) {\n                break;\n            } else {\n                group = node;\n            }\n        }\n\n        child = node;\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Gets the function which encloses a given reference.\n * This supports only FunctionDeclaration.\n *\n * @param {escope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} The function node or null.\n */\nfunction getEncloseFunctionDeclaration(reference) {\n    var node = reference.identifier;\n\n    while (node) {\n        if (node.type === \"FunctionDeclaration\") {\n            return node.id ? node : null;\n        }\n\n        node = node.parent;\n    }\n\n    return null;\n}\n\n/**\n * Updates the \"modified\" flags of given loop conditions with given modifiers.\n *\n * @param {LoopConditionInfo[]} conditions - The loop conditions to be updated.\n * @param {escope.Reference[]} modifiers - The references to update.\n * @returns {void}\n */\nfunction updateModifiedFlag(conditions, modifiers) {\n    var funcNode, funcVar;\n\n    for (var i = 0; i < conditions.length; ++i) {\n        var condition = conditions[i];\n\n        for (var j = 0; !condition.modified && j < modifiers.length; ++j) {\n            var modifier = modifiers[j],\n                inLoop;\n\n            /*\n             * Besides checking for the condition being in the loop, we want to\n             * check the function that this modifier is belonging to is called\n             * in the loop.\n             * FIXME: This should probably be extracted to a function.\n             */\n            inLoop = condition.isInLoop(modifier) || Boolean(\n                (funcNode = getEncloseFunctionDeclaration(modifier)) &&\n                (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) &&\n                funcVar.references.some(condition.isInLoop)\n            );\n            condition.modified = inLoop;\n        }\n    }\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow unmodified loop conditions\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n        var groupMap = null;\n\n        /**\n         * Reports a given condition info.\n         *\n         * @param {LoopConditionInfo} condition - A loop condition info to report.\n         * @returns {void}\n         */\n        function report(condition) {\n            var node = condition.reference.identifier;\n\n            context.report({\n                node: node,\n                message: \"'{{name}}' is not modified in this loop.\",\n                data: node\n            });\n        }\n\n        /**\n         * Registers given conditions to the group the condition belongs to.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to\n         *      register.\n         * @returns {void}\n         */\n        function registerConditionsToGroup(conditions) {\n            for (var i = 0; i < conditions.length; ++i) {\n                var condition = conditions[i];\n\n                if (condition.group) {\n                    var group = groupMap.get(condition.group);\n\n                    if (!group) {\n                        group = [];\n                        groupMap.set(condition.group, group);\n                    }\n                    group.push(condition);\n                }\n            }\n        }\n\n        /**\n         * Reports references which are inside of unmodified groups.\n         *\n         * @param {LoopConditionInfo[]} conditions - A loop condition info to report.\n         * @returns {void}\n         */\n        function checkConditionsInGroup(conditions) {\n            if (conditions.every(isUnmodified)) {\n                conditions.forEach(report);\n            }\n        }\n\n        /**\n         * Finds unmodified references which are inside of a loop condition.\n         * Then reports the references which are outside of groups.\n         *\n         * @param {escope.Variable} variable - A variable to report.\n         * @returns {void}\n         */\n        function checkReferences(variable) {\n\n            // Gets references that exist in loop conditions.\n            var conditions = variable\n                .references\n                .map(toLoopCondition)\n                .filter(Boolean);\n\n            if (conditions.length === 0) {\n                return;\n            }\n\n            // Registers the conditions to belonging groups.\n            registerConditionsToGroup(conditions);\n\n            // Check the conditions are modified.\n            var modifiers = variable.references.filter(isWriteReference);\n\n            if (modifiers.length > 0) {\n                updateModifiedFlag(conditions, modifiers);\n            }\n\n            /*\n             * Reports the conditions which are not belonging to groups.\n             * Others will be reported after all variables are done.\n             */\n            conditions\n                .filter(isUnmodifiedAndNotBelongToGroup)\n                .forEach(report);\n        }\n\n        return {\n            \"Program:exit\": function() {\n                var queue = [context.getScope()];\n\n                groupMap = new Map();\n\n                var scope;\n\n                while ((scope = queue.pop())) {\n                    pushAll(queue, scope.childScopes);\n                    scope.variables.forEach(checkReferences);\n                }\n\n                groupMap.forEach(checkConditionsInGroup);\n                groupMap = null;\n            }\n        };\n    }\n};\n"]}