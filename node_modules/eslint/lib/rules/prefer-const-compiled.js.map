{"version":3,"sources":["prefer-const.js"],"names":[],"mappings":"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","file":"prefer-const-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to suggest using of const declaration for variables that are never reassigned after declared.\n * @author Toru Nagashima\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar Map = require(\"es6-map\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\nvar PATTERN_TYPE = /^(?:.+?Pattern|RestElement|Property)$/;\nvar DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/;\nvar DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/;\n\n/**\n * Adds multiple items to the tail of an array.\n *\n * @param {any[]} array - A destination to add.\n * @param {any[]} values - Items to be added.\n * @returns {void}\n */\nvar pushAll = Function.apply.bind(Array.prototype.push);\n\n/**\n * Checks whether a given node is located at `ForStatement.init` or not.\n *\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is located at `ForStatement.init`.\n */\nfunction isInitOfForStatement(node) {\n    return node.parent.type === \"ForStatement\" && node.parent.init === node;\n}\n\n/**\n * Checks whether a given Identifier node becomes a VariableDeclaration or not.\n *\n * @param {ASTNode} identifier - An Identifier node to check.\n * @returns {boolean} `true` if the node can become a VariableDeclaration.\n */\nfunction canBecomeVariableDeclaration(identifier) {\n    var node = identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    return (\n        node.type === \"VariableDeclarator\" ||\n        (\n            node.type === \"AssignmentExpression\" &&\n            node.parent.type === \"ExpressionStatement\" &&\n            DECLARATION_HOST_TYPE.test(node.parent.parent.type)\n        )\n    );\n}\n\n/**\n * Gets an identifier node of a given variable.\n *\n * If the initialization exists or one or more reading references exist before\n * the first assignment, the identifier node is the node of the declaration.\n * Otherwise, the identifier node is the node of the first assignment.\n *\n * If the variable should not change to const, this function returns null.\n * - If the variable is reassigned.\n * - If the variable is never initialized and assigned.\n * - If the variable is initialized in a different scope from the declaration.\n * - If the unique assignment of the variable cannot change to a declaration.\n *\n * @param {escope.Variable} variable - A variable to get.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {ASTNode|null}\n *      An Identifier node if the variable should change to const.\n *      Otherwise, null.\n */\nfunction getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {\n    if (variable.eslintUsed) {\n        return null;\n    }\n\n    // Finds the unique WriteReference.\n    var writer = null;\n    var isReadBeforeInit = false;\n    var references = variable.references;\n\n    for (var i = 0; i < references.length; ++i) {\n        var reference = references[i];\n\n        if (reference.isWrite()) {\n            var isReassigned = (\n                writer !== null &&\n                writer.identifier !== reference.identifier\n            );\n\n            if (isReassigned) {\n                return null;\n            }\n            writer = reference;\n\n        } else if (reference.isRead() && writer === null) {\n            if (ignoreReadBeforeAssign) {\n                return null;\n            }\n            isReadBeforeInit = true;\n        }\n    }\n\n    // If the assignment is from a different scope, ignore it.\n    // If the assignment cannot change to a declaration, ignore it.\n    var shouldBeConst = (\n        writer !== null &&\n        writer.from === variable.scope &&\n        canBecomeVariableDeclaration(writer.identifier)\n    );\n\n    if (!shouldBeConst) {\n        return null;\n    }\n    if (isReadBeforeInit) {\n        return variable.defs[0].name;\n    }\n    return writer.identifier;\n}\n\n/**\n * Gets the VariableDeclarator/AssignmentExpression node that a given reference\n * belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {escope.Reference} reference - A reference to get.\n * @returns {ASTNode|null} A VariableDeclarator/AssignmentExpression node or\n *      null.\n */\nfunction getDestructuringHost(reference) {\n    if (!reference.isWrite()) {\n        return null;\n    }\n    var node = reference.identifier.parent;\n\n    while (PATTERN_TYPE.test(node.type)) {\n        node = node.parent;\n    }\n\n    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {\n        return null;\n    }\n    return node;\n}\n\n/**\n * Groups by the VariableDeclarator/AssignmentExpression node that each\n * reference of given variables belongs to.\n * This is used to detect a mix of reassigned and never reassigned in a\n * destructuring.\n *\n * @param {escope.Variable[]} variables - Variables to group by destructuring.\n * @param {boolean} ignoreReadBeforeAssign -\n *      The value of `ignoreReadBeforeAssign` option.\n * @returns {Map<ASTNode, ASTNode[]>} Grouped identifier nodes.\n */\nfunction groupByDestructuring(variables, ignoreReadBeforeAssign) {\n    var identifierMap = new Map();\n\n    for (var i = 0; i < variables.length; ++i) {\n        var variable = variables[i];\n        var references = variable.references;\n        var identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n        var prevId = null;\n\n        for (var j = 0; j < references.length; ++j) {\n            var reference = references[j];\n            var id = reference.identifier;\n\n            // Avoid counting a reference twice or more for default values of\n            // destructuring.\n            if (id === prevId) {\n                continue;\n            }\n            prevId = id;\n\n            // Add the identifier node into the destructuring group.\n            var group = getDestructuringHost(reference);\n\n            if (group) {\n                if (identifierMap.has(group)) {\n                    identifierMap.get(group).push(identifier);\n                } else {\n                    identifierMap.set(group, [identifier]);\n                }\n            }\n        }\n    }\n\n    return identifierMap;\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"require `const` declarations for variables that are never reassigned after declared\",\n            category: \"ECMAScript 6\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    destructuring: {enum: [\"any\", \"all\"]},\n                    ignoreReadBeforeAssign: {type: \"boolean\"}\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n        var options = context.options[0] || {};\n        var checkingMixedDestructuring = options.destructuring !== \"all\";\n        var ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;\n        var variables = null;\n\n        /**\n         * Reports a given Identifier node.\n         *\n         * @param {ASTNode} node - An Identifier node to report.\n         * @returns {void}\n         */\n        function report(node) {\n            context.report({\n                node: node,\n                message: \"'{{name}}' is never reassigned, use 'const' instead.\",\n                data: node\n            });\n        }\n\n        /**\n         * Reports a given variable if the variable should be declared as const.\n         *\n         * @param {escope.Variable} variable - A variable to report.\n         * @returns {void}\n         */\n        function checkVariable(variable) {\n            var node = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);\n\n            if (node) {\n                report(node);\n            }\n        }\n\n        /**\n         * Reports given identifier nodes if all of the nodes should be declared\n         * as const.\n         *\n         * The argument 'nodes' is an array of Identifier nodes.\n         * This node is the result of 'getIdentifierIfShouldBeConst()', so it's\n         * nullable. In simple declaration or assignment cases, the length of\n         * the array is 1. In destructuring cases, the length of the array can\n         * be 2 or more.\n         *\n         * @param {(escope.Reference|null)[]} nodes -\n         *      References which are grouped by destructuring to report.\n         * @returns {void}\n         */\n        function checkGroup(nodes) {\n            if (nodes.every(Boolean)) {\n                nodes.forEach(report);\n            }\n        }\n\n        return {\n            Program: function() {\n                variables = [];\n            },\n\n            \"Program:exit\": function() {\n                if (checkingMixedDestructuring) {\n                    variables.forEach(checkVariable);\n                } else {\n                    groupByDestructuring(variables, ignoreReadBeforeAssign)\n                        .forEach(checkGroup);\n                }\n\n                variables = null;\n            },\n\n            VariableDeclaration: function(node) {\n                if (node.kind === \"let\" && !isInitOfForStatement(node)) {\n                    pushAll(variables, context.getDeclaredVariables(node));\n                }\n            }\n        };\n    }\n};\n"]}