{"version":3,"sources":["spaced-comment.js"],"names":[],"mappings":"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","file":"spaced-comment-compiled.js","sourcesContent":["/**\n * @fileoverview Source code for spaced-comments rule\n * @author Gyandeep Singh\n */\n\"use strict\";\n\nvar lodash = require(\"lodash\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Escapes the control characters of a given string.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escape(s) {\n    var isOneChar = s.length === 1;\n\n    s = lodash.escapeRegExp(s);\n    return isOneChar ? s : \"(?:\" + s + \")\";\n}\n\n/**\n * Escapes the control characters of a given string.\n * And adds a repeat flag.\n * @param {string} s - A string to escape.\n * @returns {string} An escaped string.\n */\nfunction escapeAndRepeat(s) {\n    return escape(s) + \"+\";\n}\n\n/**\n * Parses `markers` option.\n * If markers don't include `\"*\"`, this adds `\"*\"` to allow JSDoc comments.\n * @param {string[]} [markers] - A marker list.\n * @returns {string[]} A marker list.\n */\nfunction parseMarkersOption(markers) {\n    markers = markers ? markers.slice(0) : [];\n\n    // `*` is a marker for JSDoc comments.\n    if (markers.indexOf(\"*\") === -1) {\n        markers.push(\"*\");\n    }\n\n    return markers;\n}\n\n/**\n * Creates RegExp object for `always` mode.\n * Generated pattern is below:\n *\n * 1. First, a marker or nothing.\n * 2. Next, a space or an exception pattern sequence.\n *\n * @param {string[]} markers - A marker list.\n * @param {string[]} exceptions - A exception pattern list.\n * @returns {RegExp} A RegExp object for `always` mode.\n */\nfunction createAlwaysStylePattern(markers, exceptions) {\n    var pattern = \"^\";\n\n    /*\n     * A marker or nothing.\n     * [\"*\"]            ==> \"\\*?\"\n     * [\"*\", \"!\"]       ==> \"(?:\\*|!)?\"\n     * [\"*\", \"/\", \"!<\"] ==> \"(?:\\*|\\/|(?:!<))?\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5C*%7C%5C%2F%7C(%3F%3A!%3C))%3F\n     */\n    if (markers.length === 1) {\n\n        // the marker.\n        pattern += escape(markers[0]);\n    } else {\n\n        // one of markers.\n        pattern += \"(?:\";\n        pattern += markers.map(escape).join(\"|\");\n        pattern += \")\";\n    }\n\n    pattern += \"?\"; // or nothing.\n\n    /*\n     * A space or an exception pattern sequence.\n     * []                 ==> \"\\s\"\n     * [\"-\"]              ==> \"(?:\\s|\\-+$)\"\n     * [\"-\", \"=\"]         ==> \"(?:\\s|(?:\\-+|=+)$)\"\n     * [\"-\", \"=\", \"--==\"] ==> \"(?:\\s|(?:\\-+|=+|(?:\\-\\-==)+)$)\" ==> https://jex.im/regulex/#!embed=false&flags=&re=(%3F%3A%5Cs%7C(%3F%3A%5C-%2B%7C%3D%2B%7C(%3F%3A%5C-%5C-%3D%3D)%2B)%24)\n     */\n    if (exceptions.length === 0) {\n\n        // a space.\n        pattern += \"\\\\s\";\n    } else {\n\n        // a space or...\n        pattern += \"(?:\\\\s|\";\n\n        if (exceptions.length === 1) {\n\n            // a sequence of the exception pattern.\n            pattern += escapeAndRepeat(exceptions[0]);\n        } else {\n\n            // a sequence of one of exception patterns.\n            pattern += \"(?:\";\n            pattern += exceptions.map(escapeAndRepeat).join(\"|\");\n            pattern += \")\";\n        }\n\n        pattern += \"(?:$|[\\n\\r]))\"; // the sequence continues until the end.\n    }\n\n    return new RegExp(pattern);\n}\n\n/**\n * Creates RegExp object for `never` mode.\n * Generated pattern is below:\n *\n * 1. First, a marker or nothing (captured).\n * 2. Next, a space or a tab.\n *\n * @param {string[]} markers - A marker list.\n * @returns {RegExp} A RegExp object for `never` mode.\n */\nfunction createNeverStylePattern(markers) {\n    var pattern = \"^(\" + markers.map(escape).join(\"|\") + \")?[ \\t]+\";\n\n    return new RegExp(pattern);\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce consistent spacing after the `//` or `/*` in a comment\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        fixable: \"whitespace\",\n\n        schema: [\n            {\n                enum: [\"always\", \"never\"]\n            },\n            {\n                type: \"object\",\n                properties: {\n                    exceptions: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    markers: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    line: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    },\n                    block: {\n                        type: \"object\",\n                        properties: {\n                            exceptions: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            },\n                            markers: {\n                                type: \"array\",\n                                items: {\n                                    type: \"string\"\n                                }\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        // Unless the first option is never, require a space\n        var requireSpace = context.options[0] !== \"never\";\n\n        /*\n         * Parse the second options.\n         * If markers don't include `\"*\"`, it's added automatically for JSDoc\n         * comments.\n         */\n        var config = context.options[1] || {};\n        var styleRules = [\"block\", \"line\"].reduce(function(rule, type) {\n            var markers = parseMarkersOption(config[type] && config[type].markers || config.markers);\n            var exceptions = config[type] && config[type].exceptions || config.exceptions || [];\n\n            // Create RegExp object for valid patterns.\n            rule[type] = {\n                regex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),\n                hasExceptions: exceptions.length > 0,\n                markers: new RegExp(\"^(\" + markers.map(escape).join(\"|\") + \")\")\n            };\n\n            return rule;\n        }, {});\n\n        /**\n         * Reports a spacing error with an appropriate message.\n         * @param {ASTNode} node - A comment node to check.\n         * @param {string} message - An error message to report\n         * @param {Array} match - An array of match results for markers.\n         * @returns {void}\n         */\n        function report(node, message, match) {\n            var type = node.type.toLowerCase(),\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            context.report({\n                node: node,\n                fix: function(fixer) {\n                    var start = node.range[0],\n                        end = start + 2;\n\n                    if (requireSpace) {\n                        if (match) {\n                            end += match[0].length;\n                        }\n                        return fixer.insertTextAfterRange([start, end], \" \");\n                    } else {\n                        end += match[0].length;\n                        return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : \"\"));\n                    }\n                },\n                message: message\n            });\n        }\n\n        /**\n         * Reports a given comment if it's invalid.\n         * @param {ASTNode} node - a comment node to check.\n         * @returns {void}\n         */\n        function checkCommentForSpace(node) {\n            var type = node.type.toLowerCase(),\n                rule = styleRules[type],\n                commentIdentifier = type === \"block\" ? \"/*\" : \"//\";\n\n            // Ignores empty comments.\n            if (node.value.length === 0) {\n                return;\n            }\n\n            // Checks.\n            if (requireSpace) {\n                if (!rule.regex.test(node.value)) {\n                    var hasMarker = rule.markers.exec(node.value);\n                    var marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;\n\n                    if (rule.hasExceptions) {\n                        report(node, \"Expected exception block, space or tab after '\" + marker + \"' in comment.\", hasMarker);\n                    } else {\n                        report(node, \"Expected space or tab after '\" + marker + \"' in comment.\", hasMarker);\n                    }\n                }\n            } else {\n                var matched = rule.regex.exec(node.value);\n\n                if (matched) {\n                    if (!matched[1]) {\n                        report(node, \"Unexpected space or tab after '\" + commentIdentifier + \"' in comment.\", matched);\n                    } else {\n                        report(node, \"Unexpected space or tab after marker (\" + matched[1] + \") in comment.\", matched);\n                    }\n                }\n            }\n        }\n\n        return {\n\n            LineComment: checkCommentForSpace,\n            BlockComment: checkCommentForSpace\n\n        };\n    }\n};\n"]}