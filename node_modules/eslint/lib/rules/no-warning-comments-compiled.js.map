{"version":3,"sources":["no-warning-comments.js"],"names":[],"mappings":";;;;;AAKA;;AAEA,IAAI,WAAW,QAAQ,cAAR,CAAf;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,8CADX;AAEF,sBAAU,gBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,uBAAO;AACH,0BAAM,OADH;AAEH,2BAAO;AACH,8BAAM;AADH;AAFJ,iBADC;AAOR,0BAAU;AACN,0BAAM,CAAC,OAAD,EAAU,UAAV;AADA;AAPF,aAFhB;AAaI,kCAAsB;AAb1B,SADI;AAPN,KADO;;AA2Bb,YAAQ,gBAAS,OAAT,EAAkB;;AAEtB,YAAI,gBAAgB,QAAQ,OAAR,CAAgB,CAAhB,KAAsB,EAA1C;YACI,eAAe,cAAc,KAAd,IAAuB,CAAC,MAAD,EAAS,OAAT,EAAkB,KAAlB,CAD1C;YAEI,WAAW,cAAc,QAAd,IAA0B,OAFzC;YAGI,kBAAkB,yBAHtB;YAII,cAJJ;;;;;;;;;;AAcA,iBAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3B,gBAAI,UAAU,KAAK,OAAL,CAAa,0BAAb,EAAyC,MAAzC,CAAd;gBACI,MADJ;gBAEI,MAFJ;;;;;;;;;;;;AAcA,qBAAS,MAAM,IAAN,CAAW,IAAX,IAAmB,KAAnB,GAA2B,EAApC;;AAEA,gBAAI,aAAa,OAAjB,EAA0B;;;;;;AAMtB,yBAAS,OAAT;AACH,aAPD,MAOO,IAAI,MAAM,IAAN,CAAW,IAAX,CAAJ,EAAsB;AACzB,yBAAS,KAAT;AACH,aAFM,MAEA;AACH,yBAAS,EAAT;AACH;;AAED,mBAAO,IAAI,MAAJ,CAAW,SAAS,OAAT,GAAmB,MAA9B,EAAsC,GAAtC,CAAP;AACH;;;;;;;AAOD,iBAAS,0BAAT,CAAoC,OAApC,EAA6C;AACzC,gBAAI,UAAU,EAAd;;AAEA,2BAAe,OAAf,CAAuB,UAAS,KAAT,EAAgB,KAAhB,EAAuB;AAC1C,oBAAI,MAAM,IAAN,CAAW,OAAX,CAAJ,EAAyB;AACrB,4BAAQ,IAAR,CAAa,aAAa,KAAb,CAAb;AACH;AACJ,aAJD;;AAMA,mBAAO,OAAP;AACH;;;;;;;AAOD,iBAAS,YAAT,CAAsB,IAAtB,EAA4B;AACxB,gBAAI,SAAS,kBAAT,CAA4B,IAA5B,KAAqC,gBAAgB,IAAhB,CAAqB,KAAK,KAA1B,CAAzC,EAA2E;AACvE;AACH;;AAED,gBAAI,UAAU,2BAA2B,KAAK,KAAhC,CAAd;;AAEA,oBAAQ,OAAR,CAAgB,UAAS,WAAT,EAAsB;AAClC,wBAAQ,MAAR,CAAe,IAAf,EAAqB,iBAAiB,WAAjB,GAA+B,YAApD;AACH,aAFD;AAGH;;AAED,yBAAiB,aAAa,GAAb,CAAiB,eAAjB,CAAjB;AACA,eAAO;AACH,0BAAc,YADX;AAEH,yBAAa;AAFV,SAAP;AAIH;AAnHY,CAAjB","file":"no-warning-comments-compiled.js","sourcesContent":["/**\n * @fileoverview Rule that warns about used warning comments\n * @author Alexander Schmidt <https://github.com/lxanders>\n */\n\n\"use strict\";\n\nvar astUtils = require(\"../ast-utils\");\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow specified warning terms in comments\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    terms: {\n                        type: \"array\",\n                        items: {\n                            type: \"string\"\n                        }\n                    },\n                    location: {\n                        enum: [\"start\", \"anywhere\"]\n                    }\n                },\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        var configuration = context.options[0] || {},\n            warningTerms = configuration.terms || [\"todo\", \"fixme\", \"xxx\"],\n            location = configuration.location || \"start\",\n            selfConfigRegEx = /\\bno-warning-comments\\b/,\n            warningRegExps;\n\n        /**\n         * Convert a warning term into a RegExp which will match a comment containing that whole word in the specified\n         * location (\"start\" or \"anywhere\"). If the term starts or ends with non word characters, then the match will not\n         * require word boundaries on that side.\n         *\n         * @param {String} term A term to convert to a RegExp\n         * @returns {RegExp} The term converted to a RegExp\n         */\n        function convertToRegExp(term) {\n            var escaped = term.replace(/[-\\/\\\\$\\^*+?.()|\\[\\]{}]/g, \"\\\\$&\"),\n                suffix,\n                prefix;\n\n            /*\n             * If the term ends in a word character (a-z0-9_), ensure a word\n             * boundary at the end, so that substrings do not get falsely\n             * matched. eg \"todo\" in a string such as \"mastodon\".\n             * If the term ends in a non-word character, then \\b won't match on\n             * the boundary to the next non-word character, which would likely\n             * be a space. For example `/\\bFIX!\\b/.test('FIX! blah') === false`.\n             * In these cases, use no bounding match. Same applies for the\n             * prefix, handled below.\n             */\n            suffix = /\\w$/.test(term) ? \"\\\\b\" : \"\";\n\n            if (location === \"start\") {\n\n                /*\n                 * When matching at the start, ignore leading whitespace, and\n                 * there's no need to worry about word boundaries.\n                 */\n                prefix = \"^\\\\s*\";\n            } else if (/^\\w/.test(term)) {\n                prefix = \"\\\\b\";\n            } else {\n                prefix = \"\";\n            }\n\n            return new RegExp(prefix + escaped + suffix, \"i\");\n        }\n\n        /**\n         * Checks the specified comment for matches of the configured warning terms and returns the matches.\n         * @param {String} comment The comment which is checked.\n         * @returns {Array} All matched warning terms for this comment.\n         */\n        function commentContainsWarningTerm(comment) {\n            var matches = [];\n\n            warningRegExps.forEach(function(regex, index) {\n                if (regex.test(comment)) {\n                    matches.push(warningTerms[index]);\n                }\n            });\n\n            return matches;\n        }\n\n        /**\n         * Checks the specified node for matching warning comments and reports them.\n         * @param {ASTNode} node The AST node being checked.\n         * @returns {void} undefined.\n         */\n        function checkComment(node) {\n            if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(node.value)) {\n                return;\n            }\n\n            var matches = commentContainsWarningTerm(node.value);\n\n            matches.forEach(function(matchedTerm) {\n                context.report(node, \"Unexpected '\" + matchedTerm + \"' comment.\");\n            });\n        }\n\n        warningRegExps = warningTerms.map(convertToRegExp);\n        return {\n            BlockComment: checkComment,\n            LineComment: checkComment\n        };\n    }\n};\n"]}