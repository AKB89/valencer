{"version":3,"sources":["no-control-regex.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,oDADX;AAEF,sBAAU,iBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ;AAPN,KADO;;AAWb,YAAQ,UAAS,OAAT,EAAkB;;;;;;;;AAQtB,iBAAS,SAAT,CAAmB,IAAnB,EAAyB;AACrB,gBAAI,KAAK,KAAL,YAAsB,MAA1B,EAAkC;AAC9B,uBAAO,KAAK,KAAZ;AACH,aAFD,MAEO,IAAI,OAAO,KAAK,KAAZ,KAAsB,QAA1B,EAAoC;;AAEvC,oBAAI,SAAS,QAAQ,YAAR,GAAuB,GAAvB,EAAb;;AAEA,oBAAI,CAAC,OAAO,IAAP,KAAgB,eAAhB,IAAmC,OAAO,IAAP,KAAgB,gBAApD,KACA,OAAO,MAAP,CAAc,IAAd,KAAuB,YADvB,IACuC,OAAO,MAAP,CAAc,IAAd,KAAuB,QADlE,EAEE;;;AAGE,wBAAI;AACA,+BAAO,IAAI,MAAJ,CAAW,KAAK,KAAhB,CAAP;AACH,qBAFD,CAEE,OAAO,EAAP,EAAW;AACT,+BAAO,IAAP;AACH;AACJ;AACJ;;AAED,mBAAO,IAAP;AACH;;;;;;;;AAQD,iBAAS,oBAAT,CAA8B,QAA9B,EAAwC;;;AAGpC,gBAAI,kBAAkB,cAAc,IAAd,CAAmB,QAAnB,CAAtB,C;;;AAGA,gBAAI,cAAc,SAAS,MAAT,CAAgB,kBAAhB,CAAlB;;AAEA,gBAAI,CAAC,eAAD,IAAoB,cAAc,CAAC,CAAvC,EAA0C;;;AAGtC,oBAAI,2BAA2B,SAAS,MAAT,CAAgB,CAAhB,EAAmB,WAAnB,EAAgC,KAAhC,CAAsC,QAAtC,CAA/B;;AAEA,kCAAkB,6BAA6B,IAA7B,IAAqC,EAAE,yBAAyB,CAAzB,EAA4B,MAA5B,GAAqC,CAAvC,CAAvD;AACH;;AAED,mBAAO,eAAP;AACH;;AAED,eAAO;AACH,qBAAS,UAAS,IAAT,EAAe;AACpB,oBAAI,aAAJ;oBACI,QAAQ,UAAU,IAAV,CADZ;;AAGA,oBAAI,KAAJ,EAAW;AACP,oCAAgB,MAAM,QAAN,EAAhB;;AAEA,wBAAI,qBAAqB,aAArB,CAAJ,EAAyC;AACrC,gCAAQ,MAAR,CAAe,IAAf,EAAqB,qDAArB;AACH;AACJ;AACJ;AAZE,SAAP;AAeH;AAlFY,CAAjB","file":"no-control-regex-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to forbid control charactes from regular expressions.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow control characters in regular expressions\",\n            category: \"Possible Errors\",\n            recommended: true\n        },\n\n        schema: []\n    },\n\n    create: function(context) {\n\n        /**\n         * Get the regex expression\n         * @param {ASTNode} node node to evaluate\n         * @returns {*} Regex if found else null\n         * @private\n         */\n        function getRegExp(node) {\n            if (node.value instanceof RegExp) {\n                return node.value;\n            } else if (typeof node.value === \"string\") {\n\n                var parent = context.getAncestors().pop();\n\n                if ((parent.type === \"NewExpression\" || parent.type === \"CallExpression\") &&\n                    parent.callee.type === \"Identifier\" && parent.callee.name === \"RegExp\"\n                ) {\n\n                    // there could be an invalid regular expression string\n                    try {\n                        return new RegExp(node.value);\n                    } catch (ex) {\n                        return null;\n                    }\n                }\n            }\n\n            return null;\n        }\n\n        /**\n         * Check if given regex string has control characters in it\n         * @param {String} regexStr regex as string to check\n         * @returns {Boolean} returns true if finds control characters on given string\n         * @private\n         */\n        function hasControlCharacters(regexStr) {\n\n            // check control characters, if RegExp object used\n            var hasControlChars = /[\\x00-\\x1f]/.test(regexStr); // eslint-disable-line no-control-regex\n\n            // check substr, if regex literal used\n            var subStrIndex = regexStr.search(/\\\\x[01][0-9a-f]/i);\n\n            if (!hasControlChars && subStrIndex > -1) {\n\n                // is it escaped, check backslash count\n                var possibleEscapeCharacters = regexStr.substr(0, subStrIndex).match(/\\\\+$/gi);\n\n                hasControlChars = possibleEscapeCharacters === null || !(possibleEscapeCharacters[0].length % 2);\n            }\n\n            return hasControlChars;\n        }\n\n        return {\n            Literal: function(node) {\n                var computedValue,\n                    regex = getRegExp(node);\n\n                if (regex) {\n                    computedValue = regex.toString();\n\n                    if (hasControlCharacters(computedValue)) {\n                        context.report(node, \"Unexpected control character in regular expression.\");\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]}