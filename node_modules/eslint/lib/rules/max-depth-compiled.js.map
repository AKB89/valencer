{"version":3,"sources":["max-depth.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,mDADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,mBAAO,CACH;AACI,sBAAM,SADV;AAEI,yBAAS;AAFb,aADG,EAKH;AACI,sBAAM,QADV;AAEI,4BAAY;AACR,6BAAS;AACL,8BAAM,SADD;AAEL,iCAAS;AAFJ,qBADD;AAKR,yBAAK;AACD,8BAAM,SADL;AAED,iCAAS;AAFR;AALG,iBAFhB;AAYI,sCAAsB;AAZ1B,aALG;AADX,SADI;AAPN,KADO;;AAkCb,YAAQ,UAAS,OAAT,EAAkB;;;;;;AAMtB,YAAI,gBAAgB,EAApB;YACI,SAAS,QAAQ,OAAR,CAAgB,CAAhB,CADb;YAEI,WAAW,CAFf;;AAIA,YAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,cAAP,CAAsB,SAAtB,CAA9B,IAAkE,OAAO,OAAO,OAAd,KAA0B,QAAhG,EAA0G;AACtG,uBAAW,OAAO,OAAlB;AACH;AACD,YAAI,OAAO,MAAP,KAAkB,QAAlB,IAA8B,OAAO,cAAP,CAAsB,KAAtB,CAA9B,IAA8D,OAAO,OAAO,GAAd,KAAsB,QAAxF,EAAkG;AAC9F,uBAAW,OAAO,GAAlB;AACH;AACD,YAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,uBAAW,MAAX;AACH;;;;;;;AAOD,iBAAS,aAAT,GAAyB;AACrB,0BAAc,IAAd,CAAmB,CAAnB;AACH;;;;;;;AAOD,iBAAS,WAAT,GAAuB;AACnB,0BAAc,GAAd;AACH;;;;;;;;AAQD,iBAAS,SAAT,CAAmB,IAAnB,EAAyB;AACrB,gBAAI,MAAM,EAAE,cAAc,cAAc,MAAd,GAAuB,CAArC,CAAZ;;AAEA,gBAAI,MAAM,QAAV,EAAoB;AAChB,wBAAQ,MAAR,CAAe,IAAf,EAAqB,2CAArB,EACQ,EAAE,OAAO,GAAT,EADR;AAEH;AACJ;;;;;;;AAOD,iBAAS,QAAT,GAAoB;AAChB,0BAAc,cAAc,MAAd,GAAuB,CAArC;AACH;;;;;;AAMD,eAAO;AACH,qBAAS,aADN;AAEH,iCAAqB,aAFlB;AAGH,gCAAoB,aAHjB;AAIH,qCAAyB,aAJtB;;AAMH,yBAAa,UAAS,IAAT,EAAe;AACxB,oBAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,aAAzB,EAAwC;AACpC,8BAAU,IAAV;AACH;AACJ,aAVE;AAWH,6BAAiB,SAXd;AAYH,0BAAc,SAZX;AAaH,8BAAkB,SAbf;AAcH,4BAAgB,SAdb;AAeH,2BAAe,SAfZ;AAgBH,0BAAc,SAhBX;AAiBH,4BAAgB,SAjBb;AAkBH,4BAAgB,SAlBb;;AAoBH,gCAAoB,QApBjB;AAqBH,oCAAwB,QArBrB;AAsBH,iCAAqB,QAtBlB;AAuBH,qCAAyB,QAvBtB;AAwBH,mCAAuB,QAxBpB;AAyBH,kCAAsB,QAzBnB;AA0BH,iCAAqB,QA1BlB;AA2BH,mCAAuB,QA3BpB;AA4BH,mCAAuB,QA5BpB;;AA8BH,wCAA4B,WA9BzB;AA+BH,uCAA2B,WA/BxB;AAgCH,4CAAgC,WAhC7B;AAiCH,4BAAgB;AAjCb,SAAP;AAoCH;AAxIY,CAAjB","file":"max-depth-compiled.js","sourcesContent":["/**\n * @fileoverview A rule to set the maximum depth block can be nested in a function.\n * @author Ian Christian Myers\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"enforce a maximum depth that blocks can be nested\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                oneOf: [\n                    {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    {\n                        type: \"object\",\n                        properties: {\n                            maximum: {\n                                type: \"integer\",\n                                minimum: 0\n                            },\n                            max: {\n                                type: \"integer\",\n                                minimum: 0\n                            }\n                        },\n                        additionalProperties: false\n                    }\n                ]\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        //--------------------------------------------------------------------------\n        // Helpers\n        //--------------------------------------------------------------------------\n\n        var functionStack = [],\n            option = context.options[0],\n            maxDepth = 4;\n\n        if (typeof option === \"object\" && option.hasOwnProperty(\"maximum\") && typeof option.maximum === \"number\") {\n            maxDepth = option.maximum;\n        }\n        if (typeof option === \"object\" && option.hasOwnProperty(\"max\") && typeof option.max === \"number\") {\n            maxDepth = option.max;\n        }\n        if (typeof option === \"number\") {\n            maxDepth = option;\n        }\n\n        /**\n         * When parsing a new function, store it in our function stack\n         * @returns {void}\n         * @private\n         */\n        function startFunction() {\n            functionStack.push(0);\n        }\n\n        /**\n         * When parsing is done then pop out the reference\n         * @returns {void}\n         * @private\n         */\n        function endFunction() {\n            functionStack.pop();\n        }\n\n        /**\n         * Save the block and Evaluate the node\n         * @param {ASTNode} node node to evaluate\n         * @returns {void}\n         * @private\n         */\n        function pushBlock(node) {\n            var len = ++functionStack[functionStack.length - 1];\n\n            if (len > maxDepth) {\n                context.report(node, \"Blocks are nested too deeply ({{depth}}).\",\n                        { depth: len });\n            }\n        }\n\n        /**\n         * Pop the saved block\n         * @returns {void}\n         * @private\n         */\n        function popBlock() {\n            functionStack[functionStack.length - 1]--;\n        }\n\n        //--------------------------------------------------------------------------\n        // Public API\n        //--------------------------------------------------------------------------\n\n        return {\n            Program: startFunction,\n            FunctionDeclaration: startFunction,\n            FunctionExpression: startFunction,\n            ArrowFunctionExpression: startFunction,\n\n            IfStatement: function(node) {\n                if (node.parent.type !== \"IfStatement\") {\n                    pushBlock(node);\n                }\n            },\n            SwitchStatement: pushBlock,\n            TryStatement: pushBlock,\n            DoWhileStatement: pushBlock,\n            WhileStatement: pushBlock,\n            WithStatement: pushBlock,\n            ForStatement: pushBlock,\n            ForInStatement: pushBlock,\n            ForOfStatement: pushBlock,\n\n            \"IfStatement:exit\": popBlock,\n            \"SwitchStatement:exit\": popBlock,\n            \"TryStatement:exit\": popBlock,\n            \"DoWhileStatement:exit\": popBlock,\n            \"WhileStatement:exit\": popBlock,\n            \"WithStatement:exit\": popBlock,\n            \"ForStatement:exit\": popBlock,\n            \"ForInStatement:exit\": popBlock,\n            \"ForOfStatement:exit\": popBlock,\n\n            \"FunctionDeclaration:exit\": endFunction,\n            \"FunctionExpression:exit\": endFunction,\n            \"ArrowFunctionExpression:exit\": endFunction,\n            \"Program:exit\": endFunction\n        };\n\n    }\n};\n"]}