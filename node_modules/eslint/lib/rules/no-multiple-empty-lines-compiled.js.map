{"version":3,"sources":["no-multiple-empty-lines.js"],"names":[],"mappings":";;;;;AAKA;;;;;;AAMA,OAAO,OAAP,GAAiB;AACb,UAAM;AACF,cAAM;AACF,yBAAa,+BADX;AAEF,sBAAU,kBAFR;AAGF,yBAAa;AAHX,SADJ;;AAOF,gBAAQ,CACJ;AACI,kBAAM,QADV;AAEI,wBAAY;AACR,qBAAK;AACD,0BAAM,SADL;AAED,6BAAS;AAFR,iBADG;AAKR,wBAAQ;AACJ,0BAAM,SADF;AAEJ,6BAAS;AAFL,iBALA;AASR,wBAAQ;AACJ,0BAAM,SADF;AAEJ,6BAAS;AAFL;AATA,aAFhB;AAgBI,sBAAU,CAAC,KAAD,CAhBd;AAiBI,kCAAsB;AAjB1B,SADI;AAPN,KADO;;AA+Bb,YAAQ,gBAAS,OAAT,EAAkB;;;AAGtB,YAAI,MAAM,CAAV;YACI,MADJ;YAEI,MAFJ;;;AAKA,YAAI,WAAW,EAAf;;AAEA,YAAI,QAAQ,OAAR,CAAgB,MAApB,EAA4B;AACxB,kBAAM,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,GAAzB;AACA,qBAAS,OAAO,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,MAA1B,KAAqC,WAArC,GAAmD,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,MAAtE,GAA+E,GAAxF;AACA,qBAAS,OAAO,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,MAA1B,KAAqC,WAArC,GAAmD,QAAQ,OAAR,CAAgB,CAAhB,EAAmB,MAAtE,GAA+E,GAAxF;AACH;;AAED,YAAI,aAAa,QAAQ,aAAR,EAAjB;;;;;;AAMA,eAAO;;AAEH,6BAAiB,yBAAS,IAAT,EAAe;AAC5B,oBAAI,QAAQ,KAAK,GAAL,CAAS,KAAT,CAAe,IAA3B;AACA,oBAAI,MAAM,KAAK,GAAL,CAAS,GAAT,CAAa,IAAvB;;AAEA,uBAAO,SAAS,GAAhB,EAAqB;AACjB,6BAAS,IAAT,CAAc,KAAd;AACA;AACH;AACJ,aAVE;;AAYH,4BAAgB,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC3C,oBAAI,QAAQ,WAAW,KAAvB;oBACI,kBAAkB,CAAC,CADvB;oBAEI,YAFJ;oBAGI,eAAe,CAHnB;oBAII,QAJJ;oBAKI,uBALJ;oBAMI,oBAAoB,CAAC,CANzB;oBAOI,eAAe,EAPnB;;AASA,sBAAM,OAAN,CAAc,UAAS,GAAT,EAAc,CAAd,EAAiB;AAC3B,wBAAI,UAAU,IAAI,IAAJ,EAAd;;AAEA,wBAAK,sBAAsB,CAAC,CAAxB,IAA+B,YAAY,EAA/C,EAAoD;AAChD,4CAAoB,CAApB;AACH;;AAED,iCAAa,IAAb,CAAkB,OAAlB;AACH,iBARD;;;AAWA,yBAAS,OAAT,CAAiB,UAAS,CAAT,EAAY,CAAZ,EAAe;AAC5B,iCAAa,CAAb,IAAkB,CAAlB;AACH,iBAFD;;AAIA,oBAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;;;;;;AAM/B,wBAAI,aAAa,aAAa,MAAb,GAAsB,CAAnC,MAA0C,EAA9C,EAAkD;AAC9C,uCAAe,aAAa,KAAb,CAAmB,CAAnB,EAAsB,CAAC,CAAvB,CAAf;AACH;;AAED,8CAA0B,aAAa,MAAvC;AACH,iBAXD,MAWO;;;AAGH,8CAA0B,aAAa,MAAvC;AACA,2BAAO,aAAa,0BAA0B,CAAvC,MAA8C,EAA9C,IACI,0BAA0B,CADrC,EACwC;AACpC;AACH;AACJ;;;AAGD,oBAAI,oBAAoB,MAAxB,EAAgC;AAC5B,4BAAQ,MAAR,CAAe,IAAf,EAAqB,CAArB,EACQ,2DAA2D,MAA3D,GAAoE,WAD5E;AAEH;AACD,kCAAkB,oBAAoB,CAAtC;;AAEA,+BAAe,eAAf;AACA,kCAAkB,aAAa,OAAb,CAAqB,EAArB,EAAyB,kBAAkB,CAA3C,CAAlB;AACA,uBAAO,oBAAoB,CAAC,CAA5B,EAA+B;AAC3B,mCAAe,eAAf;AACA,sCAAkB,aAAa,OAAb,CAAqB,EAArB,EAAyB,kBAAkB,CAA3C,CAAlB;AACA,wBAAI,iBAAiB,kBAAkB,CAAvC,EAA0C;AACtC;AACH,qBAFD,MAEO;AACH,mCAAW;AACP,kCAAM,eAAe,CADd;AAEP,oCAAQ;AAFD,yBAAX;;AAKA,4BAAI,eAAe,uBAAnB,EAA4C;;;AAGxC,gCAAI,gBAAgB,GAApB,EAAyB;AACrB,wCAAQ,MAAR,CAAe;AACX,0CAAM,IADK;AAEX,yCAAK,QAFM;AAGX,6CAAS,eAAe,GAAf,GAAqB,SAArB,IAAkC,QAAQ,CAAR,GAAY,MAAZ,GAAqB,OAAvD,IAAkE;AAHhE,iCAAf;AAKH;AACJ,yBAVD,MAUO;;;AAGH,gCAAI,eAAe,MAAnB,EAA2B;AACvB,wCAAQ,MAAR,CAAe;AACX,0CAAM,IADK;AAEX,yCAAK,QAFM;AAGX,6CAAS,qDAAqD,MAArD,GAA8D;AAH5D,iCAAf;AAKH;AACJ;;;AAGD,uCAAe,CAAf;AACH;AACJ;AACJ;AAxGE,SAAP;AA2GH;AAhKY,CAAjB","file":"no-multiple-empty-lines-compiled.js","sourcesContent":["/**\n * @fileoverview Disallows multiple blank lines.\n * implementation adapted from the no-trailing-spaces rule.\n * @author Greg Cochard\n */\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"disallow multiple empty lines\",\n            category: \"Stylistic Issues\",\n            recommended: false\n        },\n\n        schema: [\n            {\n                type: \"object\",\n                properties: {\n                    max: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxEOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    },\n                    maxBOF: {\n                        type: \"integer\",\n                        minimum: 0\n                    }\n                },\n                required: [\"max\"],\n                additionalProperties: false\n            }\n        ]\n    },\n\n    create: function(context) {\n\n        // Use options.max or 2 as default\n        var max = 2,\n            maxEOF,\n            maxBOF;\n\n        // store lines that appear empty but really aren't\n        var notEmpty = [];\n\n        if (context.options.length) {\n            max = context.options[0].max;\n            maxEOF = typeof context.options[0].maxEOF !== \"undefined\" ? context.options[0].maxEOF : max;\n            maxBOF = typeof context.options[0].maxBOF !== \"undefined\" ? context.options[0].maxBOF : max;\n        }\n\n        var sourceCode = context.getSourceCode();\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        return {\n\n            TemplateLiteral: function(node) {\n                var start = node.loc.start.line;\n                var end = node.loc.end.line;\n\n                while (start <= end) {\n                    notEmpty.push(start);\n                    start++;\n                }\n            },\n\n            \"Program:exit\": function checkBlankLines(node) {\n                var lines = sourceCode.lines,\n                    currentLocation = -1,\n                    lastLocation,\n                    blankCounter = 0,\n                    location,\n                    firstOfEndingBlankLines,\n                    firstNonBlankLine = -1,\n                    trimmedLines = [];\n\n                lines.forEach(function(str, i) {\n                    var trimmed = str.trim();\n\n                    if ((firstNonBlankLine === -1) && (trimmed !== \"\")) {\n                        firstNonBlankLine = i;\n                    }\n\n                    trimmedLines.push(trimmed);\n                });\n\n                // add the notEmpty lines in there with a placeholder\n                notEmpty.forEach(function(x, i) {\n                    trimmedLines[i] = x;\n                });\n\n                if (typeof maxEOF === \"undefined\") {\n\n                    /*\n                     * Swallow the final newline, as some editors add it\n                     * automatically and we don't want it to cause an issue\n                     */\n                    if (trimmedLines[trimmedLines.length - 1] === \"\") {\n                        trimmedLines = trimmedLines.slice(0, -1);\n                    }\n\n                    firstOfEndingBlankLines = trimmedLines.length;\n                } else {\n\n                    // save the number of the first of the last blank lines\n                    firstOfEndingBlankLines = trimmedLines.length;\n                    while (trimmedLines[firstOfEndingBlankLines - 1] === \"\"\n                            && firstOfEndingBlankLines > 0) {\n                        firstOfEndingBlankLines--;\n                    }\n                }\n\n                // Aggregate and count blank lines\n                if (firstNonBlankLine > maxBOF) {\n                    context.report(node, 0,\n                            \"Too many blank lines at the beginning of file. Max of \" + maxBOF + \" allowed.\");\n                }\n                currentLocation = firstNonBlankLine - 1;\n\n                lastLocation = currentLocation;\n                currentLocation = trimmedLines.indexOf(\"\", currentLocation + 1);\n                while (currentLocation !== -1) {\n                    lastLocation = currentLocation;\n                    currentLocation = trimmedLines.indexOf(\"\", currentLocation + 1);\n                    if (lastLocation === currentLocation - 1) {\n                        blankCounter++;\n                    } else {\n                        location = {\n                            line: lastLocation + 1,\n                            column: 1\n                        };\n\n                        if (lastLocation < firstOfEndingBlankLines) {\n\n                            // within the file, not at the end\n                            if (blankCounter >= max) {\n                                context.report({\n                                    node: node,\n                                    loc: location,\n                                    message: \"More than \" + max + \" blank \" + (max === 1 ? \"line\" : \"lines\") + \" not allowed.\"\n                                });\n                            }\n                        } else {\n\n                            // inside the last blank lines\n                            if (blankCounter > maxEOF) {\n                                context.report({\n                                    node: node,\n                                    loc: location,\n                                    message: \"Too many blank lines at the end of file. Max of \" + maxEOF + \" allowed.\"\n                                });\n                            }\n                        }\n\n                        // Finally, reset the blank counter\n                        blankCounter = 0;\n                    }\n                }\n            }\n        };\n\n    }\n};\n"]}