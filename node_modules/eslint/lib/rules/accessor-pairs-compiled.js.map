{"version":3,"sources":["accessor-pairs.js"],"names":[],"mappings":"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","file":"accessor-pairs-compiled.js","sourcesContent":["/**\n * @fileoverview Rule to flag wrapping non-iife in parens\n * @author Gyandeep Singh\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Checks whether or not a given node is an `Identifier` node which was named a given name.\n * @param {ASTNode} node - A node to check.\n * @param {string} name - An expected name of the node.\n * @returns {boolean} `true` if the node is an `Identifier` node which was named as expected.\n */\nfunction isIdentifier(node, name) {\n    return node.type === \"Identifier\" && node.name === name;\n}\n\n/**\n * Checks whether or not a given node is an argument of a specified method call.\n * @param {ASTNode} node - A node to check.\n * @param {number} index - An expected index of the node in arguments.\n * @param {string} object - An expected name of the object of the method.\n * @param {string} property - An expected name of the method.\n * @returns {boolean} `true` if the node is an argument of the specified method call.\n */\nfunction isArgumentOfMethodCall(node, index, object, property) {\n    var parent = node.parent;\n\n    return (\n        parent.type === \"CallExpression\" &&\n        parent.callee.type === \"MemberExpression\" &&\n        parent.callee.computed === false &&\n        isIdentifier(parent.callee.object, object) &&\n        isIdentifier(parent.callee.property, property) &&\n        parent.arguments[index] === node\n    );\n}\n\n/**\n * Checks whether or not a given node is a property descriptor.\n * @param {ASTNode} node - A node to check.\n * @returns {boolean} `true` if the node is a property descriptor.\n */\nfunction isPropertyDescriptor(node) {\n\n    // Object.defineProperty(obj, \"foo\", {set: ...})\n    if (isArgumentOfMethodCall(node, 2, \"Object\", \"defineProperty\") ||\n        isArgumentOfMethodCall(node, 2, \"Reflect\", \"defineProperty\")\n    ) {\n        return true;\n    }\n\n    /*\n     * Object.defineProperties(obj, {foo: {set: ...}})\n     * Object.create(proto, {foo: {set: ...}})\n     */\n    node = node.parent.parent;\n\n    return node.type === \"ObjectExpression\" && (\n        isArgumentOfMethodCall(node, 1, \"Object\", \"create\") ||\n        isArgumentOfMethodCall(node, 1, \"Object\", \"defineProperties\")\n    );\n}\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nmodule.exports = {\n    meta: {\n        docs: {\n            description: \"Enforces getter/setter pairs in objects\",\n            category: \"Best Practices\",\n            recommended: false\n        },\n        schema: [{\n            type: \"object\",\n            properties: {\n                getWithoutSet: {\n                    type: \"boolean\"\n                },\n                setWithoutGet: {\n                    type: \"boolean\"\n                }\n            },\n            additionalProperties: false\n        }]\n    },\n    create: function(context) {\n        var config = context.options[0] || {};\n        var checkGetWithoutSet = config.getWithoutSet === true;\n        var checkSetWithoutGet = config.setWithoutGet !== false;\n\n        /**\n         * Checks a object expression to see if it has setter and getter both present or none.\n         * @param {ASTNode} node The node to check.\n         * @returns {void}\n         * @private\n         */\n        function checkLonelySetGet(node) {\n            var isSetPresent = false;\n            var isGetPresent = false;\n            var isDescriptor = isPropertyDescriptor(node);\n\n            for (var i = 0, end = node.properties.length; i < end; i++) {\n                var property = node.properties[i];\n\n                var propToCheck = \"\";\n\n                if (property.kind === \"init\") {\n                    if (isDescriptor && !property.computed) {\n                        propToCheck = property.key.name;\n                    }\n                } else {\n                    propToCheck = property.kind;\n                }\n\n                switch (propToCheck) {\n                    case \"set\":\n                        isSetPresent = true;\n                        break;\n\n                    case \"get\":\n                        isGetPresent = true;\n                        break;\n\n                    default:\n\n                        // Do nothing\n                }\n\n                if (isSetPresent && isGetPresent) {\n                    break;\n                }\n            }\n\n            if (checkSetWithoutGet && isSetPresent && !isGetPresent) {\n                context.report(node, \"Getter is not present\");\n            } else if (checkGetWithoutSet && isGetPresent && !isSetPresent) {\n                context.report(node, \"Setter is not present\");\n            }\n        }\n\n        return {\n            ObjectExpression: function(node) {\n                if (checkSetWithoutGet || checkGetWithoutSet) {\n                    checkLonelySetGet(node);\n                }\n            }\n        };\n    }\n};\n"]}