{"version":3,"sources":["eslint.js"],"names":[],"mappings":"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","file":"eslint-compiled.js","sourcesContent":["/**\n * @fileoverview Main ESLint object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar assert = require(\"assert\"),\n    EventEmitter = require(\"events\").EventEmitter,\n    escope = require(\"escope\"),\n    levn = require(\"levn\"),\n    lodash = require(\"lodash\"),\n    blankScriptAST = require(\"../conf/blank-script.json\"),\n    DEFAULT_PARSER = require(\"../conf/eslint.json\").parser,\n    replacements = require(\"../conf/replacements.json\"),\n    CodePathAnalyzer = require(\"./code-path-analysis/code-path-analyzer\"),\n    ConfigOps = require(\"./config/config-ops\"),\n    validator = require(\"./config/config-validator\"),\n    Environments = require(\"./config/environments\"),\n    CommentEventGenerator = require(\"./util/comment-event-generator\"),\n    NodeEventGenerator = require(\"./util/node-event-generator\"),\n    SourceCode = require(\"./util/source-code\"),\n    Traverser = require(\"./util/traverser\"),\n    RuleContext = require(\"./rule-context\"),\n    rules = require(\"./rules\"),\n    timing = require(\"./timing\");\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\n/**\n * Parses a list of \"name:boolean_value\" or/and \"name\" options divided by comma or\n * whitespace.\n * @param {string} string The string to parse.\n * @param {Comment} comment The comment node which has the string.\n * @returns {Object} Result map object of names and boolean values\n */\nfunction parseBooleanConfig(string, comment) {\n    var items = {};\n\n    // Collapse whitespace around : to make parsing easier\n    string = string.replace(/\\s*:\\s*/g, \":\");\n\n    // Collapse whitespace around ,\n    string = string.replace(/\\s*,\\s*/g, \",\");\n\n    string.split(/\\s|,+/).forEach(function(name) {\n        if (!name) {\n            return;\n        }\n        var pos = name.indexOf(\":\"),\n            value;\n\n        if (pos !== -1) {\n            value = name.substring(pos + 1, name.length);\n            name = name.substring(0, pos);\n        }\n\n        items[name] = {\n            value: (value === \"true\"),\n            comment: comment\n        };\n\n    });\n    return items;\n}\n\n/**\n * Parses a JSON-like config.\n * @param {string} string The string to parse.\n * @param {Object} location Start line and column of comments for potential error message.\n * @param {Object[]} messages The messages queue for potential error message.\n * @returns {Object} Result map object\n */\nfunction parseJsonConfig(string, location, messages) {\n    var items = {};\n\n    // Parses a JSON-like comment by the same way as parsing CLI option.\n    try {\n        items = levn.parse(\"Object\", string) || {};\n\n        // Some tests say that it should ignore invalid comments such as `/*eslint no-alert:abc*/`.\n        // Also, commaless notations have invalid severity:\n        //     \"no-alert: 2 no-console: 2\" --> {\"no-alert\": \"2 no-console: 2\"}\n        // Should ignore that case as well.\n        if (ConfigOps.isEverySeverityValid(items)) {\n            return items;\n        }\n    } catch (ex) {\n\n        // ignore to parse the string by a fallback.\n    }\n\n    // Optionator cannot parse commaless notations.\n    // But we are supporting that. So this is a fallback for that.\n    items = {};\n    string = string.replace(/([a-zA-Z0-9\\-\\/]+):/g, \"\\\"$1\\\":\").replace(/(\\]|[0-9])\\s+(?=\")/, \"$1,\");\n    try {\n        items = JSON.parse(\"{\" + string + \"}\");\n    } catch (ex) {\n\n        messages.push({\n            ruleId: null,\n            fatal: true,\n            severity: 2,\n            source: null,\n            message: \"Failed to parse JSON from '\" + string + \"': \" + ex.message,\n            line: location.start.line,\n            column: location.start.column + 1\n        });\n\n    }\n\n    return items;\n}\n\n/**\n * Parses a config of values separated by comma.\n * @param {string} string The string to parse.\n * @returns {Object} Result map of values and true values\n */\nfunction parseListConfig(string) {\n    var items = {};\n\n    // Collapse whitespace around ,\n    string = string.replace(/\\s*,\\s*/g, \",\");\n\n    string.split(/,+/).forEach(function(name) {\n        name = name.trim();\n        if (!name) {\n            return;\n        }\n        items[name] = true;\n    });\n    return items;\n}\n\n/**\n * Ensures that variables representing built-in properties of the Global Object,\n * and any globals declared by special block comments, are present in the global\n * scope.\n * @param {ASTNode} program The top node of the AST.\n * @param {Scope} globalScope The global scope.\n * @param {Object} config The existing configuration data.\n * @returns {void}\n */\nfunction addDeclaredGlobals(program, globalScope, config) {\n    var declaredGlobals = {},\n        exportedGlobals = {},\n        explicitGlobals = {},\n        builtin = Environments.get(\"builtin\");\n\n    lodash.assign(declaredGlobals, builtin);\n\n    Object.keys(config.env).forEach(function(name) {\n        if (config.env[name]) {\n            var env = Environments.get(name),\n                environmentGlobals = env && env.globals;\n\n            if (environmentGlobals) {\n                lodash.assign(declaredGlobals, environmentGlobals);\n            }\n        }\n    });\n\n    lodash.assign(exportedGlobals, config.exported);\n    lodash.assign(declaredGlobals, config.globals);\n    lodash.assign(explicitGlobals, config.astGlobals);\n\n    Object.keys(declaredGlobals).forEach(function(name) {\n        var variable = globalScope.set.get(name);\n\n        if (!variable) {\n            variable = new escope.Variable(name, globalScope);\n            variable.eslintExplicitGlobal = false;\n            globalScope.variables.push(variable);\n            globalScope.set.set(name, variable);\n        }\n        variable.writeable = declaredGlobals[name];\n    });\n\n    Object.keys(explicitGlobals).forEach(function(name) {\n        var variable = globalScope.set.get(name);\n\n        if (!variable) {\n            variable = new escope.Variable(name, globalScope);\n            variable.eslintExplicitGlobal = true;\n            variable.eslintExplicitGlobalComment = explicitGlobals[name].comment;\n            globalScope.variables.push(variable);\n            globalScope.set.set(name, variable);\n        }\n        variable.writeable = explicitGlobals[name].value;\n    });\n\n    // mark all exported variables as such\n    Object.keys(exportedGlobals).forEach(function(name) {\n        var variable = globalScope.set.get(name);\n\n        if (variable) {\n            variable.eslintUsed = true;\n        }\n    });\n\n    /*\n     * \"through\" contains all references which definitions cannot be found.\n     * Since we augment the global scope using configuration, we need to update\n     * references and remove the ones that were added by configuration.\n     */\n    globalScope.through = globalScope.through.filter(function(reference) {\n        var name = reference.identifier.name;\n        var variable = globalScope.set.get(name);\n\n        if (variable) {\n\n            /*\n             * Links the variable and the reference.\n             * And this reference is removed from `Scope#through`.\n             */\n            reference.resolved = variable;\n            variable.references.push(reference);\n\n            return false;\n        }\n\n        return true;\n    });\n}\n\n/**\n * Add data to reporting configuration to disable reporting for list of rules\n * starting from start location\n * @param  {Object[]} reportingConfig Current reporting configuration\n * @param  {Object} start Position to start\n * @param  {string[]} rulesToDisable List of rules\n * @returns {void}\n */\nfunction disableReporting(reportingConfig, start, rulesToDisable) {\n\n    if (rulesToDisable.length) {\n        rulesToDisable.forEach(function(rule) {\n            reportingConfig.push({\n                start: start,\n                end: null,\n                rule: rule\n            });\n        });\n    } else {\n        reportingConfig.push({\n            start: start,\n            end: null,\n            rule: null\n        });\n    }\n}\n\n/**\n * Add data to reporting configuration to enable reporting for list of rules\n * starting from start location\n * @param  {Object[]} reportingConfig Current reporting configuration\n * @param  {Object} start Position to start\n * @param  {string[]} rulesToEnable List of rules\n * @returns {void}\n */\nfunction enableReporting(reportingConfig, start, rulesToEnable) {\n    var i;\n\n    if (rulesToEnable.length) {\n        rulesToEnable.forEach(function(rule) {\n            for (i = reportingConfig.length - 1; i >= 0; i--) {\n                if (!reportingConfig[i].end && reportingConfig[i].rule === rule) {\n                    reportingConfig[i].end = start;\n                    break;\n                }\n            }\n        });\n    } else {\n\n        // find all previous disabled locations if they was started as list of rules\n        var prevStart;\n\n        for (i = reportingConfig.length - 1; i >= 0; i--) {\n            if (prevStart && prevStart !== reportingConfig[i].start) {\n                break;\n            }\n\n            if (!reportingConfig[i].end) {\n                reportingConfig[i].end = start;\n                prevStart = reportingConfig[i].start;\n            }\n        }\n    }\n}\n\n/**\n * Parses comments in file to extract file-specific config of rules, globals\n * and environments and merges them with global config; also code blocks\n * where reporting is disabled or enabled and merges them with reporting config.\n * @param {string} filename The file being checked.\n * @param {ASTNode} ast The top node of the AST.\n * @param {Object} config The existing configuration data.\n * @param {Object[]} reportingConfig The existing reporting configuration data.\n * @param {Object[]} messages The messages queue.\n * @returns {object} Modified config object\n */\nfunction modifyConfigsFromComments(filename, ast, config, reportingConfig, messages) {\n\n    var commentConfig = {\n        exported: {},\n        astGlobals: {},\n        rules: {},\n        env: {}\n    };\n    var commentRules = {};\n\n    ast.comments.forEach(function(comment) {\n\n        var value = comment.value.trim();\n        var match = /^(eslint(-\\w+){0,3}|exported|globals?)(\\s|$)/.exec(value);\n\n        if (match) {\n            value = value.substring(match.index + match[1].length);\n\n            if (comment.type === \"Block\") {\n                switch (match[1]) {\n                    case \"exported\":\n                        lodash.assign(commentConfig.exported, parseBooleanConfig(value, comment));\n                        break;\n\n                    case \"globals\":\n                    case \"global\":\n                        lodash.assign(commentConfig.astGlobals, parseBooleanConfig(value, comment));\n                        break;\n\n                    case \"eslint-env\":\n                        lodash.assign(commentConfig.env, parseListConfig(value));\n                        break;\n\n                    case \"eslint-disable\":\n                        disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                        break;\n\n                    case \"eslint-enable\":\n                        enableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                        break;\n\n                    case \"eslint\":\n                        var items = parseJsonConfig(value, comment.loc, messages);\n\n                        Object.keys(items).forEach(function(name) {\n                            var ruleValue = items[name];\n\n                            validator.validateRuleOptions(name, ruleValue, filename + \" line \" + comment.loc.start.line);\n                            commentRules[name] = ruleValue;\n                        });\n                        break;\n\n                    // no default\n                }\n            } else {        // comment.type === \"Line\"\n                if (match[1] === \"eslint-disable-line\") {\n                    disableReporting(reportingConfig, { line: comment.loc.start.line, column: 0 }, Object.keys(parseListConfig(value)));\n                    enableReporting(reportingConfig, comment.loc.end, Object.keys(parseListConfig(value)));\n                } else if (match[1] === \"eslint-disable-next-line\") {\n                    disableReporting(reportingConfig, comment.loc.start, Object.keys(parseListConfig(value)));\n                    enableReporting(reportingConfig, { line: comment.loc.start.line + 2 }, Object.keys(parseListConfig(value)));\n                }\n            }\n        }\n    });\n\n    // apply environment configs\n    Object.keys(commentConfig.env).forEach(function(name) {\n        var env = Environments.get(name);\n\n        if (env) {\n            commentConfig = ConfigOps.merge(commentConfig, env);\n        }\n    });\n    lodash.assign(commentConfig.rules, commentRules);\n\n    return ConfigOps.merge(config, commentConfig);\n}\n\n/**\n * Check if message of rule with ruleId should be ignored in location\n * @param  {Object[]} reportingConfig  Collection of ignore records\n * @param  {string} ruleId   Id of rule\n * @param  {Object} location Location of message\n * @returns {boolean}          True if message should be ignored, false otherwise\n */\nfunction isDisabledByReportingConfig(reportingConfig, ruleId, location) {\n\n    for (var i = 0, c = reportingConfig.length; i < c; i++) {\n\n        var ignore = reportingConfig[i];\n\n        if ((!ignore.rule || ignore.rule === ruleId) &&\n            (location.line > ignore.start.line || (location.line === ignore.start.line && location.column >= ignore.start.column)) &&\n            (!ignore.end || (location.line < ignore.end.line || (location.line === ignore.end.line && location.column <= ignore.end.column)))) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n/**\n * Process initial config to make it safe to extend by file comment config\n * @param  {Object} config Initial config\n * @returns {Object}        Processed config\n */\nfunction prepareConfig(config) {\n\n    config.globals = config.globals || config.global || {};\n    delete config.global;\n\n    var copiedRules = {},\n        parserOptions = {},\n        preparedConfig;\n\n    if (typeof config.rules === \"object\") {\n        Object.keys(config.rules).forEach(function(k) {\n            var rule = config.rules[k];\n\n            if (rule === null) {\n                throw new Error(\"Invalid config for rule '\" + k + \"'\\.\");\n            }\n            if (Array.isArray(rule)) {\n                copiedRules[k] = rule.slice();\n            } else {\n                copiedRules[k] = rule;\n            }\n        });\n    }\n\n    // merge in environment parserOptions\n    if (typeof config.env === \"object\") {\n        Object.keys(config.env).forEach(function(envName) {\n            var env = Environments.get(envName);\n\n            if (config.env[envName] && env && env.parserOptions) {\n                parserOptions = ConfigOps.merge(parserOptions, env.parserOptions);\n            }\n        });\n    }\n\n    preparedConfig = {\n        rules: copiedRules,\n        parser: config.parser || DEFAULT_PARSER,\n        globals: ConfigOps.merge({}, config.globals),\n        env: ConfigOps.merge({}, config.env || {}),\n        settings: ConfigOps.merge({}, config.settings || {}),\n        parserOptions: ConfigOps.merge(parserOptions, config.parserOptions || {})\n    };\n\n    if (preparedConfig.parserOptions.sourceType === \"module\") {\n        if (!preparedConfig.parserOptions.ecmaFeatures) {\n            preparedConfig.parserOptions.ecmaFeatures = {};\n        }\n\n        // can't have global return inside of modules\n        preparedConfig.parserOptions.ecmaFeatures.globalReturn = false;\n\n        // also need at least ES6 for modules\n        if (!preparedConfig.parserOptions.ecmaVersion || preparedConfig.parserOptions.ecmaVersion < 6) {\n            preparedConfig.parserOptions.ecmaVersion = 6;\n        }\n    }\n\n    return preparedConfig;\n}\n\n/**\n * Provide a stub rule with a given message\n * @param  {string} message The message to be displayed for the rule\n * @returns {Function}      Stub rule function\n */\nfunction createStubRule(message) {\n\n    /**\n     * Creates a fake rule object\n     * @param {object} context context object for each rule\n     * @returns {object} collection of node to listen on\n     */\n    function createRuleModule(context) {\n        return {\n            Program: function(node) {\n                context.report(node, message);\n            }\n        };\n    }\n\n    if (message) {\n        return createRuleModule;\n    } else {\n        throw new Error(\"No message passed to stub rule\");\n    }\n}\n\n/**\n * Provide a rule replacement message\n * @param  {string} ruleId Name of the rule\n * @returns {string}       Message detailing rule replacement\n */\nfunction getRuleReplacementMessage(ruleId) {\n    if (ruleId in replacements.rules) {\n        var newRules = replacements.rules[ruleId];\n\n        return \"Rule \\'\" + ruleId + \"\\' was removed and replaced by: \" + newRules.join(\", \");\n    }\n\n    return null;\n}\n\nvar eslintEnvPattern = /\\/\\*\\s*eslint-env\\s(.+?)\\*\\//g;\n\n/**\n * Checks whether or not there is a comment which has \"eslint-env *\" in a given text.\n * @param {string} text - A source code text to check.\n * @returns {object|null} A result of parseListConfig() with \"eslint-env *\" comment.\n */\nfunction findEslintEnv(text) {\n    var match, retv;\n\n    eslintEnvPattern.lastIndex = 0;\n\n    while ((match = eslintEnvPattern.exec(text))) {\n        retv = lodash.assign(retv || {}, parseListConfig(match[1]));\n    }\n\n    return retv;\n}\n\n/**\n * Strips Unicode BOM from a given text.\n *\n * @param {string} text - A text to strip.\n * @returns {string} The stripped text.\n */\nfunction stripUnicodeBOM(text) {\n\n    /*\n     * Check Unicode BOM.\n     * In JavaScript, string data is stored as UTF-16, so BOM is 0xFEFF.\n     * http://www.ecma-international.org/ecma-262/6.0/#sec-unicode-format-control-characters\n     */\n    if (text.charCodeAt(0) === 0xFEFF) {\n        return text.slice(1);\n    }\n    return text;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Object that is responsible for verifying JavaScript text\n * @name eslint\n */\nmodule.exports = (function() {\n\n    var api = Object.create(new EventEmitter()),\n        messages = [],\n        currentConfig = null,\n        currentScopes = null,\n        scopeMap = null,\n        scopeManager = null,\n        currentFilename = null,\n        traverser = null,\n        reportingConfig = [],\n        sourceCode = null;\n\n    /**\n     * Parses text into an AST. Moved out here because the try-catch prevents\n     * optimization of functions, so it's best to keep the try-catch as isolated\n     * as possible\n     * @param {string} text The text to parse.\n     * @param {Object} config The ESLint configuration object.\n     * @returns {ASTNode} The AST if successful or null if not.\n     * @private\n     */\n    function parse(text, config) {\n\n        var parser,\n            parserOptions = {\n                loc: true,\n                range: true,\n                raw: true,\n                tokens: true,\n                comment: true,\n                attachComment: true\n            };\n\n        try {\n            parser = require(config.parser);\n        } catch (ex) {\n            messages.push({\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                source: null,\n                message: ex.message,\n                line: 0,\n                column: 0\n            });\n\n            return null;\n        }\n\n        // merge in any additional parser options\n        if (config.parserOptions) {\n            parserOptions = lodash.assign({}, config.parserOptions, parserOptions);\n        }\n\n        /*\n         * Check for parsing errors first. If there's a parsing error, nothing\n         * else can happen. However, a parsing error does not throw an error\n         * from this method - it's just considered a fatal error message, a\n         * problem that ESLint identified just like any other.\n         */\n        try {\n            return parser.parse(text, parserOptions);\n        } catch (ex) {\n\n            // If the message includes a leading line number, strip it:\n            var message = ex.message.replace(/^line \\d+:/i, \"\").trim();\n            var source = (ex.lineNumber) ? SourceCode.splitLines(text)[ex.lineNumber - 1] : null;\n\n            messages.push({\n                ruleId: null,\n                fatal: true,\n                severity: 2,\n                source: source,\n                message: \"Parsing error: \" + message,\n\n                line: ex.lineNumber,\n                column: ex.column\n            });\n\n            return null;\n        }\n    }\n\n    /**\n     * Get the severity level of a rule (0 - none, 1 - warning, 2 - error)\n     * Returns 0 if the rule config is not valid (an Array or a number)\n     * @param {Array|number} ruleConfig rule configuration\n     * @returns {number} 0, 1, or 2, indicating rule severity\n     */\n    function getRuleSeverity(ruleConfig) {\n        if (typeof ruleConfig === \"number\") {\n            return ruleConfig;\n        } else if (Array.isArray(ruleConfig)) {\n            return ruleConfig[0];\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Get the options for a rule (not including severity), if any\n     * @param {Array|number} ruleConfig rule configuration\n     * @returns {Array} of rule options, empty Array if none\n     */\n    function getRuleOptions(ruleConfig) {\n        if (Array.isArray(ruleConfig)) {\n            return ruleConfig.slice(1);\n        } else {\n            return [];\n        }\n    }\n\n    // set unlimited listeners (see https://github.com/eslint/eslint/issues/524)\n    api.setMaxListeners(0);\n\n    /**\n     * Resets the internal state of the object.\n     * @returns {void}\n     */\n    api.reset = function() {\n        this.removeAllListeners();\n        messages = [];\n        currentConfig = null;\n        currentScopes = null;\n        scopeMap = null;\n        scopeManager = null;\n        traverser = null;\n        reportingConfig = [];\n        sourceCode = null;\n    };\n\n    /**\n     * Configuration object for the `verify` API. A JS representation of the eslintrc files.\n     * @typedef {Object} ESLintConfig\n     * @property {Object} rules The rule configuration to verify against.\n     * @property {string} [parser] Parser to use when generatig the AST.\n     * @property {Object} [parserOptions] Options for the parsed used.\n     * @property {Object} [settings] Global settings passed to each rule.\n     * @property {Object} [env] The environment to verify in.\n     * @property {Object} [globals] Available globalsto the code.\n     */\n\n    /**\n     * Verifies the text against the rules specified by the second argument.\n     * @param {string|SourceCode} textOrSourceCode The text to parse or a SourceCode object.\n     * @param {ESLintConfig} config An ESLintConfig instance to configure everything.\n     * @param {(string|Object)} [filenameOrOptions] The optional filename of the file being checked.\n     *      If this is not set, the filename will default to '<input>' in the rule context. If\n     *      an object, then it has \"filename\", \"saveState\", and \"allowInlineConfig\" properties.\n     * @param {boolean} [saveState] Indicates if the state from the last run should be saved.\n     *      Mostly useful for testing purposes.\n     * @param {boolean} [filenameOrOptions.allowInlineConfig] Allow/disallow inline comments' ability to change config once it is set. Defaults to true if not supplied.\n     *      Useful if you want to validate JS without comments overriding rules.\n     * @returns {Object[]} The results as an array of messages or null if no messages.\n     */\n    api.verify = function(textOrSourceCode, config, filenameOrOptions, saveState) {\n\n        var ast,\n            shebang,\n            ecmaFeatures,\n            ecmaVersion,\n            allowInlineConfig,\n            text = (typeof textOrSourceCode === \"string\") ? textOrSourceCode : null;\n\n        // evaluate arguments\n        if (typeof filenameOrOptions === \"object\") {\n            currentFilename = filenameOrOptions.filename;\n            allowInlineConfig = filenameOrOptions.allowInlineConfig;\n            saveState = filenameOrOptions.saveState;\n        } else {\n            currentFilename = filenameOrOptions;\n        }\n\n        if (!saveState) {\n            this.reset();\n        }\n\n        // search and apply \"eslint-env *\".\n        var envInFile = findEslintEnv(text || textOrSourceCode.text);\n\n        if (envInFile) {\n            if (!config || !config.env) {\n                config = lodash.assign({}, config || {}, {env: envInFile});\n            } else {\n                config = lodash.assign({}, config);\n                config.env = lodash.assign({}, config.env, envInFile);\n            }\n        }\n\n        // process initial config to make it safe to extend\n        config = prepareConfig(config || {});\n\n        // only do this for text\n        if (text !== null) {\n\n            // there's no input, just exit here\n            if (text.trim().length === 0) {\n                sourceCode = new SourceCode(text, blankScriptAST);\n                return messages;\n            }\n\n            ast = parse(\n                stripUnicodeBOM(text).replace(/^#!([^\\r\\n]+)/, function(match, captured) {\n                    shebang = captured;\n                    return \"//\" + captured;\n                }),\n                config\n            );\n\n            if (ast) {\n                sourceCode = new SourceCode(text, ast);\n            }\n\n        } else {\n            sourceCode = textOrSourceCode;\n            ast = sourceCode.ast;\n        }\n\n        // if espree failed to parse the file, there's no sense in setting up rules\n        if (ast) {\n\n            // parse global comments and modify config\n            if (allowInlineConfig !== false) {\n                config = modifyConfigsFromComments(currentFilename, ast, config, reportingConfig, messages);\n            }\n\n            // ensure that severities are normalized in the config\n            ConfigOps.normalize(config);\n\n            // enable appropriate rules\n            Object.keys(config.rules).filter(function(key) {\n                return getRuleSeverity(config.rules[key]) > 0;\n            }).forEach(function(key) {\n                var ruleCreator,\n                    severity,\n                    options,\n                    rule;\n\n                ruleCreator = rules.get(key);\n\n                if (!ruleCreator) {\n                    var replacementMsg = getRuleReplacementMessage(key);\n\n                    if (replacementMsg) {\n                        ruleCreator = createStubRule(replacementMsg);\n                    } else {\n                        ruleCreator = createStubRule(\"Definition for rule '\" + key + \"' was not found\");\n                    }\n                    rules.define(key, ruleCreator);\n                }\n\n                severity = getRuleSeverity(config.rules[key]);\n                options = getRuleOptions(config.rules[key]);\n\n                try {\n                    var ruleContext = new RuleContext(\n                        key, api, severity, options,\n                        config.settings, config.parserOptions, config.parser, ruleCreator.meta);\n\n                    rule = ruleCreator.create ? ruleCreator.create(ruleContext) :\n                        ruleCreator(ruleContext);\n\n                    // add all the node types as listeners\n                    Object.keys(rule).forEach(function(nodeType) {\n                        api.on(nodeType, timing.enabled\n                            ? timing.time(key, rule[nodeType])\n                            : rule[nodeType]\n                        );\n                    });\n                } catch (ex) {\n                    ex.message = \"Error while loading rule '\" + key + \"': \" + ex.message;\n                    throw ex;\n                }\n            });\n\n            // save config so rules can access as necessary\n            currentConfig = config;\n            traverser = new Traverser();\n\n            ecmaFeatures = currentConfig.parserOptions.ecmaFeatures || {};\n            ecmaVersion = currentConfig.parserOptions.ecmaVersion || 5;\n\n            // gather scope data that may be needed by the rules\n            scopeManager = escope.analyze(ast, {\n                ignoreEval: true,\n                nodejsScope: ecmaFeatures.globalReturn,\n                impliedStrict: ecmaFeatures.impliedStrict,\n                ecmaVersion: ecmaVersion,\n                sourceType: currentConfig.parserOptions.sourceType || \"script\",\n                fallback: Traverser.getKeys\n            });\n\n            currentScopes = scopeManager.scopes;\n\n            /*\n             * Index the scopes by the start range of their block for efficient\n             * lookup in getScope.\n             */\n            scopeMap = [];\n\n            currentScopes.forEach(function(scope, index) {\n                var range = scope.block.range[0];\n\n                /*\n                 * Sometimes two scopes are returned for a given node. This is\n                 * handled later in a known way, so just don't overwrite here.\n                 */\n                if (!scopeMap[range]) {\n                    scopeMap[range] = index;\n                }\n            });\n\n            // augment global scope with declared global variables\n            addDeclaredGlobals(ast, currentScopes[0], currentConfig);\n\n            // remove shebang comments\n            if (shebang && ast.comments.length && ast.comments[0].value === shebang) {\n                ast.comments.splice(0, 1);\n\n                if (ast.body.length && ast.body[0].leadingComments && ast.body[0].leadingComments[0].value === shebang) {\n                    ast.body[0].leadingComments.splice(0, 1);\n                }\n            }\n\n            var eventGenerator = new NodeEventGenerator(api);\n\n            eventGenerator = new CodePathAnalyzer(eventGenerator);\n            eventGenerator = new CommentEventGenerator(eventGenerator, sourceCode);\n\n            /*\n             * Each node has a type property. Whenever a particular type of\n             * node is found, an event is fired. This allows any listeners to\n             * automatically be informed that this type of node has been found\n             * and react accordingly.\n             */\n            traverser.traverse(ast, {\n                enter: function(node, parent) {\n                    node.parent = parent;\n                    eventGenerator.enterNode(node);\n                },\n                leave: function(node) {\n                    eventGenerator.leaveNode(node);\n                }\n            });\n        }\n\n        // sort by line and column\n        messages.sort(function(a, b) {\n            var lineDiff = a.line - b.line;\n\n            if (lineDiff === 0) {\n                return a.column - b.column;\n            } else {\n                return lineDiff;\n            }\n        });\n\n        return messages;\n    };\n\n    /**\n     * Reports a message from one of the rules.\n     * @param {string} ruleId The ID of the rule causing the message.\n     * @param {number} severity The severity level of the rule as configured.\n     * @param {ASTNode} node The AST node that the message relates to.\n     * @param {Object=} location An object containing the error line and column\n     *      numbers. If location is not provided the node's start location will\n     *      be used.\n     * @param {string} message The actual message.\n     * @param {Object} opts Optional template data which produces a formatted message\n     *     with symbols being replaced by this object's values.\n     * @param {Object} fix A fix command description.\n     * @param {Object} meta Metadata of the rule\n     * @returns {void}\n     */\n    api.report = function(ruleId, severity, node, location, message, opts, fix, meta) {\n        if (node) {\n            assert.strictEqual(typeof node, \"object\", \"Node must be an object\");\n        }\n\n        if (typeof location === \"string\") {\n            assert.ok(node, \"Node must be provided when reporting error if location is not provided\");\n\n            meta = fix;\n            fix = opts;\n            opts = message;\n            message = location;\n            location = node.loc.start;\n        }\n\n        // else, assume location was provided, so node may be omitted\n\n        if (isDisabledByReportingConfig(reportingConfig, ruleId, location)) {\n            return;\n        }\n\n        if (opts) {\n            message = message.replace(/\\{\\{\\s*(.+?)\\s*\\}\\}/g, function(fullMatch, term) {\n                if (term in opts) {\n                    return opts[term];\n                }\n\n                // Preserve old behavior: If parameter name not provided, don't replace it.\n                return fullMatch;\n            });\n        }\n\n        var problem = {\n            ruleId: ruleId,\n            severity: severity,\n            message: message,\n            line: location.line,\n            column: location.column + 1,   // switch to 1-base instead of 0-base\n            nodeType: node && node.type,\n            source: sourceCode.lines[location.line - 1] || \"\"\n        };\n\n        // ensure there's range and text properties, otherwise it's not a valid fix\n        if (fix && Array.isArray(fix.range) && (typeof fix.text === \"string\")) {\n\n            // If rule uses fix, has metadata, but has no metadata.fixable, we should throw\n            if (meta && !meta.fixable) {\n                throw new Error(\"Fixable rules should export a `meta.fixable` property.\");\n            }\n\n            problem.fix = fix;\n        }\n\n        messages.push(problem);\n    };\n\n    /**\n     * Gets the SourceCode object representing the parsed source.\n     * @returns {SourceCode} The SourceCode object.\n     */\n    api.getSourceCode = function() {\n        return sourceCode;\n    };\n\n    // methods that exist on SourceCode object\n    var externalMethods = {\n        getSource: \"getText\",\n        getSourceLines: \"getLines\",\n        getAllComments: \"getAllComments\",\n        getNodeByRangeIndex: \"getNodeByRangeIndex\",\n        getComments: \"getComments\",\n        getJSDocComment: \"getJSDocComment\",\n        getFirstToken: \"getFirstToken\",\n        getFirstTokens: \"getFirstTokens\",\n        getLastToken: \"getLastToken\",\n        getLastTokens: \"getLastTokens\",\n        getTokenAfter: \"getTokenAfter\",\n        getTokenBefore: \"getTokenBefore\",\n        getTokenByRangeStart: \"getTokenByRangeStart\",\n        getTokens: \"getTokens\",\n        getTokensAfter: \"getTokensAfter\",\n        getTokensBefore: \"getTokensBefore\",\n        getTokensBetween: \"getTokensBetween\"\n    };\n\n    // copy over methods\n    Object.keys(externalMethods).forEach(function(methodName) {\n        var exMethodName = externalMethods[methodName];\n\n        // All functions expected to have less arguments than 5.\n        api[methodName] = function(a, b, c, d, e) {\n            if (sourceCode) {\n                return sourceCode[exMethodName](a, b, c, d, e);\n            }\n            return null;\n        };\n    });\n\n    /**\n     * Gets nodes that are ancestors of current node.\n     * @returns {ASTNode[]} Array of objects representing ancestors.\n     */\n    api.getAncestors = function() {\n        return traverser.parents();\n    };\n\n    /**\n     * Gets the scope for the current node.\n     * @returns {Object} An object representing the current node's scope.\n     */\n    api.getScope = function() {\n        var parents = traverser.parents(),\n            scope = currentScopes[0];\n\n        // Don't do this for Program nodes - they have no parents\n        if (parents.length) {\n\n            // if current node introduces a scope, add it to the list\n            var current = traverser.current();\n\n            if (currentConfig.parserOptions.ecmaVersion >= 6) {\n                if ([\"BlockStatement\", \"SwitchStatement\", \"CatchClause\", \"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(current.type) >= 0) {\n                    parents.push(current);\n                }\n            } else {\n                if ([\"FunctionDeclaration\", \"FunctionExpression\", \"ArrowFunctionExpression\"].indexOf(current.type) >= 0) {\n                    parents.push(current);\n                }\n            }\n\n            // Ascend the current node's parents\n            for (var i = parents.length - 1; i >= 0; --i) {\n\n                // Get the innermost scope\n                scope = scopeManager.acquire(parents[i], true);\n                if (scope) {\n                    if (scope.type === \"function-expression-name\") {\n                        return scope.childScopes[0];\n                    } else {\n                        return scope;\n                    }\n                }\n\n            }\n\n        }\n\n        return currentScopes[0];\n    };\n\n    /**\n     * Record that a particular variable has been used in code\n     * @param {string} name The name of the variable to mark as used\n     * @returns {boolean} True if the variable was found and marked as used,\n     *      false if not.\n     */\n    api.markVariableAsUsed = function(name) {\n        var scope = this.getScope(),\n            hasGlobalReturn = currentConfig.parserOptions.ecmaFeatures && currentConfig.parserOptions.ecmaFeatures.globalReturn,\n            specialScope = hasGlobalReturn || currentConfig.parserOptions.sourceType === \"module\",\n            variables,\n            i,\n            len;\n\n        // Special Node.js scope means we need to start one level deeper\n        if (scope.type === \"global\" && specialScope) {\n            scope = scope.childScopes[0];\n        }\n\n        do {\n            variables = scope.variables;\n            for (i = 0, len = variables.length; i < len; i++) {\n                if (variables[i].name === name) {\n                    variables[i].eslintUsed = true;\n                    return true;\n                }\n            }\n        } while ((scope = scope.upper));\n\n        return false;\n    };\n\n    /**\n     * Gets the filename for the currently parsed source.\n     * @returns {string} The filename associated with the source being parsed.\n     *     Defaults to \"<input>\" if no filename info is present.\n     */\n    api.getFilename = function() {\n        if (typeof currentFilename === \"string\") {\n            return currentFilename;\n        } else {\n            return \"<input>\";\n        }\n    };\n\n    /**\n     * Defines a new linting rule.\n     * @param {string} ruleId A unique rule identifier\n     * @param {Function} ruleModule Function from context to object mapping AST node types to event handlers\n     * @returns {void}\n     */\n    var defineRule = api.defineRule = function(ruleId, ruleModule) {\n        rules.define(ruleId, ruleModule);\n    };\n\n    /**\n     * Defines many new linting rules.\n     * @param {object} rulesToDefine map from unique rule identifier to rule\n     * @returns {void}\n     */\n    api.defineRules = function(rulesToDefine) {\n        Object.getOwnPropertyNames(rulesToDefine).forEach(function(ruleId) {\n            defineRule(ruleId, rulesToDefine[ruleId]);\n        });\n    };\n\n    /**\n     * Gets the default eslint configuration.\n     * @returns {Object} Object mapping rule IDs to their default configurations\n     */\n    api.defaults = function() {\n        return require(\"../conf/eslint.json\");\n    };\n\n    /**\n     * Gets variables that are declared by a specified node.\n     *\n     * The variables are its `defs[].node` or `defs[].parent` is same as the specified node.\n     * Specifically, below:\n     *\n     * - `VariableDeclaration` - variables of its all declarators.\n     * - `VariableDeclarator` - variables.\n     * - `FunctionDeclaration`/`FunctionExpression` - its function name and parameters.\n     * - `ArrowFunctionExpression` - its parameters.\n     * - `ClassDeclaration`/`ClassExpression` - its class name.\n     * - `CatchClause` - variables of its exception.\n     * - `ImportDeclaration` - variables of  its all specifiers.\n     * - `ImportSpecifier`/`ImportDefaultSpecifier`/`ImportNamespaceSpecifier` - a variable.\n     * - others - always an empty array.\n     *\n     * @param {ASTNode} node A node to get.\n     * @returns {escope.Variable[]} Variables that are declared by the node.\n     */\n    api.getDeclaredVariables = function(node) {\n        return (scopeManager && scopeManager.getDeclaredVariables(node)) || [];\n    };\n\n    return api;\n\n}());\n"]}