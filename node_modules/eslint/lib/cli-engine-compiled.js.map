{"version":3,"sources":["cli-engine.js"],"names":[],"mappings":"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","file":"cli-engine-compiled.js","sourcesContent":["/**\n * @fileoverview Main CLI object.\n * @author Nicholas C. Zakas\n */\n\n\"use strict\";\n\n/*\n * The CLI object should *not* call process.exit() directly. It should only return\n * exit codes. This allows other programs to use the CLI object and still control\n * when the program exits.\n */\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nvar fs = require(\"fs\"),\n    path = require(\"path\"),\n\n    lodash = require(\"lodash\"),\n    debug = require(\"debug\"),\n    isAbsolute = require(\"path-is-absolute\"),\n\n    rules = require(\"./rules\"),\n    eslint = require(\"./eslint\"),\n    defaultOptions = require(\"../conf/cli-options\"),\n    IgnoredPaths = require(\"./ignored-paths\"),\n    Config = require(\"./config\"),\n    Plugins = require(\"./config/plugins\"),\n    fileEntryCache = require(\"file-entry-cache\"),\n    globUtil = require(\"./util/glob-util\"),\n    SourceCodeFixer = require(\"./util/source-code-fixer\"),\n    validator = require(\"./config/config-validator\"),\n    stringify = require(\"json-stable-stringify\"),\n    hash = require(\"./util/hash\"),\n\n    pkg = require(\"../package.json\");\n\n\n//------------------------------------------------------------------------------\n// Typedefs\n//------------------------------------------------------------------------------\n\n/**\n * The options to configure a CLI engine with.\n * @typedef {Object} CLIEngineOptions\n * @property {string} configFile The configuration file to use.\n * @property {boolean|object} baseConfig Base config object. True enables recommend rules and environments.\n * @property {boolean} ignore False disables use of .eslintignore.\n * @property {string[]} rulePaths An array of directories to load custom rules from.\n * @property {boolean} useEslintrc False disables looking for .eslintrc\n * @property {string[]} envs An array of environments to load.\n * @property {string[]} globals An array of global variables to declare.\n * @property {string[]} extensions An array of file extensions to check.\n * @property {Object<string,*>} rules An object of rules to use.\n * @property {string} ignorePath The ignore file to use instead of .eslintignore.\n */\n\n/**\n * A linting warning or error.\n * @typedef {Object} LintMessage\n * @property {string} message The message to display to the user.\n */\n\n/**\n * A linting result.\n * @typedef {Object} LintResult\n * @property {string} filePath The path to the file that was linted.\n * @property {LintMessage[]} messages All of the messages for the result.\n * @property {number} errorCount Number or errors for the result.\n * @property {number} warningCount Number or warnings for the result.\n */\n\n//------------------------------------------------------------------------------\n// Helpers\n//------------------------------------------------------------------------------\n\ndebug = debug(\"eslint:cli-engine\");\n\n/**\n * It will calculate the error and warning count for collection of messages per file\n * @param {Object[]} messages - Collection of messages\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerFile(messages) {\n    return messages.reduce(function(stat, message) {\n        if (message.fatal || message.severity === 2) {\n            stat.errorCount++;\n        } else {\n            stat.warningCount++;\n        }\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0\n    });\n}\n\n/**\n * It will calculate the error and warning count for collection of results from all files\n * @param {Object[]} results - Collection of messages from all the files\n * @returns {Object} Contains the stats\n * @private\n */\nfunction calculateStatsPerRun(results) {\n    return results.reduce(function(stat, result) {\n        stat.errorCount += result.errorCount;\n        stat.warningCount += result.warningCount;\n        return stat;\n    }, {\n        errorCount: 0,\n        warningCount: 0\n    });\n}\n\n/**\n * Performs multiple autofix passes over the text until as many fixes as possible\n * have been applied.\n * @param {string} text The source text to apply fixes to.\n * @param {Object} config The ESLint config object to use.\n * @param {Object} options The ESLint options object to use.\n * @param {string} options.filename The filename from which the text was read.\n * @param {boolean} options.allowInlineConfig Flag indicating if inline comments\n *      should be allowed.\n * @returns {Object} The result of the fix operation as returned from the\n *      SourceCodeFixer.\n * @private\n */\nfunction multipassFix(text, config, options) {\n\n    var messages = [],\n        fixedResult,\n        fixed = false,\n        passNumber = 0,\n        MAX_PASSES = 10;\n\n    /**\n     * This loop continues until one of the following is true:\n     *\n     * 1. No more fixes have been applied.\n     * 2. Ten passes have been made.\n     *\n     * That means anytime a fix is successfully applied, there will be another pass.\n     * Essentially, guaranteeing a minimum of two passes.\n     */\n    do {\n        passNumber++;\n\n        debug(\"Linting code for \" + options.filename + \" (pass \" + passNumber + \")\");\n        messages = eslint.verify(text, config, options);\n\n        debug(\"Generating fixed text for \" + options.filename + \" (pass \" + passNumber + \")\");\n        fixedResult = SourceCodeFixer.applyFixes(eslint.getSourceCode(), messages);\n\n        // stop if there are any syntax errors.\n        // 'fixedResult.output' is a empty string.\n        if (messages.length === 1 && messages[0].fatal) {\n            break;\n        }\n\n        // keep track if any fixes were ever applied - important for return value\n        fixed = fixed || fixedResult.fixed;\n\n        // update to use the fixed output instead of the original text\n        text = fixedResult.output;\n\n    } while (\n        fixedResult.fixed &&\n        passNumber < MAX_PASSES\n    );\n\n\n    /*\n     * If the last result had fixes, we need to lint again to me sure we have\n     * the most up-to-date information.\n     */\n    if (fixedResult.fixed) {\n        fixedResult.messages = eslint.verify(text, config, options);\n    }\n\n\n    // ensure the last result properly reflects if fixes were done\n    fixedResult.fixed = fixed;\n    fixedResult.output = text;\n\n    return fixedResult;\n\n}\n\n/**\n * Processes an source code using ESLint.\n * @param {string} text The source code to check.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {string} filename An optional string representing the texts filename.\n * @param {boolean} fix Indicates if fixes should be processed.\n * @param {boolean} allowInlineConfig Allow/ignore comments that change config.\n * @returns {Result} The results for linting on this text.\n * @private\n */\nfunction processText(text, configHelper, filename, fix, allowInlineConfig) {\n\n    // clear all existing settings for a new file\n    eslint.reset();\n\n    var filePath,\n        config,\n        messages,\n        stats,\n        fileExtension,\n        processor,\n        loadedPlugins,\n        fixedResult;\n\n    if (filename) {\n        filePath = path.resolve(filename);\n        fileExtension = path.extname(filename);\n    }\n\n    filename = filename || \"<text>\";\n    debug(\"Linting \" + filename);\n    config = configHelper.getConfig(filePath);\n\n    if (config.plugins) {\n        Plugins.loadAll(config.plugins);\n    }\n\n    loadedPlugins = Plugins.getAll();\n\n    for (var plugin in loadedPlugins) {\n        if (loadedPlugins[plugin].processors && Object.keys(loadedPlugins[plugin].processors).indexOf(fileExtension) >= 0) {\n            processor = loadedPlugins[plugin].processors[fileExtension];\n            break;\n        }\n    }\n\n    if (processor) {\n        debug(\"Using processor\");\n        var parsedBlocks = processor.preprocess(text, filename);\n        var unprocessedMessages = [];\n\n        parsedBlocks.forEach(function(block) {\n            unprocessedMessages.push(eslint.verify(block, config, {\n                filename: filename,\n                allowInlineConfig: allowInlineConfig\n            }));\n        });\n\n        // TODO(nzakas): Figure out how fixes might work for processors\n\n        messages = processor.postprocess(unprocessedMessages, filename);\n\n    } else {\n\n        if (fix) {\n            fixedResult = multipassFix(text, config, {\n                filename: filename,\n                allowInlineConfig: allowInlineConfig\n            });\n            messages = fixedResult.messages;\n        } else {\n            messages = eslint.verify(text, config, {\n                filename: filename,\n                allowInlineConfig: allowInlineConfig\n            });\n        }\n    }\n\n    stats = calculateStatsPerFile(messages);\n\n    var result = {\n        filePath: filename,\n        messages: messages,\n        errorCount: stats.errorCount,\n        warningCount: stats.warningCount\n    };\n\n    if (fixedResult && fixedResult.fixed) {\n        result.output = fixedResult.output;\n    }\n\n    return result;\n}\n\n/**\n * Processes an individual file using ESLint. Files used here are known to\n * exist, so no need to check that here.\n * @param {string} filename The filename of the file being checked.\n * @param {Object} configHelper The configuration options for ESLint.\n * @param {Object} options The CLIEngine options object.\n * @returns {Result} The results for linting on this file.\n * @private\n */\nfunction processFile(filename, configHelper, options) {\n\n    var text = fs.readFileSync(path.resolve(filename), \"utf8\"),\n        result = processText(text, configHelper, filename, options.fix, options.allowInlineConfig);\n\n    return result;\n\n}\n\n/**\n * Returns result with warning by ignore settings\n * @param {string} filePath - File path of checked code\n * @param {string} baseDir  - Absolute path of base directory\n * @returns {Result}           Result with single warning\n * @private\n */\nfunction createIgnoreResult(filePath, baseDir) {\n    var message;\n    var isHidden = /^\\./.test(path.basename(filePath));\n    var isInNodeModules = baseDir && /^node_modules/.test(path.relative(baseDir, filePath));\n    var isInBowerComponents = baseDir && /^bower_components/.test(path.relative(baseDir, filePath));\n\n    if (isHidden) {\n        message = \"File ignored by default.  Use a negated ignore pattern (like \\\"--ignore-pattern \\'!<relative/path/to/filename>\\'\\\") to override.\";\n    } else if (isInNodeModules) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern \\'!node_modules/*\\'\\\" to override.\";\n    } else if (isInBowerComponents) {\n        message = \"File ignored by default. Use \\\"--ignore-pattern \\'!bower_components/*\\'\\\" to override.\";\n    } else {\n        message = \"File ignored because of a matching ignore pattern. Use \\\"--no-ignore\\\" to override.\";\n    }\n\n    return {\n        filePath: path.resolve(filePath),\n        messages: [\n            {\n                fatal: false,\n                severity: 1,\n                message: message\n            }\n        ],\n        errorCount: 0,\n        warningCount: 1\n    };\n}\n\n\n/**\n * Checks if the given message is an error message.\n * @param {object} message The message to check.\n * @returns {boolean} Whether or not the message is an error message.\n * @private\n */\nfunction isErrorMessage(message) {\n    return message.severity === 2;\n}\n\n\n/**\n * return the cacheFile to be used by eslint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be the `cacheFile/.cache_hashOfCWD`\n *\n * if cacheFile points to a file or looks like a file then in will just use that file\n *\n * @param {string} cacheFile The name of file to be used to store the cache\n * @param {string} cwd Current working directory\n * @returns {string} the resolved path to the cache file\n */\nfunction getCacheFile(cacheFile, cwd) {\n\n    /*\n     * make sure the path separators are normalized for the environment/os\n     * keeping the trailing path separator if present\n     */\n    cacheFile = path.normalize(cacheFile);\n\n    var resolvedCacheFile = path.resolve(cwd, cacheFile);\n    var looksLikeADirectory = cacheFile[cacheFile.length - 1 ] === path.sep;\n\n    /**\n     * return the name for the cache file in case the provided parameter is a directory\n     * @returns {string} the resolved path to the cacheFile\n     */\n    function getCacheFileForDirectory() {\n        return path.join(resolvedCacheFile, \".cache_\" + hash(cwd));\n    }\n\n    var fileStats;\n\n    try {\n        fileStats = fs.lstatSync(resolvedCacheFile);\n    } catch (ex) {\n        fileStats = null;\n    }\n\n\n    /*\n     * in case the file exists we need to verify if the provided path\n     * is a directory or a file. If it is a directory we want to create a file\n     * inside that directory\n     */\n    if (fileStats) {\n\n        /*\n         * is a directory or is a file, but the original file the user provided\n         * looks like a directory but `path.resolve` removed the `last path.sep`\n         * so we need to still treat this like a directory\n         */\n        if (fileStats.isDirectory() || looksLikeADirectory) {\n            return getCacheFileForDirectory();\n        }\n\n        // is file so just use that file\n        return resolvedCacheFile;\n    }\n\n    /*\n     * here we known the file or directory doesn't exist,\n     * so we will try to infer if its a directory if it looks like a directory\n     * for the current operating system.\n     */\n\n    // if the last character passed is a path separator we assume is a directory\n    if (looksLikeADirectory) {\n        return getCacheFileForDirectory();\n    }\n\n    return resolvedCacheFile;\n}\n\n//------------------------------------------------------------------------------\n// Public Interface\n//------------------------------------------------------------------------------\n\n/**\n * Creates a new instance of the core CLI engine.\n * @param {CLIEngineOptions} options The options for this instance.\n * @constructor\n */\nfunction CLIEngine(options) {\n\n    options = lodash.assign(\n        Object.create(null),\n        defaultOptions,\n        {cwd: process.cwd()},\n        options\n    );\n\n    /**\n     * Stored options for this instance\n     * @type {Object}\n     */\n    this.options = options;\n\n    var cacheFile = getCacheFile(this.options.cacheLocation || this.options.cacheFile, this.options.cwd);\n\n    /**\n     * Cache used to avoid operating on files that haven't changed since the\n     * last successful execution (e.g., file passed linting with no errors and\n     * no warnings).\n     * @type {Object}\n     */\n    this._fileCache = fileEntryCache.create(cacheFile);\n\n    if (!this.options.cache) {\n        this._fileCache.destroy();\n    }\n\n    // load in additional rules\n    if (this.options.rulePaths) {\n        var cwd = this.options.cwd;\n\n        this.options.rulePaths.forEach(function(rulesdir) {\n            debug(\"Loading rules from \" + rulesdir);\n            rules.load(rulesdir, cwd);\n        });\n    }\n\n    Object.keys(this.options.rules || {}).forEach(function(name) {\n        validator.validateRuleOptions(name, this.options.rules[name], \"CLI\");\n    }.bind(this));\n}\n\n/**\n * Returns the formatter representing the given format or null if no formatter\n * with the given name can be found.\n * @param {string} [format] The name of the format to load or the path to a\n *      custom formatter.\n * @returns {Function} The formatter function or null if not found.\n */\nCLIEngine.getFormatter = function(format) {\n\n    var formatterPath;\n\n    // default is stylish\n    format = format || \"stylish\";\n\n    // only strings are valid formatters\n    if (typeof format === \"string\") {\n\n        // replace \\ with / for Windows compatibility\n        format = format.replace(/\\\\/g, \"/\");\n\n        // if there's a slash, then it's a file\n        if (format.indexOf(\"/\") > -1) {\n            var cwd = this.options ? this.options.cwd : process.cwd();\n\n            formatterPath = path.resolve(cwd, format);\n        } else {\n            formatterPath = \"./formatters/\" + format;\n        }\n\n        try {\n            return require(formatterPath);\n        } catch (ex) {\n            ex.message = \"There was a problem loading formatter: \" + formatterPath + \"\\nError: \" + ex.message;\n            throw ex;\n        }\n\n    } else {\n        return null;\n    }\n};\n\n/**\n * Returns results that only contains errors.\n * @param {LintResult[]} results The results to filter.\n * @returns {LintResult[]} The filtered results.\n */\nCLIEngine.getErrorResults = function(results) {\n    var filtered = [];\n\n    results.forEach(function(result) {\n        var filteredMessages = result.messages.filter(isErrorMessage);\n\n        if (filteredMessages.length > 0) {\n            filtered.push({\n                filePath: result.filePath,\n                messages: filteredMessages,\n                errorCount: filteredMessages.length,\n                warningCount: 0\n            });\n        }\n    });\n\n    return filtered;\n};\n\n/**\n * Outputs fixes from the given results to files.\n * @param {Object} report The report object created by CLIEngine.\n * @returns {void}\n */\nCLIEngine.outputFixes = function(report) {\n    report.results.filter(function(result) {\n        return result.hasOwnProperty(\"output\");\n    }).forEach(function(result) {\n        fs.writeFileSync(result.filePath, result.output);\n    });\n};\n\nCLIEngine.prototype = {\n\n    constructor: CLIEngine,\n\n    /**\n     * Add a plugin by passing it's configuration\n     * @param {string} name Name of the plugin.\n     * @param {Object} pluginobject Plugin configuration object.\n     * @returns {void}\n     */\n    addPlugin: function(name, pluginobject) {\n        Plugins.define(name, pluginobject);\n    },\n\n    /**\n     * Resolves the patterns passed into executeOnFiles() into glob-based patterns\n     * for easier handling.\n     * @param {string[]} patterns The file patterns passed on the command line.\n     * @returns {string[]} The equivalent glob patterns.\n     */\n    resolveFileGlobPatterns: function(patterns) {\n        return globUtil.resolveFileGlobPatterns(patterns, this.options);\n    },\n\n    /**\n     * Executes the current configuration on an array of file and directory names.\n     * @param {string[]} patterns An array of file and directory names.\n     * @returns {Object} The results for all files that were linted.\n     */\n    executeOnFiles: function(patterns) {\n        var results = [],\n            processed = {},\n            options = this.options,\n            fileCache = this._fileCache,\n            configHelper = new Config(options),\n            fileList,\n            stats,\n            startTime,\n            prevConfig; // the previous configuration used\n\n        /**\n         * Calculates the hash of the config file used to validate a given file\n         * @param  {string} filename The path of the file to retrieve a config object for to calculate the hash\n         * @returns {string}         the hash of the config\n         */\n        function hashOfConfigFor(filename) {\n            var config = configHelper.getConfig(filename);\n\n            if (!prevConfig) {\n                prevConfig = {};\n            }\n\n            // reuse the previously hashed config if the config hasn't changed\n            if (prevConfig.config !== config) {\n\n                /*\n                 * config changed so we need to calculate the hash of the config\n                 * and the hash of the plugins being used\n                 */\n                prevConfig.config = config;\n\n                var eslintVersion = pkg.version;\n\n                prevConfig.hash = hash(eslintVersion + \"_\" + stringify(config));\n            }\n\n            return prevConfig.hash;\n        }\n\n        /**\n         * Executes the linter on a file defined by the `filename`. Skips\n         * unsupported file extensions and any files that are already linted.\n         * @param {string} filename The resolved filename of the file to be linted\n         * @param {boolean} warnIgnored always warn when a file is ignored\n         * @returns {void}\n         */\n        function executeOnFile(filename, warnIgnored) {\n            var hashOfConfig;\n\n            if (warnIgnored) {\n                results.push(createIgnoreResult(filename, options.cwd));\n                return;\n            }\n\n            if (options.cache) {\n\n                /*\n                 * get the descriptor for this file\n                 * with the metadata and the flag that determines if\n                 * the file has changed\n                 */\n                var descriptor = fileCache.getFileDescriptor(filename);\n                var meta = descriptor.meta || {};\n\n                hashOfConfig = hashOfConfigFor(filename);\n\n                var changed = descriptor.changed || meta.hashOfConfig !== hashOfConfig;\n\n                if (!changed) {\n                    debug(\"Skipping file since hasn't changed: \" + filename);\n\n                    /*\n                     * Adding the filename to the processed hashmap\n                     * so the reporting is not affected (showing a warning about .eslintignore being used\n                     * when it is not really used)\n                     */\n                    processed[filename] = true;\n\n                    /*\n                     * Add the the cached results (always will be 0 error and\n                     * 0 warnings). We should not cache results for files that\n                     * failed, in order to guarantee that next execution will\n                     * process those files as well.\n                     */\n                    results.push(descriptor.meta.results);\n\n                    // move to the next file\n                    return;\n                }\n            }\n\n            debug(\"Processing \" + filename);\n\n            processed[filename] = true;\n\n            var res = processFile(filename, configHelper, options);\n\n            if (options.cache) {\n\n                /*\n                 * if a file contains errors or warnings we don't want to\n                 * store the file in the cache so we can guarantee that\n                 * next execution will also operate on this file\n                 */\n                if (res.errorCount > 0 || res.warningCount > 0) {\n                    debug(\"File has problems, skipping it: \" + filename);\n\n                    // remove the entry from the cache\n                    fileCache.removeEntry(filename);\n                } else {\n\n                    /*\n                     * since the file passed we store the result here\n                     * TODO: check this as we might not need to store the\n                     * successful runs as it will always should be 0 errors and\n                     * 0 warnings.\n                     */\n                    descriptor.meta.hashOfConfig = hashOfConfig;\n                    descriptor.meta.results = res;\n                }\n            }\n\n            results.push(res);\n        }\n\n        startTime = Date.now();\n\n\n\n        patterns = this.resolveFileGlobPatterns(patterns);\n        fileList = globUtil.listFilesToProcess(patterns, options);\n        fileList.forEach(function(fileInfo) {\n            executeOnFile(fileInfo.filename, fileInfo.ignored);\n        });\n\n        stats = calculateStatsPerRun(results);\n\n        if (options.cache) {\n\n            // persist the cache to disk\n            fileCache.reconcile();\n        }\n\n        debug(\"Linting complete in: \" + (Date.now() - startTime) + \"ms\");\n\n        return {\n            results: results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount\n        };\n    },\n\n    /**\n     * Executes the current configuration on text.\n     * @param {string} text A string of JavaScript code to lint.\n     * @param {string} filename An optional string representing the texts filename.\n     * @returns {Object} The results for the linting.\n     */\n    executeOnText: function(text, filename) {\n\n        var results = [],\n            stats,\n            options = this.options,\n            configHelper = new Config(options),\n            ignoredPaths = new IgnoredPaths(options);\n\n        // resolve filename based on options.cwd (for reporting, ignoredPaths also resolves)\n        if (filename && !isAbsolute(filename)) {\n            filename = path.resolve(options.cwd, filename);\n        }\n        if (filename && ignoredPaths.contains(filename)) {\n\n            results.push(createIgnoreResult(filename, options.cwd));\n        } else {\n            results.push(processText(text, configHelper, filename, options.fix, options.allowInlineConfig));\n        }\n\n        stats = calculateStatsPerRun(results);\n\n        return {\n            results: results,\n            errorCount: stats.errorCount,\n            warningCount: stats.warningCount\n        };\n    },\n\n    /**\n     * Returns a configuration object for the given file based on the CLI options.\n     * This is the same logic used by the ESLint CLI executable to determine\n     * configuration for each file it processes.\n     * @param {string} filePath The path of the file to retrieve a config object for.\n     * @returns {Object} A configuration object for the file.\n     */\n    getConfigForFile: function(filePath) {\n        var configHelper = new Config(this.options);\n\n        return configHelper.getConfig(filePath);\n    },\n\n    /**\n     * Checks if a given path is ignored by ESLint.\n     * @param {string} filePath The path of the file to check.\n     * @returns {boolean} Whether or not the given path is ignored.\n     */\n    isPathIgnored: function(filePath) {\n        var ignoredPaths;\n        var resolvedPath = path.resolve(this.options.cwd, filePath);\n\n        ignoredPaths = new IgnoredPaths(this.options);\n        return ignoredPaths.contains(resolvedPath);\n    },\n\n    getFormatter: CLIEngine.getFormatter\n\n};\n\nmodule.exports = CLIEngine;\n"]}