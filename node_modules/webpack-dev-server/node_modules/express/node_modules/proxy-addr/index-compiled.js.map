{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;AAMA;;;;;;AAMA,OAAO,OAAP,GAAiB,SAAjB;AACA,OAAO,OAAP,CAAe,GAAf,GAAqB,QAArB;AACA,OAAO,OAAP,CAAe,OAAf,GAAyB,OAAzB;;;;;;AAMA,IAAI,YAAY,QAAQ,WAAR,CAAhB;AACA,IAAI,SAAS,QAAQ,WAAR,CAAb;;;;;;AAMA,IAAI,UAAU,UAAd;AACA,IAAI,OAAO,OAAO,OAAlB;AACA,IAAI,UAAU,OAAO,KAArB;;;;;;AAMA,IAAI,WAAW;AACb,aAAW,CAAC,gBAAD,EAAmB,WAAnB,CADE;AAEb,YAAU,CAAC,aAAD,EAAgB,SAAhB,CAFG;AAGb,eAAa,CAAC,YAAD,EAAe,eAAf,EAAgC,gBAAhC,EAAkD,UAAlD;AAHA,CAAf;;;;;;;;;;;AAeA,SAAS,QAAT,CAAkB,GAAlB,EAAuB,KAAvB,EAA8B;;AAE5B,MAAI,QAAQ,UAAU,GAAV,CAAZ;;AAEA,MAAI,CAAC,KAAL,EAAY;;AAEV,WAAO,KAAP;AACD;;AAED,MAAI,OAAO,KAAP,KAAiB,UAArB,EAAiC;AAC/B,YAAQ,QAAQ,KAAR,CAAR;AACD;;AAED,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAAN,GAAe,CAAnC,EAAsC,GAAtC,EAA2C;AACzC,QAAI,MAAM,MAAM,CAAN,CAAN,EAAgB,CAAhB,CAAJ,EAAwB;;AAExB,UAAM,MAAN,GAAe,IAAI,CAAnB;AACD;;AAED,SAAO,KAAP;AACD;;;;;;;;;AASD,SAAS,OAAT,CAAiB,GAAjB,EAAsB;AACpB,MAAI,CAAC,GAAL,EAAU;AACR,UAAM,IAAI,SAAJ,CAAc,sBAAd,CAAN;AACD;;AAED,MAAI,QAAQ,OAAO,GAAP,KAAe,QAAf,GACR,CAAC,GAAD,CADQ,GAER,GAFJ;;AAIA,MAAI,CAAC,MAAM,OAAN,CAAc,KAAd,CAAL,EAA2B;AACzB,UAAM,IAAI,SAAJ,CAAc,4BAAd,CAAN;AACD;;AAED,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACrC,UAAM,MAAM,CAAN,CAAN;;AAEA,QAAI,CAAC,SAAS,cAAT,CAAwB,GAAxB,CAAL,EAAmC;AACjC;AACD;;;AAGD,UAAM,SAAS,GAAT,CAAN;AACA,UAAM,MAAN,CAAa,KAAb,CAAmB,KAAnB,EAA0B,CAAC,CAAD,EAAI,CAAJ,EAAO,MAAP,CAAc,GAAd,CAA1B;AACA,SAAK,IAAI,MAAJ,GAAa,CAAlB;AACD;;AAED,SAAO,aAAa,oBAAoB,KAApB,CAAb,CAAP;AACD;;;;;;;;;AASD,SAAS,mBAAT,CAA6B,GAA7B,EAAkC;AAChC,MAAI,eAAe,IAAI,KAAJ,CAAU,IAAI,MAAd,CAAnB;;AAEA,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,IAAI,MAAxB,EAAgC,GAAhC,EAAqC;AACnC,iBAAa,CAAb,IAAkB,gBAAgB,IAAI,CAAJ,CAAhB,CAAlB;AACD;;AAED,SAAO,YAAP;AACD;;;;;;;;;AASD,SAAS,YAAT,CAAsB,YAAtB,EAAoC;;AAElC,MAAI,MAAM,aAAa,MAAvB;AACA,SAAO,QAAQ,CAAR,GACH,SADG,GAEH,QAAQ,CAAR,GACA,YAAY,aAAa,CAAb,CAAZ,CADA,GAEA,WAAW,YAAX,CAJJ;AAKD;;;;;;;;;AASD,SAAS,eAAT,CAAyB,IAAzB,EAA+B;AAC7B,MAAI,EAAJ;AACA,MAAI,IAAJ;AACA,MAAI,GAAJ;AACA,MAAI,MAAM,KAAK,WAAL,CAAiB,GAAjB,CAAV;AACA,MAAI,KAAJ;;AAEA,OAAK,QAAQ,CAAC,CAAT,GACD,KAAK,SAAL,CAAe,CAAf,EAAkB,GAAlB,CADC,GAED,IAFJ;;AAIA,MAAI,CAAC,KAAK,EAAL,CAAL,EAAe;AACb,UAAM,IAAI,SAAJ,CAAc,yBAAyB,EAAvC,CAAN;AACD;;AAED,OAAK,QAAQ,EAAR,CAAL;;AAEA,SAAO,GAAG,IAAH,EAAP;AACA,QAAM,SAAS,MAAT,GACF,GADE,GAEF,EAFJ;;AAIA,UAAQ,QAAQ,CAAC,CAAT,GACJ,KAAK,SAAL,CAAe,MAAM,CAArB,EAAwB,KAAK,MAA7B,CADI,GAEJ,GAFJ;;AAIA,MAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAQ,QAAQ,IAAR,CAAa,KAAb,IACJ,SAAS,KAAT,EAAgB,EAAhB,CADI,GAEJ,KAAK,KAAL,IACA,aAAa,KAAb,CADA,GAEA,CAJJ;AAKD;;AAED,MAAI,GAAG,IAAH,OAAc,MAAd,IAAwB,GAAG,mBAAH,EAA5B,EAAsD;;AAEpD,SAAK,GAAG,aAAH,EAAL;AACA,YAAQ,SAAS,GAAT,GACJ,QAAQ,EADJ,GAEJ,KAFJ;AAGD;;AAED,MAAI,SAAS,CAAT,IAAc,QAAQ,GAA1B,EAA+B;AAC7B,UAAM,IAAI,SAAJ,CAAc,+BAA+B,IAA7C,CAAN;AACD;;AAED,SAAO,CAAC,EAAD,EAAK,KAAL,CAAP;AACD;;;;;;;;;AASD,SAAS,YAAT,CAAsB,OAAtB,EAA+B;AAC7B,MAAI,KAAK,QAAQ,OAAR,CAAT;AACA,MAAI,KAAJ;AACA,MAAI,IAAJ;;AAEA,UAAQ,GAAG,IAAH,EAAR;AACE,SAAK,MAAL;AACE,cAAQ,GAAG,MAAX;AACA,aAAO,CAAP;AACA;AACF,SAAK,MAAL;AACE,cAAQ,GAAG,KAAX;AACA,aAAO,EAAP;AACA;AARJ;;AAWA,MAAI,MAAM,KAAK,GAAL,CAAS,CAAT,EAAY,IAAZ,IAAoB,CAA9B;AACA,MAAI,IAAJ;AACA,MAAI,QAAQ,CAAZ;;AAEA,OAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,MAAM,MAA1B,EAAkC,GAAlC,EAAuC;AACrC,WAAO,MAAM,CAAN,IAAW,GAAlB;;AAEA,QAAI,SAAS,GAAb,EAAkB;AAChB,eAAS,IAAT;AACA;AACD;;AAED,WAAO,IAAP,EAAa;AACX,aAAQ,QAAQ,CAAT,GAAc,GAArB;AACA,eAAS,CAAT;AACD;;AAED;AACD;;AAED,SAAO,KAAP;AACD;;;;;;;;;;AAUD,SAAS,SAAT,CAAmB,GAAnB,EAAwB,KAAxB,EAA+B;AAC7B,MAAI,CAAC,GAAL,EAAU;AACR,UAAM,IAAI,SAAJ,CAAc,0BAAd,CAAN;AACD;;AAED,MAAI,CAAC,KAAL,EAAY;AACV,UAAM,IAAI,SAAJ,CAAc,4BAAd,CAAN;AACD;;AAED,MAAI,QAAQ,SAAS,GAAT,EAAc,KAAd,CAAZ;AACA,MAAI,OAAO,MAAM,MAAM,MAAN,GAAe,CAArB,CAAX;;AAEA,SAAO,IAAP;AACD;;;;;;;;AAQD,SAAS,SAAT,GAAqB;AACnB,SAAO,KAAP;AACD;;;;;;;;;AASD,SAAS,UAAT,CAAoB,OAApB,EAA6B;AAC3B,SAAO,SAAS,KAAT,CAAe,IAAf,EAAqB;AAC1B,QAAI,CAAC,KAAK,IAAL,CAAL,EAAiB,OAAO,KAAP;;AAEjB,QAAI,KAAK,QAAQ,IAAR,CAAT;AACA,QAAI,IAAJ;AACA,QAAI,OAAO,GAAG,IAAH,EAAX;AACA,QAAI,MAAJ;AACA,QAAI,QAAJ;AACA,QAAI,UAAJ;AACA,QAAI,WAAJ;AACA,QAAI,OAAJ;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,QAAQ,MAA5B,EAAoC,GAApC,EAAyC;AACvC,eAAS,QAAQ,CAAR,CAAT;AACA,iBAAW,OAAO,CAAP,CAAX;AACA,mBAAa,SAAS,IAAT,EAAb;AACA,oBAAc,OAAO,CAAP,CAAd;AACA,gBAAU,EAAV;;AAEA,UAAI,SAAS,UAAb,EAAyB;AACvB,YAAI,SAAS,MAAT,IAAmB,eAAe,MAAlC,IAA4C,CAAC,GAAG,mBAAH,EAAjD,EAA2E;AACzE;AACD;;;AAGD,eAAO,QAAQ,GAAG,aAAH,EAAf;AACA,kBAAU,IAAV;AACD;;AAED,UAAI,QAAQ,KAAR,CAAc,QAAd,EAAwB,WAAxB,CAAJ,EAA0C,OAAO,IAAP;AAC3C;;AAED,WAAO,KAAP;AACD,GAjCD;AAkCD;;;;;;;;;AASD,SAAS,WAAT,CAAqB,MAArB,EAA6B;AAC3B,MAAI,WAAW,OAAO,CAAP,CAAf;AACA,MAAI,aAAa,SAAS,IAAT,EAAjB;AACA,MAAI,eAAe,eAAe,MAAlC;AACA,MAAI,cAAc,OAAO,CAAP,CAAlB;;AAEA,SAAO,SAAS,KAAT,CAAe,IAAf,EAAqB;AAC1B,QAAI,CAAC,KAAK,IAAL,CAAL,EAAiB,OAAO,KAAP;;AAEjB,QAAI,KAAK,QAAQ,IAAR,CAAT;AACA,QAAI,OAAO,GAAG,IAAH,EAAX;;AAEA,WAAO,SAAS,UAAT,GACH,GAAG,KAAH,CAAS,QAAT,EAAmB,WAAnB,CADG,GAEH,gBAAgB,SAAS,MAAzB,IAAmC,GAAG,mBAAH,EAAnC,GACA,GAAG,aAAH,GAAmB,KAAnB,CAAyB,QAAzB,EAAmC,WAAnC,CADA,GAEA,KAJJ;AAKD,GAXD;AAYD","file":"index-compiled.js","sourcesContent":["/*!\n * proxy-addr\n * Copyright(c) 2014 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module exports.\n */\n\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\n\n/**\n * Module dependencies.\n */\n\nvar forwarded = require('forwarded');\nvar ipaddr = require('ipaddr.js');\n\n/**\n * Variables.\n */\n\nvar digitre = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\n\n/**\n * Pre-defined IP ranges.\n */\n\nvar ipranges = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n\n/**\n * Get all addresses in the request, optionally stopping\n * at the first untrusted.\n *\n * @param {Object} request\n * @param {Function|Array|String} [trust]\n * @api public\n */\n\nfunction alladdrs(req, trust) {\n  // get addresses\n  var addrs = forwarded(req);\n\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n\n    addrs.length = i + 1;\n  }\n\n  return addrs;\n}\n\n/**\n * Compile argument into trust function.\n *\n * @param {Array|String} val\n * @api private\n */\n\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n\n  var trust = typeof val === 'string'\n    ? [val]\n    : val;\n\n  if (!Array.isArray(trust)) {\n    throw new TypeError('unsupported trust argument');\n  }\n\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n\n    if (!ipranges.hasOwnProperty(val)) {\n      continue;\n    }\n\n    // Splice in pre-defined range\n    val = ipranges[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n\n  return compileTrust(compileRangeSubnets(trust));\n}\n\n/**\n * Compile `arr` elements into range subnets.\n *\n * @param {Array} arr\n * @api private\n */\n\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n\n  return rangeSubnets;\n}\n\n/**\n * Compile range subnet array into trust function.\n *\n * @param {Array} rangeSubnets\n * @api private\n */\n\nfunction compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0\n    ? trustNone\n    : len === 1\n    ? trustSingle(rangeSubnets[0])\n    : trustMulti(rangeSubnets);\n}\n\n/**\n * Parse IP notation string into range subnet.\n *\n * @param {String} note\n * @api private\n */\n\nfunction parseipNotation(note) {\n  var ip;\n  var kind;\n  var max;\n  var pos = note.lastIndexOf('/');\n  var range;\n\n  ip = pos !== -1\n    ? note.substring(0, pos)\n    : note;\n\n  if (!isip(ip)) {\n    throw new TypeError('invalid IP address: ' + ip);\n  }\n\n  ip = parseip(ip);\n\n  kind = ip.kind();\n  max = kind === 'ipv6'\n    ? 128\n    : 32;\n\n  range = pos !== -1\n    ? note.substring(pos + 1, note.length)\n    : max;\n\n  if (typeof range !== 'number') {\n    range = digitre.test(range)\n      ? parseInt(range, 10)\n      : isip(range)\n      ? parseNetmask(range)\n      : 0;\n  }\n\n  if (ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n    range = range <= max\n      ? range - 96\n      : range;\n  }\n\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n\n  return [ip, range];\n}\n\n/**\n * Parse netmask string into CIDR range.\n *\n * @param {String} note\n * @api private\n */\n\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var parts;\n  var size;\n\n  switch (ip.kind()) {\n    case 'ipv4':\n      parts = ip.octets;\n      size = 8;\n      break;\n    case 'ipv6':\n      parts = ip.parts;\n      size = 16;\n      break;\n  }\n\n  var max = Math.pow(2, size) - 1;\n  var part;\n  var range = 0;\n\n  for (var i = 0; i < parts.length; i++) {\n    part = parts[i] & max;\n\n    if (part === max) {\n      range += size;\n      continue;\n    }\n\n    while (part) {\n      part = (part << 1) & max;\n      range += 1;\n    }\n\n    break;\n  }\n\n  return range;\n}\n\n/**\n * Determine address of proxied request.\n *\n * @param {Object} request\n * @param {Function|Array|String} trust\n * @api public\n */\n\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n\n  return addr;\n}\n\n/**\n * Static trust function to trust nothing.\n *\n * @api private\n */\n\nfunction trustNone() {\n  return false;\n}\n\n/**\n * Compile trust function for multiple subnets.\n *\n * @param {Array} subnets\n * @api private\n */\n\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n\n    var ip = parseip(addr);\n    var ipv4;\n    var kind = ip.kind();\n    var subnet;\n    var subnetip;\n    var subnetkind;\n    var subnetrange;\n    var trusted;\n\n    for (var i = 0; i < subnets.length; i++) {\n      subnet = subnets[i];\n      subnetip = subnet[0];\n      subnetkind = subnetip.kind();\n      subnetrange = subnet[1];\n      trusted = ip;\n\n      if (kind !== subnetkind) {\n        if (kind !== 'ipv6' || subnetkind !== 'ipv4' || !ip.isIPv4MappedAddress()) {\n          continue;\n        }\n\n        // Store addr as IPv4\n        ipv4 = ipv4 || ip.toIPv4Address();\n        trusted = ipv4;\n      }\n\n      if (trusted.match(subnetip, subnetrange)) return true;\n    }\n\n    return false;\n  };\n}\n\n/**\n * Compile trust function for single subnet.\n *\n * @param {Object} subnet\n * @api private\n */\n\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n\n    var ip = parseip(addr);\n    var kind = ip.kind();\n\n    return kind === subnetkind\n      ? ip.match(subnetip, subnetrange)\n      : subnetisipv4 && kind === 'ipv6' && ip.isIPv4MappedAddress()\n      ? ip.toIPv4Address().match(subnetip, subnetrange)\n      : false;\n  };\n}\n"]}